<!DOCTYPE html>
<html>
<head>
<title>Rust Compiler Error Index</title>
<meta charset="utf-8">
<!-- Include rust.css after main.css so its rules take priority. -->
<link rel="stylesheet" type="text/css" href="main.css"/>
<link rel="stylesheet" type="text/css" href="rust.css"/>
<style>
.error-undescribed {
    display: none;
}
</style>
</head>
<body>
<h1>Rust Compiler Error Index</h1>
<div class="error-described error-used"><h2 id="E0001" class="section-header"><a href="#E0001">E0001</a></h2>
<p>This error suggests that the expression arm corresponding to the noted pattern
will never be reached as for all possible values of the expression being
matched, one of the preceding patterns will match.</p>

<p>This means that perhaps some of the preceding patterns are too general, this one
is too specific or the ordering is incorrect.</p>

<p>For example, the following <code>match</code> block has too many arms:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>foo</span> {
    <span class='prelude-val'>Some</span>(<span class='ident'>bar</span>) <span class='op'>=&gt;</span> {<span class='comment'>/* ... */</span>}
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {<span class='comment'>/* ... */</span>}
    _ <span class='op'>=&gt;</span> {<span class='comment'>/* ... */</span>} <span class='comment'>// All possible cases have already been handled</span>
}</pre>

<p><code>match</code> blocks have their patterns matched in order, so, for example, putting
a wildcard arm above a more specific arm will make the latter arm irrelevant.</p>

<p>Ensure the ordering of the match arm is correct and remove any superfluous
arms.</p>
</div>
<div class="error-described error-used"><h2 id="E0002" class="section-header"><a href="#E0002">E0002</a></h2>
<p>This error indicates that an empty match expression is invalid because the type
it is matching on is non-empty (there exist values of this type). In safe code
it is impossible to create an instance of an empty type, so empty match
expressions are almost never desired. This error is typically fixed by adding
one or more cases to the match expression.</p>

<p>An example of an empty type is <code>enum Empty { }</code>. So, the following will work:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>Empty</span>) {
    <span class='kw'>match</span> <span class='ident'>x</span> {
        <span class='comment'>// empty</span>
    }
}</pre>

<p>However, this won&#39;t:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span>) {
    <span class='kw'>match</span> <span class='ident'>x</span> {
        <span class='comment'>// empty</span>
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0003" class="section-header"><a href="#E0003">E0003</a></h2>
<p>Not-a-Number (NaN) values cannot be compared for equality and hence can never
match the input to a match expression. So, the following will not compile:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>NAN</span>: <span class='ident'>f32</span> <span class='op'>=</span> <span class='number'>0.0</span> <span class='op'>/</span> <span class='number'>0.0</span>;

<span class='kw'>match</span> <span class='ident'>number</span> {
    <span class='ident'>NAN</span> <span class='op'>=&gt;</span> { <span class='comment'>/* ... */</span> },
    <span class='comment'>// ...</span>
}</pre>

<p>To match against NaN values, you should instead use the <code>is_nan()</code> method in a
guard, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>number</span> {
    <span class='comment'>// ...</span>
    <span class='ident'>x</span> <span class='kw'>if</span> <span class='ident'>x</span>.<span class='ident'>is_nan</span>() <span class='op'>=&gt;</span> { <span class='comment'>/* ... */</span> }
    <span class='comment'>// ...</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0004" class="section-header"><a href="#E0004">E0004</a></h2>
<p>This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution.</p>

<p>If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore <code>_</code> wildcard pattern can be added after all other patterns to match
&quot;anything else&quot;.</p>
</div>
<div class="error-described error-used"><h2 id="E0005" class="section-header"><a href="#E0005">E0005</a></h2>
<p>Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases. If you encounter this error you
probably need to use a <code>match</code> or <code>if let</code> to deal with the possibility of
failure.</p>
</div>
<div class="error-described error-used"><h2 id="E0007" class="section-header"><a href="#E0007">E0007</a></h2>
<p>This error indicates that the bindings in a match arm would require a value to
be moved into more than one location, thus violating unique ownership. Code like
the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be moved
into a variable called <code>op_string</code> while simultaneously requiring the inner
String to be moved into a variable called <code>s</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;s&quot;</span>.<span class='ident'>to_string</span>());
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>op_string</span> <span class='kw-2'>@</span> <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='op'>=&gt;</span> ...
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
}</pre>

<p>See also Error 303.</p>
</div>
<div class="error-described error-used"><h2 id="E0008" class="section-header"><a href="#E0008">E0008</a></h2>
<p>Names bound in match arms retain their type in pattern guards. As such, if a
name is bound by move in a pattern, it should also be moved to wherever it is
referenced in the pattern guard code. Doing so however would prevent the name
from being available in the body of the match arm. Consider the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='kw'>if</span> <span class='ident'>s</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='comment'>// use s.</span>
    ...
}</pre>

<p>The variable <code>s</code> has type <code>String</code>, and its use in the guard is as a variable of
type <code>String</code>. The guard code effectively executes in a separate scope to the
body of the arm, so the value would be moved into this anonymous scope and
therefore become unavailable in the body of the arm. Although this example seems
innocuous, the problem is most clear when considering functions that take their
argument by value.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='kw'>if</span> { <span class='ident'>drop</span>(<span class='ident'>s</span>); <span class='boolval'>false</span> } <span class='op'>=&gt;</span> (),
    <span class='prelude-val'>Some</span>(<span class='ident'>s</span>) <span class='op'>=&gt;</span> <span class='comment'>// use s.</span>
    ...
}</pre>

<p>The value would be dropped in the guard then become unavailable not only in the
body of that arm but also in all subsequent arms! The solution is to bind by
reference when using guards or refactor the entire expression, perhaps by
putting the condition inside the body of the arm.</p>
</div>
<div class="error-described error-used"><h2 id="E0009" class="section-header"><a href="#E0009">E0009</a></h2>
<p>In a pattern, all values that don&#39;t implement the <code>Copy</code> trait have to be bound
the same way. The goal here is to avoid binding simultaneously by-move and
by-ref.</p>

<p>This limitation may be removed in a future version of Rust.</p>

<p>Wrong example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>X</span> { <span class='ident'>x</span>: (), }

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>((<span class='ident'>X</span> { <span class='ident'>x</span>: () }, <span class='ident'>X</span> { <span class='ident'>x</span>: () }));
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>((<span class='ident'>y</span>, <span class='kw-2'>ref</span> <span class='ident'>z</span>)) <span class='op'>=&gt;</span> {},
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>()
}</pre>

<p>You have two solutions:</p>

<p>Solution #1: Bind the pattern&#39;s values the same way.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>X</span> { <span class='ident'>x</span>: (), }

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>((<span class='ident'>X</span> { <span class='ident'>x</span>: () }, <span class='ident'>X</span> { <span class='ident'>x</span>: () }));
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>((<span class='kw-2'>ref</span> <span class='ident'>y</span>, <span class='kw-2'>ref</span> <span class='ident'>z</span>)) <span class='op'>=&gt;</span> {},
    <span class='comment'>// or Some((y, z)) =&gt; {}</span>
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>()
}</pre>

<p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p>

<p>However, please keep in mind that the first solution should be preferred.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Clone</span>, <span class='ident'>Copy</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>X</span> { <span class='ident'>x</span>: (), }

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>((<span class='ident'>X</span> { <span class='ident'>x</span>: () }, <span class='ident'>X</span> { <span class='ident'>x</span>: () }));
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>((<span class='ident'>y</span>, <span class='kw-2'>ref</span> <span class='ident'>z</span>)) <span class='op'>=&gt;</span> {},
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>()
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0010" class="section-header"><a href="#E0010">E0010</a></h2>
<p>The value of statics and constants must be known at compile time, and they live
for the entire lifetime of a program. Creating a boxed value allocates memory on
the heap at runtime, and therefore cannot be done at compile time. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>box_syntax</span>)]</span>

<span class='kw'>const</span> <span class='ident'>CON</span> : <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>0</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0011" class="section-header"><a href="#E0011">E0011</a></h2>
<p>Initializers for constants and statics are evaluated at compile time.
User-defined operators rely on user-defined functions, which cannot be evaluated
at compile time.</p>

<p>Bad example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Index</span>;

<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='ident'>u8</span> }

<span class='kw'>impl</span> <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>u8</span>;

    <span class='kw'>fn</span> <span class='ident'>index</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='self'>self</span>, <span class='ident'>idx</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>u8</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>a</span> }
}

<span class='kw'>const</span> <span class='ident'>a</span>: <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='number'>0u8</span> };
<span class='kw'>const</span> <span class='ident'>b</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='ident'>a</span>[<span class='number'>0</span>]; <span class='comment'>// Index trait is defined by the user, bad!</span></pre>

<p>Only operators on builtin types are allowed.</p>

<p>Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> [<span class='ident'>i32</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>const</span> <span class='ident'>b</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>a</span>[<span class='number'>0</span>]; <span class='comment'>// Good!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0013" class="section-header"><a href="#E0013">E0013</a></h2>
<p>Static and const variables can refer to other const variables. But a const
variable cannot refer to a static variable. For example, <code>Y</code> cannot refer to <code>X</code>
here:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>X</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>X</span>;</pre>

<p>To fix this, the value can be extracted as a const and then used:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>A</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>static</span> <span class='ident'>X</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>A</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>A</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0014" class="section-header"><a href="#E0014">E0014</a></h2>
<p>Constants can only be initialized by a constant value or, in a future
version of Rust, a call to a const function. This error indicates the use
of a path (like a::b, or x) denoting something other than one of these
allowed items. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>x</span> }; <span class='comment'>// &#39;x&#39; isn&#39;t a constant nor a function!</span></pre>

<p>To avoid it, you have to replace the non-constant value:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>const</span> <span class='ident'>X</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>X</span> };
<span class='comment'>// or even:</span>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='number'>0</span> }; <span class='comment'>// but brackets are useless here</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0015" class="section-header"><a href="#E0015">E0015</a></h2>
<p>The only functions that can be called in static or constant expressions are
<code>const</code> functions, and struct/enum constructors. <code>const</code> functions are only
available on a nightly compiler. Rust currently does not support more general
compile-time function execution.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>(<span class='number'>1</span>); <span class='comment'>// enum constructor</span>
<span class='kw'>struct</span> <span class='ident'>Bar</span> {<span class='ident'>x</span>: <span class='ident'>u8</span>}
<span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>Bar</span> <span class='op'>=</span> <span class='ident'>Bar</span> {<span class='ident'>x</span>: <span class='number'>1</span>}; <span class='comment'>// struct constructor</span></pre>

<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md">RFC 911</a> for more details on the design of <code>const fn</code>s.</p>
</div>
<div class="error-described error-used"><h2 id="E0016" class="section-header"><a href="#E0016">E0016</a></h2>
<p>Blocks in constants may only contain items (such as constant, function
definition, etc...) and a tail expression. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>x</span> }; <span class='comment'>// &#39;x&#39; isn&#39;t an item!</span></pre>

<p>To avoid it, you have to replace the non-item object:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>i32</span> <span class='op'>=</span> { <span class='kw'>const</span> <span class='ident'>X</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>X</span> };</pre>
</div>
<div class="error-described error-used"><h2 id="E0017" class="section-header"><a href="#E0017">E0017</a></h2>
<p>References in statics and constants may only refer to immutable values. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>X</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>const</span> <span class='ident'>C</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>2</span>;

<span class='comment'>// these three are not allowed:</span>
<span class='kw'>const</span> <span class='ident'>CR</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='kw-2'>mut</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>C</span>;
<span class='kw'>static</span> <span class='ident'>STATIC_REF</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='kw-2'>mut</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>X</span>;
<span class='kw'>static</span> <span class='ident'>CONST_REF</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='kw-2'>mut</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>C</span>;</pre>

<p>Statics are shared everywhere, and if they refer to mutable data one might
violate memory safety since holding multiple mutable references to shared data
is not allowed.</p>

<p>If you really want global mutable state, try using <code>static mut</code> or a global
<code>UnsafeCell</code>.</p>
</div>
<div class="error-described error-used"><h2 id="E0018" class="section-header"><a href="#E0018">E0018</a></h2>
<p>The value of static and const variables must be known at compile time. You
can&#39;t cast a pointer as an integer because we can&#39;t know what value the
address will take.</p>

<p>However, pointers to other constants&#39; addresses are allowed in constants,
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>50</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>X</span>;</pre>

<p>Therefore, casting one of these non-constant pointers to an integer results
in a non-constant integer which lead to this error. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>usize</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>X</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span> <span class='kw'>as</span> <span class='ident'>usize</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>Y</span>);</pre>
</div>
<div class="error-described error-used"><h2 id="E0019" class="section-header"><a href="#E0019">E0019</a></h2>
<p>A function call isn&#39;t allowed in the const&#39;s initialization expression
because the expression&#39;s value must be known at compile-time. Example of
erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Test</span> {
    <span class='ident'>V1</span>
}

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>test</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='number'>12</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>Test</span> <span class='op'>=</span> <span class='ident'>Test</span>::<span class='ident'>V1</span>;

    <span class='kw'>const</span> <span class='ident'>A</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>FOO</span>.<span class='ident'>test</span>(); <span class='comment'>// You can&#39;t call Test::func() here !</span>
}</pre>

<p>Remember: you can&#39;t use a function call inside a const&#39;s initialization
expression! However, you can totally use it anywhere else:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>const</span> <span class='ident'>FOO</span>: <span class='ident'>Test</span> <span class='op'>=</span> <span class='ident'>Test</span>::<span class='ident'>V1</span>;

    <span class='ident'>FOO</span>.<span class='ident'>func</span>(); <span class='comment'>// here is good</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>FOO</span>.<span class='ident'>func</span>(); <span class='comment'>// or even here!</span>
}</pre>
</div>
<div class="error-described error-unused"><h2 id="E0020" class="section-header"><a href="#E0020">E0020</a></h2>
<p>This error indicates that an attempt was made to divide by zero (or take the
remainder of a zero divisor) in a static or constant expression. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span> <span class='op'>/</span> <span class='number'>0</span>;
<span class='comment'>// error: attempted to divide by zero in a constant expression</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0022" class="section-header"><a href="#E0022">E0022</a></h2>
<p>Constant functions are not allowed to mutate anything. Thus, binding to an
argument with a mutable pattern is not allowed. For example,</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>u8</span>) {
    <span class='comment'>// do stuff</span>
}</pre>

<p>is bad because the function body may not mutate <code>x</code>.</p>

<p>Remove any mutable bindings from the argument list to fix this error. In case
you need to mutate the argument, try lazily initializing a global variable
instead of using a <code>const fn</code>, or refactoring the code to a functional style to
avoid mutation if possible.</p>
</div>
<div class="error-described error-used"><h2 id="E0023" class="section-header"><a href="#E0023">E0023</a></h2>
<p>A pattern used to match against an enum variant must provide a sub-pattern for
each field of the enum variant. This error indicates that a pattern attempted to
extract an incorrect number of fields from a variant.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Fruit</span> {
    <span class='ident'>Apple</span>(<span class='ident'>String</span>, <span class='ident'>String</span>)
    <span class='ident'>Pear</span>(<span class='ident'>u32</span>)
}</pre>

<p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Correct.</span>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>Apple</span>(<span class='ident'>a</span>, <span class='ident'>b</span>) <span class='op'>=&gt;</span> ...
}</pre>

<p>Matching with the wrong number of fields has no sensible interpretation:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Incorrect.</span>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>Apple</span>(<span class='ident'>a</span>) <span class='op'>=&gt;</span> ...,
    <span class='ident'>Apple</span>(<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>) <span class='op'>=&gt;</span> ...
}</pre>

<p>Check how many fields the enum was declared with and ensure that your pattern
uses the same number.</p>
</div>
<div class="error-described error-used"><h2 id="E0024" class="section-header"><a href="#E0024">E0024</a></h2>
<p>This error indicates that a pattern attempted to extract the fields of an enum
variant with no fields. Here&#39;s a tiny example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This enum has two variants.</span>
<span class='kw'>enum</span> <span class='ident'>Number</span> {
    <span class='comment'>// This variant has no fields.</span>
    <span class='ident'>Zero</span>,
    <span class='comment'>// This variant has one field.</span>
    <span class='ident'>One</span>(<span class='ident'>u32</span>)
}

<span class='comment'>// Assuming x is a Number we can pattern match on its contents.</span>
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='ident'>Zero</span>(<span class='ident'>inside</span>) <span class='op'>=&gt;</span> ...,
    <span class='ident'>One</span>(<span class='ident'>inside</span>) <span class='op'>=&gt;</span> ...
}</pre>

<p>The pattern match <code>Zero(inside)</code> is incorrect because the <code>Zero</code> variant
contains no fields, yet the <code>inside</code> name attempts to bind the first field of
the enum.</p>
</div>
<div class="error-described error-used"><h2 id="E0025" class="section-header"><a href="#E0025">E0025</a></h2>
<p>Each field of a struct can only be bound once in a pattern. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>u8</span>,
    <span class='ident'>b</span>: <span class='ident'>u8</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>(){
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>:<span class='number'>1</span>, <span class='ident'>b</span>:<span class='number'>2</span> };

    <span class='kw'>let</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='ident'>x</span>, <span class='ident'>a</span>: <span class='ident'>y</span> } <span class='op'>=</span> <span class='ident'>x</span>;
    <span class='comment'>// error: field `a` bound multiple times in the pattern</span>
}</pre>

<p>Each occurrence of a field name binds the value of that field, so to fix this
error you will have to remove or alter the duplicate uses of the field name.
Perhaps you misspelled another field name? Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>u8</span>,
    <span class='ident'>b</span>: <span class='ident'>u8</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>(){
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>:<span class='number'>1</span>, <span class='ident'>b</span>:<span class='number'>2</span> };

    <span class='kw'>let</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='ident'>x</span>, <span class='ident'>b</span>: <span class='ident'>y</span> } <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0026" class="section-header"><a href="#E0026">E0026</a></h2>
<p>This error indicates that a struct pattern attempted to extract a non-existent
field from a struct. Struct fields are identified by the name used before the
colon <code>:</code> so struct patterns should resemble the declaration of the struct type
being matched.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Correct matching.</span>
<span class='kw'>struct</span> <span class='ident'>Thing</span> {
    <span class='ident'>x</span>: <span class='ident'>u32</span>,
    <span class='ident'>y</span>: <span class='ident'>u32</span>
}

<span class='kw'>let</span> <span class='ident'>thing</span> <span class='op'>=</span> <span class='ident'>Thing</span> { <span class='ident'>x</span>: <span class='number'>1</span>, <span class='ident'>y</span>: <span class='number'>2</span> };
<span class='kw'>match</span> <span class='ident'>thing</span> {
    <span class='ident'>Thing</span> { <span class='ident'>x</span>: <span class='ident'>xfield</span>, <span class='ident'>y</span>: <span class='ident'>yfield</span> } <span class='op'>=&gt;</span> ...
}</pre>

<p>If you are using shorthand field patterns but want to refer to the struct field
by a different name, you should rename it explicitly.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Change this:</span>
<span class='kw'>match</span> <span class='ident'>thing</span> {
    <span class='ident'>Thing</span> { <span class='ident'>x</span>, <span class='ident'>z</span> } <span class='op'>=&gt;</span> ...
}

<span class='comment'>// To this:</span>
<span class='kw'>match</span> <span class='ident'>thing</span> {
    <span class='ident'>Thing</span> { <span class='ident'>x</span>, <span class='ident'>y</span>: <span class='ident'>z</span> } <span class='op'>=&gt;</span> ...
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0027" class="section-header"><a href="#E0027">E0027</a></h2>
<p>This error indicates that a pattern for a struct fails to specify a sub-pattern
for every one of the struct&#39;s fields. Ensure that each field from the struct&#39;s
definition is mentioned in the pattern, or use <code>..</code> to ignore unwanted fields.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Dog</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>age</span>: <span class='ident'>u32</span>
}

<span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='ident'>Dog</span> { <span class='ident'>name</span>: <span class='string'>&quot;Rusty&quot;</span>.<span class='ident'>to_string</span>(), <span class='ident'>age</span>: <span class='number'>8</span> };

<span class='comment'>// This is incorrect.</span>
<span class='kw'>match</span> <span class='ident'>d</span> {
    <span class='ident'>Dog</span> { <span class='ident'>age</span>: <span class='ident'>x</span> } <span class='op'>=&gt;</span> ...
}

<span class='comment'>// This is correct (explicit).</span>
<span class='kw'>match</span> <span class='ident'>d</span> {
    <span class='ident'>Dog</span> { <span class='ident'>name</span>: <span class='ident'>n</span>, <span class='ident'>age</span>: <span class='ident'>x</span> } <span class='op'>=&gt;</span> ...
}

<span class='comment'>// This is also correct (ignore unused fields).</span>
<span class='kw'>match</span> <span class='ident'>d</span> {
    <span class='ident'>Dog</span> { <span class='ident'>age</span>: <span class='ident'>x</span>, .. } <span class='op'>=&gt;</span> ...
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0029" class="section-header"><a href="#E0029">E0029</a></h2>
<p>In a match expression, only numbers and characters can be matched against a
range. This is because the compiler checks that the range is non-empty at
compile-time, and is unable to evaluate arbitrary comparison functions. If you
want to capture values of an orderable type between two end-points, you can use
a guard.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// The ordering relation for strings can&#39;t be evaluated at compile time,</span>
<span class='comment'>// so this doesn&#39;t work:</span>
<span class='kw'>match</span> <span class='ident'>string</span> {
    <span class='string'>&quot;hello&quot;</span> ... <span class='string'>&quot;world&quot;</span> <span class='op'>=&gt;</span> ...
    _ <span class='op'>=&gt;</span> ...
}

<span class='comment'>// This is a more general version, using a guard:</span>
<span class='kw'>match</span> <span class='ident'>string</span> {
    <span class='ident'>s</span> <span class='kw'>if</span> <span class='ident'>s</span> <span class='op'>&gt;=</span> <span class='string'>&quot;hello&quot;</span> <span class='op'>&amp;&amp;</span> <span class='ident'>s</span> <span class='op'>&lt;=</span> <span class='string'>&quot;world&quot;</span> <span class='op'>=&gt;</span> ...
    _ <span class='op'>=&gt;</span> ...
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0030" class="section-header"><a href="#E0030">E0030</a></h2>
<p>When matching against a range, the compiler verifies that the range is
non-empty.  Range patterns include both end-points, so this is equivalent to
requiring the start of the range to be less than or equal to the end of the
range.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='number'>5u32</span> {
    <span class='comment'>// This range is ok, albeit pointless.</span>
    <span class='number'>1</span> ... <span class='number'>1</span> <span class='op'>=&gt;</span> ...
    <span class='comment'>// This range is empty, and the compiler can tell.</span>
    <span class='number'>1000</span> ... <span class='number'>5</span> <span class='op'>=&gt;</span> ...
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0033" class="section-header"><a href="#E0033">E0033</a></h2>
<p>This error indicates that a pointer to a trait type cannot be implicitly
dereferenced by a pattern. Every trait defines a type, but because the
size of trait implementors isn&#39;t fixed, this type has no compile-time size.
Therefore, all accesses to trait types must be through pointers. If you
encounter this error you should try to avoid dereferencing the pointer.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>trait_obj</span>: <span class='kw-2'>&amp;</span><span class='ident'>SomeTrait</span> <span class='op'>=</span> ...;

<span class='comment'>// This tries to implicitly dereference to create an unsized local variable.</span>
<span class='kw'>let</span> <span class='kw-2'>&amp;</span><span class='ident'>invalid</span> <span class='op'>=</span> <span class='ident'>trait_obj</span>;

<span class='comment'>// You can call methods without binding to the value being pointed at.</span>
<span class='ident'>trait_obj</span>.<span class='ident'>method_one</span>();
<span class='ident'>trait_obj</span>.<span class='ident'>method_two</span>();</pre>

<p>You can read more about trait objects in the Trait Object section of the
Reference:</p>

<p><a href="https://doc.rust-lang.org/reference.html#trait-objects">https://doc.rust-lang.org/reference.html#trait-objects</a></p>
</div>
<div class="error-described error-used"><h2 id="E0034" class="section-header"><a href="#E0034">E0034</a></h2>
<p>The compiler doesn&#39;t know what method to call because more than one method
has the same prototype. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>trait</span> <span class='ident'>Trait1</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>trait</span> <span class='ident'>Trait2</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>impl</span> <span class='ident'>Trait1</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }
<span class='kw'>impl</span> <span class='ident'>Trait2</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>Test</span>::<span class='ident'>foo</span>() <span class='comment'>// error, which foo() to call?</span>
}</pre>

<p>To avoid this error, you have to keep only one of them and remove the others.
So let&#39;s take our example and fix it:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>trait</span> <span class='ident'>Trait1</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>impl</span> <span class='ident'>Trait1</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>Test</span>::<span class='ident'>foo</span>() <span class='comment'>// and now that&#39;s good!</span>
}</pre>

<p>However, a better solution would be using fully explicit naming of type and
trait:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>trait</span> <span class='ident'>Trait1</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>trait</span> <span class='ident'>Trait2</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>impl</span> <span class='ident'>Trait1</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }
<span class='kw'>impl</span> <span class='ident'>Trait2</span> <span class='kw'>for</span> <span class='ident'>Test</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>() {} }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='op'>&lt;</span><span class='ident'>Test</span> <span class='kw'>as</span> <span class='ident'>Trait1</span><span class='op'>&gt;</span>::<span class='ident'>foo</span>()
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0035" class="section-header"><a href="#E0035">E0035</a></h2>
<p>You tried to give a type parameter where it wasn&#39;t needed. Bad example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;

    <span class='ident'>x</span>.<span class='ident'>method</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>(); <span class='comment'>// Error: Test::method doesn&#39;t need type parameter!</span>
}</pre>

<p>To fix this error, just remove the type parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;

    <span class='ident'>x</span>.<span class='ident'>method</span>(); <span class='comment'>// OK, we&#39;re good!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0036" class="section-header"><a href="#E0036">E0036</a></h2>
<p>This error occurrs when you pass too many or not enough type parameters to
a method. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='ident'>v</span>.<span class='ident'>len</span>()
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0i32</span>];

    <span class='ident'>x</span>.<span class='ident'>method</span>::<span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>v</span>); <span class='comment'>// error: only one type parameter is expected!</span>
}</pre>

<p>To fix it, just specify a correct number of type parameters:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Test</span>;

<span class='kw'>impl</span> <span class='ident'>Test</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='ident'>v</span>.<span class='ident'>len</span>()
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Test</span>;
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0i32</span>];

    <span class='ident'>x</span>.<span class='ident'>method</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>(<span class='ident'>v</span>); <span class='comment'>// OK, we&#39;re good!</span>
}</pre>

<p>Please note on the last example that we could have called <code>method</code> like this:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>x</span>.<span class='ident'>method</span>(<span class='ident'>v</span>);</pre>
</div>
<div class="error-described error-used"><h2 id="E0038" class="section-header"><a href="#E0038">E0038</a></h2>
<p>Trait objects like <code>Box&lt;Trait&gt;</code> can only be constructed when certain
requirements are satisfied by the trait in question.</p>

<p>Trait objects are a form of dynamic dispatch and use a dynamically sized type
for the inner type. So, for a given trait <code>Trait</code>, when <code>Trait</code> is treated as a
type, as in <code>Box&lt;Trait&gt;</code>, the inner type is &#39;unsized&#39;. In such cases the boxed
pointer is a &#39;fat pointer&#39; that contains an extra pointer to a table of methods
(among other things) for dynamic dispatch. This design mandates some
restrictions on the types of traits that are allowed to be used in trait
objects, which are collectively termed as &#39;object safety&#39; rules.</p>

<p>Attempting to create a trait object for a non object-safe trait will trigger
this error.</p>

<p>There are various rules:</p>

<h3 id='the-trait-cannot-require-self-sized' class='section-header'><a href='#the-trait-cannot-require-self-sized'>The trait cannot require <code>Self: Sized</code></a></h3>
<p>When <code>Trait</code> is treated as a type, the type does not implement the special
<code>Sized</code> trait, because the type does not have a known size at compile time and
can only be accessed behind a pointer. Thus, if we have a trait like the
following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> <span class='kw'>where</span> <span class='kw'>Self</span>: <span class='ident'>Sized</span> {

}</pre>

<p>we cannot create an object of type <code>Box&lt;Foo&gt;</code> or <code>&amp;Foo</code> since in this case
<code>Self</code> would not be <code>Sized</code>.</p>

<p>Generally, <code>Self : Sized</code> is used to indicate that the trait should not be used
as a trait object. If the trait comes from your own crate, consider removing
this restriction.</p>

<h3 id='method-references-the-self-type-in-its-arguments-or-return-type' class='section-header'><a href='#method-references-the-self-type-in-its-arguments-or-return-type'>Method references the <code>Self</code> type in its arguments or return type</a></h3>
<p>This happens when a trait has a method like the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
}

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span> {
        <span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_owned</span>()
    }
}

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span> {
        <span class='number'>1</span>
    }
}</pre>

<p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it&#39;s additional <code>Self</code> types which
cause this problem)</p>

<p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a
situation like the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>call_foo</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Trait</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>foo</span>(); <span class='comment'>// What type is y?</span>
    <span class='comment'>// ...</span>
}</pre>

<p>If only some methods aren&#39;t object-safe, you can add a <code>where Self: Sized</code> bound
on them to mark them as explicitly unavailable to trait objects. The
functionality will still be available to all other implementers, including
<code>Box&lt;Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;Trait&gt;</code>).</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span> <span class='kw'>where</span> <span class='kw'>Self</span>: <span class='ident'>Sized</span>;
    <span class='comment'>// more functions</span>
}</pre>

<p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be
allowed to make a trait object, and that will be able to call any object-safe
methods&quot;. With such a bound, one can still call <code>foo()</code> on types implementing
that trait that aren&#39;t behind trait objects.</p>

<h3 id='method-has-generic-type-parameters' class='section-header'><a href='#method-has-generic-type-parameters'>Method has generic type parameters</a></h3>
<p>As mentioned before, trait objects contain pointers to method tables. So, if we
have:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='comment'>// implementation 1</span>
    }
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='comment'>// implementation 2</span>
    }
}
<span class='comment'>// ...</span></pre>

<p>At compile time each implementation of <code>Trait</code> will produce a table containing
the various methods (and other items) related to the implementation.</p>

<p>This works fine, but when the method gains generic parameters, we can have a
problem.</p>

<p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='comment'>// ...</span>
}</pre>

<p>the machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any
other type substitution is different. Hence the compiler generates the
implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the
compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional
type parameters, the number of monomorphized implementations the compiler
generates does not grow drastically, since the compiler will only generate an
implementation if the function is called with unparametrized substitutions
(i.e., substitutions where none of the substituted types are themselves
parametrized).</p>

<p>However, with trait objects we have to make a table containing <em>every</em> object
that implements the trait. Now, if it has type parameters, we need to add
implementations for every type that implements the trait, and there could
theoretically be an infinite number of types.</p>

<p>For example, with:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>on</span>: <span class='ident'>T</span>);
    <span class='comment'>// more methods</span>
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>on</span>: <span class='ident'>T</span>) {
        <span class='comment'>// implementation 1</span>
    }
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>on</span>: <span class='ident'>T</span>) {
        <span class='comment'>// implementation 2</span>
    }
}
<span class='comment'>// 8 more implementations</span></pre>

<p>Now, if we have the following code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>call_foo</span>(<span class='ident'>thing</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Trait</span><span class='op'>&gt;</span>) {
    <span class='ident'>thing</span>.<span class='ident'>foo</span>(<span class='boolval'>true</span>); <span class='comment'>// this could be any one of the 8 types above</span>
    <span class='ident'>thing</span>.<span class='ident'>foo</span>(<span class='number'>1</span>);
    <span class='ident'>thing</span>.<span class='ident'>foo</span>(<span class='string'>&quot;hello&quot;</span>);
}</pre>

<p>we don&#39;t just need to create a table of all implementations of all methods of
<code>Trait</code>, we need to create such a table, for each different type fed to
<code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3
types being fed to <code>foo()</code>) = 30 implementations!</p>

<p>With real world traits these numbers can grow drastically.</p>

<p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the
fix for the sub-error above if you do not intend to call the method with type
parameters:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>on</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='kw'>Self</span>: <span class='ident'>Sized</span>;
    <span class='comment'>// more methods</span>
}</pre>

<p>If this is not an option, consider replacing the type parameter with another
trait object (e.g. if <code>T: OtherTrait</code>, use <code>on: Box&lt;OtherTrait&gt;</code>). If the number
of types you intend to feed to this method is limited, consider manually listing
out the methods of different types.</p>

<h3 id='method-has-no-receiver' class='section-header'><a href='#method-has-no-receiver'>Method has no receiver</a></h3>
<p>Methods that do not take a <code>self</code> parameter can&#39;t be called since there won&#39;t be
a way to get a pointer to the method table for them</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>u8</span>;
}</pre>

<p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick
an implementation.</p>

<p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>u8</span> <span class='kw'>where</span> <span class='kw'>Self</span>: <span class='ident'>Sized</span>;
}</pre>

<h3 id='the-trait-cannot-use-self-as-a-type-parameter-in-the-supertrait-listing' class='section-header'><a href='#the-trait-cannot-use-self-as-a-type-parameter-in-the-supertrait-listing'>The trait cannot use <code>Self</code> as a type parameter in the supertrait listing</a></h3>
<p>This is similar to the second sub-error, but subtler. It happens in situations
like the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Super</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> {}

<span class='kw'>trait</span> <span class='ident'>Trait</span>: <span class='ident'>Super</span><span class='op'>&lt;</span><span class='kw'>Self</span><span class='op'>&gt;</span> {
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Super</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Foo</span>{}

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {}</pre>

<p>Here, the supertrait might have methods as follows:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Super</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>get_a</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>A</span>; <span class='comment'>// note that this is object safe!</span>
}</pre>

<p>If the trait <code>Foo</code> was deriving from something like <code>Super&lt;String&gt;</code> or
<code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type
<code>get_a()</code> will definitely return an object of that type.</p>

<p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is object safe,
the method <code>get_a()</code> would return an object of unknown type when called on the
function. <code>Self</code> type parameters let us make object safe traits no longer safe,
so they are forbidden when specifying supertraits.</p>

<p>There&#39;s no easy fix for this, generally code will need to be refactored so that
you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>
</div>
<div class="error-described error-used"><h2 id="E0040" class="section-header"><a href="#E0040">E0040</a></h2>
<p>It is not allowed to manually call destructors in Rust. It is also not
necessary to do this since <code>drop</code> is called automatically whenever a value goes
out of scope.</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;kaboom&quot;</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='op'>-</span><span class='number'>7</span> };
    <span class='ident'>x</span>.<span class='ident'>drop</span>(); <span class='comment'>// error: explicit use of destructor method</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0044" class="section-header"><a href="#E0044">E0044</a></h2>
<p>You can&#39;t use type parameters on foreign items. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> { <span class='kw'>fn</span> <span class='ident'>some_func</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>); }</pre>

<p>To fix this, replace the type parameter with the specializations that you
need:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> { <span class='kw'>fn</span> <span class='ident'>some_func_i32</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>); }
<span class='kw'>extern</span> { <span class='kw'>fn</span> <span class='ident'>some_func_i64</span>(<span class='ident'>x</span>: <span class='ident'>i64</span>); }</pre>
</div>
<div class="error-described error-used"><h2 id="E0045" class="section-header"><a href="#E0045">E0045</a></h2>
<p>Rust only supports variadic parameters for interoperability with C code in its
FFI. As such, variadic parameters can only be used with functions which are
using the C ABI. Examples of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;rust-call&quot;</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>, ...); }
<span class='comment'>// or</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>, ...) {}</pre>

<p>To fix such code, put them in an extern &quot;C&quot; block:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span> <span class='ident'>foo</span> (<span class='ident'>x</span>: <span class='ident'>u8</span>, ...);
<span class='comment'>// or:</span>
<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span> (<span class='ident'>x</span>: <span class='ident'>u8</span>, ...);
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0046" class="section-header"><a href="#E0046">E0046</a></h2>
<p>Items are missing in a trait implementation. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {}
<span class='comment'>// error: not all trait items implemented, missing: `foo`</span></pre>

<p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum,
provide implementations for all of <code>Foo</code>&#39;s required methods (meaning the
methods that do not have default implementations), as well as any required
trait items like associated types or constants. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>() {} <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0049" class="section-header"><a href="#E0049">E0049</a></h2>
<p>This error indicates that an attempted implementation of a trait method
has the wrong number of type parameters.</p>

<p>For example, the trait below has a method <code>foo</code> with a type parameter <code>T</code>,
but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Default</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='comment'>// error: method `foo` has 0 type parameters but its trait declaration has 1</span>
<span class='comment'>// type parameter</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>bool</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span> { <span class='ident'>Bar</span> }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0050" class="section-header"><a href="#E0050">E0050</a></h2>
<p>This error indicates that an attempted implementation of a trait method
has the wrong number of function parameters.</p>

<p>For example, the trait below has a method <code>foo</code> with two function parameters
(<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits
the <code>u8</code> parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>x</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='comment'>// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`</span>
<span class='comment'>// has 2</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='boolval'>true</span> }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0053" class="section-header"><a href="#E0053">E0053</a></h2>
<p>The parameters of any trait method must match between a trait implementation
and the trait definition.</p>

<p>Here are a couple examples of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u16</span>);
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='comment'>// error, expected u16, found i16</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i16</span>) { }

    <span class='comment'>// error, values differ in mutability</span>
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) { }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0054" class="section-header"><a href="#E0054">E0054</a></h2>
<p>It is not allowed to cast to a bool. If you are trying to cast a numeric type
to a bool, you can compare it with zero instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='comment'>// Ok</span>
<span class='kw'>let</span> <span class='ident'>x_is_nonzero</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='op'>!=</span> <span class='number'>0</span>;

<span class='comment'>// Not allowed, won&#39;t compile</span>
<span class='kw'>let</span> <span class='ident'>x_is_nonzero</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='kw'>as</span> <span class='ident'>bool</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0055" class="section-header"><a href="#E0055">E0055</a></h2>
<p>During a method call, a value is automatically dereferenced as many times as
needed to make the value&#39;s type match the method&#39;s receiver. The catch is that
the compiler will only attempt to dereference a number of times up to the
recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p>

<p>For a somewhat artificial example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>recursion_limit</span><span class='op'>=</span><span class='string'>&quot;2&quot;</span>]</span>

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='ident'>Foo</span>;
    <span class='kw'>let</span> <span class='ident'>ref_foo</span> <span class='op'>=</span> <span class='op'>&amp;&amp;</span><span class='ident'>Foo</span>;

    <span class='comment'>// error, reached the recursion limit while auto-dereferencing &amp;&amp;Foo</span>
    <span class='ident'>ref_foo</span>.<span class='ident'>foo</span>();
}</pre>

<p>One fix may be to increase the recursion limit. Note that it is possible to
create an infinite recursion of dereferencing, in which case the only fix is to
somehow break the recursion.</p>
</div>
<div class="error-described error-used"><h2 id="E0057" class="section-header"><a href="#E0057">E0057</a></h2>
<p>When invoking closures or other implementations of the function traits <code>Fn</code>,
<code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the
function must match its definition.</p>

<p>An example using a closure:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>3</span>;
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>f</span>();        <span class='comment'>// invalid, too few parameters</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>4</span>);       <span class='comment'>// this works!</span>
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>2</span>, <span class='number'>3</span>);    <span class='comment'>// invalid, too many parameters</span></pre>

<p>A generic function must be treated similarly:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>()<span class='op'>&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) {
    <span class='ident'>f</span>(); <span class='comment'>// this is valid, but f(3) would not work</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0059" class="section-header"><a href="#E0059">E0059</a></h2>
<p>The built-in function traits are generic over a tuple of the function arguments.
If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses
(<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a
tuple. Otherwise function call notation cannot be used and the trait will not be
implemented by closures.</p>

<p>The most likely source of this error is using angle-bracket notation without
wrapping the function argument type into a tuple, for example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>F</span>::<span class='ident'>Output</span> { <span class='ident'>f</span>(<span class='number'>3</span>) }</pre>

<p>It can be fixed by adjusting the trait bound like this:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span><span class='op'>&lt;</span>(<span class='ident'>i32</span>,)<span class='op'>&gt;&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>F</span>::<span class='ident'>Output</span> { <span class='ident'>f</span>(<span class='number'>3</span>) }</pre>

<p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of
type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>
</div>
<div class="error-described error-used"><h2 id="E0060" class="section-header"><a href="#E0060">E0060</a></h2>
<p>External C functions are allowed to be variadic. However, a variadic function
takes a minimum number of arguments. For example, consider C&#39;s variadic <code>printf</code>
function:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;
<span class='kw'>use</span> <span class='ident'>libc</span>::{ <span class='ident'>c_char</span>, <span class='ident'>c_int</span> };

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>printf</span>(_: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>c_char</span>, ...) <span class='op'>-&gt;</span> <span class='ident'>c_int</span>;
}</pre>

<p>Using this declaration, it must be called with at least one argument, so
simply calling <code>printf()</code> is invalid. But the following uses are allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ffi</span>::<span class='ident'>CString</span>;

    <span class='ident'>printf</span>(<span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;test\n&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>as_ptr</span>());
    <span class='ident'>printf</span>(<span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;number = %d\n&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>as_ptr</span>(), <span class='number'>3</span>);
    <span class='ident'>printf</span>(<span class='ident'>CString</span>::<span class='ident'>new</span>(<span class='string'>&quot;%d, %d\n&quot;</span>).<span class='ident'>unwrap</span>().<span class='ident'>as_ptr</span>(), <span class='number'>10</span>, <span class='number'>5</span>);
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0061" class="section-header"><a href="#E0061">E0061</a></h2>
<p>The number of arguments passed to a function must match the number of arguments
specified in the function signature.</p>

<p>For example, a function like</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>(<span class='ident'>a</span>: <span class='ident'>u16</span>, <span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {}</pre>

<p>must always be called with exactly two arguments, e.g. <code>f(2, &quot;test&quot;)</code>.</p>

<p>Note, that Rust does not have a notion of optional function arguments or
variadic functions (except for its C-FFI).</p>
</div>
<div class="error-described error-used"><h2 id="E0062" class="section-header"><a href="#E0062">E0062</a></h2>
<p>This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was specified more than once. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> {
                <span class='ident'>x</span>: <span class='number'>0</span>,
                <span class='ident'>x</span>: <span class='number'>0</span>, <span class='comment'>// error: field `x` specified more than once</span>
            };
}</pre>

<p>Each field should be specified exactly one time. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='number'>0</span> }; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0063" class="section-header"><a href="#E0063">E0063</a></h2>
<p>This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was not provided. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='number'>0</span> }; <span class='comment'>// error: missing field: `y`</span>
}</pre>

<p>Each field should be specified exactly once. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> }; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-unused"><h2 id="E0066" class="section-header"><a href="#E0066">E0066</a></h2>
<p>Box placement expressions (like C++&#39;s &quot;placement new&quot;) do not yet support any
place expression except the exchange heap (i.e. <code>std::boxed::HEAP</code>).
Furthermore, the syntax is changing to use <code>in</code> instead of <code>box</code>. See <a href="https://github.com/rust-lang/rfcs/pull/470">RFC 470</a>
and <a href="https://github.com/rust-lang/rfcs/pull/809">RFC 809</a> for more details.</p>
</div>
<div class="error-described error-used"><h2 id="E0067" class="section-header"><a href="#E0067">E0067</a></h2>
<p>The left-hand side of a compound assignment expression must be an lvalue
expression. An lvalue expression represents a memory location and includes
item paths (ie, namespaced variables), dereferences, indexing expressions,
and field references.</p>

<p>Let&#39;s start with some bad examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>LinkedList</span>;

<span class='comment'>// Bad: assignment to non-lvalue expression</span>
<span class='ident'>LinkedList</span>::<span class='ident'>new</span>() <span class='op'>+=</span> <span class='number'>1</span>;

<span class='comment'>// ...</span>

<span class='kw'>fn</span> <span class='ident'>some_func</span>(<span class='ident'>i</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>) {
    <span class='ident'>i</span> <span class='op'>+=</span> <span class='number'>12</span>; <span class='comment'>// Error : &#39;+=&#39; operation cannot be applied on a reference !</span>
}</pre>

<p>And now some good examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>;

<span class='ident'>i</span> <span class='op'>+=</span> <span class='number'>12</span>; <span class='comment'>// Good !</span>

<span class='comment'>// ...</span>

<span class='kw'>fn</span> <span class='ident'>some_func</span>(<span class='ident'>i</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>) {
    <span class='op'>*</span><span class='ident'>i</span> <span class='op'>+=</span> <span class='number'>12</span>; <span class='comment'>// Good !</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0069" class="section-header"><a href="#E0069">E0069</a></h2>
<p>The compiler found a function whose body contains a <code>return;</code> statement but
whose return type is not <code>()</code>. An example of this is:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>u8</span> {
    <span class='kw'>return</span>;
}</pre>

<p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the
function&#39;s return type and the value being returned.</p>
</div>
<div class="error-described error-used"><h2 id="E0070" class="section-header"><a href="#E0070">E0070</a></h2>
<p>The left-hand side of an assignment operator must be an lvalue expression. An
lvalue expression represents a memory location and can be a variable (with
optional namespacing), a dereference, an indexing expression or a field
reference.</p>

<p>More details can be found here:
<a href="https://doc.rust-lang.org/reference.html#lvalues,-rvalues-and-temporaries">https://doc.rust-lang.org/reference.html#lvalues,-rvalues-and-temporaries</a></p>

<p>Now, we can go further. Here are some bad examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>SomeStruct</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>
}
<span class='kw'>const</span> <span class='ident'>SOME_CONST</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>12</span>;

<span class='kw'>fn</span> <span class='ident'>some_other_func</span>() {}

<span class='kw'>fn</span> <span class='ident'>some_function</span>() {
    <span class='ident'>SOME_CONST</span> <span class='op'>=</span> <span class='number'>14</span>; <span class='comment'>// error : a constant value cannot be changed!</span>
    <span class='number'>1</span> <span class='op'>=</span> <span class='number'>3</span>; <span class='comment'>// error : 1 isn&#39;t a valid lvalue!</span>
    <span class='ident'>some_other_func</span>() <span class='op'>=</span> <span class='number'>4</span>; <span class='comment'>// error : we can&#39;t assign value to a function!</span>
    <span class='ident'>SomeStruct</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12</span>; <span class='comment'>// error : SomeStruct a structure name but it is used</span>
                       <span class='comment'>// like a variable!</span>
}</pre>

<p>And now let&#39;s give good examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>SomeStruct</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>
}
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>SomeStruct</span> {<span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span>};

<span class='ident'>s</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>; <span class='comment'>// that&#39;s good !</span>

<span class='comment'>// ...</span>

<span class='kw'>fn</span> <span class='ident'>some_func</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i32</span>) {
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12</span>; <span class='comment'>// that&#39;s good !</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0071" class="section-header"><a href="#E0071">E0071</a></h2>
<p>You tried to use structure-literal syntax to create an item that is
not a struct-style structure or enum variant.</p>

<p>Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> { <span class='ident'>FirstValue</span>(<span class='ident'>i32</span>) };

<span class='kw'>let</span> <span class='ident'>u</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>FirstValue</span> { <span class='ident'>value</span>: <span class='number'>0i32</span> }; <span class='comment'>// error: Foo::FirstValue</span>
                                         <span class='comment'>// isn&#39;t a structure!</span>
<span class='comment'>// or even simpler, if the name doesn&#39;t refer to a structure at all.</span>
<span class='kw'>let</span> <span class='ident'>t</span> <span class='op'>=</span> <span class='ident'>u32</span> { <span class='ident'>value</span>: <span class='number'>4</span> }; <span class='comment'>// error: `u32` does not name a structure.</span></pre>

<p>To fix this, ensure that the name was correctly spelled, and that
the correct form of initializer was used.</p>

<p>For example, the code above can be fixed to:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>FirstValue</span>(<span class='ident'>i32</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>u</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>FirstValue</span>(<span class='number'>0i32</span>);

    <span class='kw'>let</span> <span class='ident'>t</span> <span class='op'>=</span> <span class='number'>4</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0072" class="section-header"><a href="#E0072">E0072</a></h2>
<p>When defining a recursive struct or enum, any use of the type being defined
from inside the definition must occur behind a pointer (like <code>Box</code> or <code>&amp;</code>).
This is because structs and enums must have a well-defined size, and without
the pointer the size of the type would need to be unbounded.</p>

<p>Consider the following erroneous definition of a type for a list of bytes:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, invalid recursive struct type</span>
<span class='kw'>struct</span> <span class='ident'>ListNode</span> {
    <span class='ident'>head</span>: <span class='ident'>u8</span>,
    <span class='ident'>tail</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>ListNode</span><span class='op'>&gt;</span>,
}</pre>

<p>This type cannot have a well-defined size, because it needs to be arbitrarily
large (since we would be able to nest <code>ListNode</code>s to any depth). Specifically,</p>

<pre><code class="language-plain">size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</code></pre>

<p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>ListNode</span> {
    <span class='ident'>head</span>: <span class='ident'>u8</span>,
    <span class='ident'>tail</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>ListNode</span><span class='op'>&gt;&gt;</span>,
}</pre>

<p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>
</div>
<div class="error-described error-unused"><h2 id="E0073" class="section-header"><a href="#E0073">E0073</a></h2>
<p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code>
in order to make a new <code>Foo</code> value. This is because there would be no way a
first instance of <code>Foo</code> could be made to initialize another instance!</p>

<p>Here&#39;s an example of a struct that has this problem:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span> } <span class='comment'>// error</span></pre>

<p>One fix is to use <code>Option</code>, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;&gt;</span> }</pre>

<p>Now it&#39;s possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>
</div>
<div class="error-described error-unused"><h2 id="E0074" class="section-header"><a href="#E0074">E0074</a></h2>
<p>When using the <code>#[simd]</code> attribute on a tuple struct, the components of the
tuple struct must all be of a concrete, nongeneric type so the compiler can
reason about how to use SIMD with them. This error will occur if the types
are generic.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Bad</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>T</span>, <span class='ident'>T</span>, <span class='ident'>T</span>); <span class='comment'>// This will cause an error</span>

<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Good</span>(<span class='ident'>u32</span>, <span class='ident'>u32</span>, <span class='ident'>u32</span>); <span class='comment'>// This will not</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0075" class="section-header"><a href="#E0075">E0075</a></h2>
<p>The <code>#[simd]</code> attribute can only be applied to non empty tuple structs, because
it doesn&#39;t make sense to try to use SIMD operations when there are no values to
operate on.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Bad</span>; <span class='comment'>// This will cause an error</span>

<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Good</span>(<span class='ident'>u32</span>); <span class='comment'>// This will not</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0076" class="section-header"><a href="#E0076">E0076</a></h2>
<p>When using the <code>#[simd]</code> attribute to automatically use SIMD operations in tuple
struct, the types in the struct must all be of the same type, or the compiler
will trigger this error.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Bad</span>(<span class='ident'>u16</span>, <span class='ident'>u32</span>, <span class='ident'>u32</span>); <span class='comment'>// This will cause an error</span>

<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Good</span>(<span class='ident'>u32</span>, <span class='ident'>u32</span>, <span class='ident'>u32</span>); <span class='comment'>// This will not</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0077" class="section-header"><a href="#E0077">E0077</a></h2>
<p>When using the <code>#[simd]</code> attribute on a tuple struct, the elements in the tuple
must be machine types so SIMD operations can be applied to them.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Bad</span>(<span class='ident'>String</span>); <span class='comment'>// This will cause an error</span>

<span class='attribute'>#[<span class='ident'>simd</span>]</span>
<span class='kw'>struct</span> <span class='ident'>Good</span>(<span class='ident'>u32</span>, <span class='ident'>u32</span>, <span class='ident'>u32</span>); <span class='comment'>// This will not</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0079" class="section-header"><a href="#E0079">E0079</a></h2>
<p>Enum variants which contain no data can be given a custom integer
representation. This error indicates that the value provided is not an integer
literal and is therefore invalid.</p>

<p>For example, in the following code,</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Q</span> <span class='op'>=</span> <span class='string'>&quot;32&quot;</span>
}</pre>

<p>we try to set the representation to a string.</p>

<p>There&#39;s no general fix for this; if you can work with an integer then just set
it to one:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Q</span> <span class='op'>=</span> <span class='number'>32</span>
}</pre>

<p>however if you actually wanted a mapping between variants and non-integer
objects, it may be preferable to use a method with a match instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> { <span class='ident'>Q</span> }
<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>get_str</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>Foo</span>::<span class='ident'>Q</span> <span class='op'>=&gt;</span> <span class='string'>&quot;32&quot;</span>,
        }
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0080" class="section-header"><a href="#E0080">E0080</a></h2>
<p>This error indicates that the compiler was unable to sensibly evaluate an
integer expression provided as an enum discriminant. Attempting to divide by 0
or causing integer overflow are two ways to induce this error. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Enum</span> {
    <span class='ident'>X</span> <span class='op'>=</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> <span class='number'>500</span>),
    <span class='ident'>Y</span> <span class='op'>=</span> (<span class='number'>1</span> <span class='op'>/</span> <span class='number'>0</span>)
}</pre>

<p>Ensure that the expressions given can be evaluated as the desired integer type.
See the FFI section of the Reference for more information about using a custom
integer type:</p>

<p><a href="https://doc.rust-lang.org/reference.html#ffi-attributes">https://doc.rust-lang.org/reference.html#ffi-attributes</a></p>
</div>
<div class="error-described error-used"><h2 id="E0081" class="section-header"><a href="#E0081">E0081</a></h2>
<p>Enum discriminants are used to differentiate enum variants stored in memory.
This error indicates that the same value was used for two or more variants,
making them impossible to tell apart.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Good.</span>
<span class='kw'>enum</span> <span class='ident'>Enum</span> {
    <span class='ident'>P</span>,
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>3</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>5</span>
}

<span class='comment'>// Bad.</span>
<span class='kw'>enum</span> <span class='ident'>Enum</span> {
    <span class='ident'>P</span> <span class='op'>=</span> <span class='number'>3</span>,
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>3</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>5</span>
}</pre>

<p>Note that variants without a manually specified discriminant are numbered from
top to bottom starting from 0, so clashes can occur with seemingly unrelated
variants.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Bad</span> {
    <span class='ident'>X</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>0</span>
}</pre>

<p>Here <code>X</code> will have already been assigned the discriminant 0 by the time <code>Y</code> is
encountered, so a conflict occurs.</p>
</div>
<div class="error-described error-used"><h2 id="E0082" class="section-header"><a href="#E0082">E0082</a></h2>
<p>The default type for enum discriminants is <code>isize</code>, but it can be adjusted by
adding the <code>repr</code> attribute to the enum declaration. This error indicates that
an integer literal given as a discriminant is not a member of the discriminant
type. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>u8</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>Thing</span> {
    <span class='ident'>A</span> <span class='op'>=</span> <span class='number'>1024</span>,
    <span class='ident'>B</span> <span class='op'>=</span> <span class='number'>5</span>
}</pre>

<p>Here, 1024 lies outside the valid range for <code>u8</code>, so the discriminant for <code>A</code> is
invalid. You may want to change representation types to fix this, or else change
invalid discriminant values so that they fit within the existing type.</p>

<p>Note also that without a representation manually defined, the compiler will
optimize by using the smallest integer type possible.</p>
</div>
<div class="error-described error-used"><h2 id="E0083" class="section-header"><a href="#E0083">E0083</a></h2>
<p>At present, it&#39;s not possible to define a custom representation for an enum with
a single variant. As a workaround you can add a <code>Dummy</code> variant.</p>

<p>See: <a href="https://github.com/rust-lang/rust/issues/10292">https://github.com/rust-lang/rust/issues/10292</a></p>
</div>
<div class="error-described error-used"><h2 id="E0084" class="section-header"><a href="#E0084">E0084</a></h2>
<p>It is impossible to define an integer type to be used to represent zero-variant
enum values because there are no zero-variant enum values. There is no way to
construct an instance of the following type using only safe code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Empty</span> {}</pre>
</div>
<div class="error-described error-used"><h2 id="E0087" class="section-header"><a href="#E0087">E0087</a></h2>
<p>Too many type parameters were supplied for a function. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>::<span class='op'>&lt;</span><span class='ident'>f64</span>, <span class='ident'>bool</span><span class='op'>&gt;</span>(); <span class='comment'>// error, expected 1 parameter, found 2 parameters</span>
}</pre>

<p>The number of supplied parameters must exactly match the number of defined type
parameters.</p>
</div>
<div class="error-described error-used"><h2 id="E0088" class="section-header"><a href="#E0088">E0088</a></h2>
<p>You gave too many lifetime parameters. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>f</span>::<span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>() <span class='comment'>// error: too many lifetime parameters provided</span>
}</pre>

<p>Please check you give the right number of lifetime parameters. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>f</span>() <span class='comment'>// ok!</span>
}</pre>

<p>It&#39;s also important to note that the Rust compiler can generally
determine the lifetime by itself. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>value</span>: <span class='ident'>String</span>
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='comment'>// it can be written like this</span>
    <span class='kw'>fn</span> <span class='ident'>get_value</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>value</span> }
    <span class='comment'>// but the compiler works fine with this too:</span>
    <span class='kw'>fn</span> <span class='ident'>without_lifetime</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { <span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>value</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>value</span>: <span class='string'>&quot;hello&quot;</span>.<span class='ident'>to_owned</span>() };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>f</span>.<span class='ident'>get_value</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>f</span>.<span class='ident'>without_lifetime</span>());
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0089" class="section-header"><a href="#E0089">E0089</a></h2>
<p>Not enough type parameters were supplied for a function. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>() {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>::<span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>(); <span class='comment'>// error, expected 2 parameters, found 1 parameter</span>
}</pre>

<p>Note that if a function takes multiple type parameters but you want the compiler
to infer some of them, you can use type placeholders:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='boolval'>true</span>;
    <span class='ident'>foo</span>::<span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='ident'>x</span>);    <span class='comment'>// error, expected 2 parameters, found 1 parameter</span>
    <span class='ident'>foo</span>::<span class='op'>&lt;</span>_, <span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='ident'>x</span>); <span class='comment'>// same as `foo::&lt;bool, f64&gt;(x)`</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0090" class="section-header"><a href="#E0090">E0090</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0091" class="section-header"><a href="#E0091">E0091</a></h2>
<p>You gave an unnecessary type parameter in a type alias. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// error: type parameter `T` is unused</span>
<span class='comment'>// or:</span>
<span class='kw'>type</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>A</span>,<span class='ident'>B</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span>; <span class='comment'>// error: type parameter `B` is unused</span></pre>

<p>Please check you didn&#39;t write too many type parameters. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span>
<span class='kw'>type</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0092" class="section-header"><a href="#E0092">E0092</a></h2>
<p>You tried to declare an undefined atomic operation function.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>atomic_foo</span>(); <span class='comment'>// error: unrecognized atomic operation</span>
                     <span class='comment'>//        function</span>
}</pre>

<p>Please check you didn&#39;t make a mistake in the function&#39;s name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>atomic_fence</span>(); <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0093" class="section-header"><a href="#E0093">E0093</a></h2>
<p>You declared an unknown intrinsic function. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(); <span class='comment'>// error: unrecognized intrinsic function: `foo`</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>foo</span>();
    }
}</pre>

<p>Please check you didn&#39;t make a mistake in the function&#39;s name. All intrinsic
functions are defined in librustc_trans/trans/intrinsic.rs and in
libcore/intrinsics.rs in the Rust source code. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>atomic_fence</span>(); <span class='comment'>// ok!</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='ident'>atomic_fence</span>();
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0094" class="section-header"><a href="#E0094">E0094</a></h2>
<p>You gave an invalid number of type parameters to an intrinsic function.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span>; <span class='comment'>// error: intrinsic has wrong number</span>
                                 <span class='comment'>//        of type parameters</span>
}</pre>

<p>Please check that you provided the right number of lifetime parameters
and verify with the function declaration in the Rust source code.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0101" class="section-header"><a href="#E0101">E0101</a></h2>
<p>You hit this error because the compiler lacks the information to
determine a type for this expression. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='op'>|</span>_<span class='op'>|</span> {}; <span class='comment'>// error: cannot determine a type for this expression</span>
}</pre>

<p>You have two possibilities to solve this situation:
 * Give an explicit definition of the expression
 * Infer the expression</p>

<p>Examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='op'>|</span>_ : <span class='ident'>u32</span><span class='op'>|</span> {}; <span class='comment'>// ok!</span>
    <span class='comment'>// or:</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='op'>|</span>_<span class='op'>|</span> {};
    <span class='ident'>x</span>(<span class='number'>0u32</span>);
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0102" class="section-header"><a href="#E0102">E0102</a></h2>
<p>You hit this error because the compiler lacks information to
determine a type for this variable. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>demo</span>(<span class='ident'>devil</span>: <span class='kw'>fn</span> () <span class='op'>-&gt;</span> <span class='op'>!</span>) {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>_ <span class='op'>=</span> <span class='ident'>devil</span>();
    <span class='comment'>// error: cannot determine a type for this local variable</span>
}

<span class='kw'>fn</span> <span class='ident'>oh_no</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;the devil is in the details&quot;</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>demo</span>(<span class='ident'>oh_no</span>);
}</pre>

<p>To solve this situation, constrain the type of the variable.
Examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>some_func</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>u32</span>) {
    <span class='comment'>// some code</span>
}

<span class='kw'>fn</span> <span class='ident'>demo</span>(<span class='ident'>devil</span>: <span class='kw'>fn</span> () <span class='op'>-&gt;</span> <span class='op'>!</span>) {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>devil</span>();
    <span class='comment'>// Here we defined the type at the variable creation</span>

    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw-2'>&amp;</span>_ <span class='op'>=</span> <span class='ident'>devil</span>();
    <span class='ident'>some_func</span>(<span class='ident'>x</span>);
    <span class='comment'>// Here, the type is determined by the function argument type</span>
}

<span class='kw'>fn</span> <span class='ident'>oh_no</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;the devil is in the details&quot;</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>demo</span>(<span class='ident'>oh_no</span>);
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0103" class="section-header"><a href="#E0103">E0103</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0104" class="section-header"><a href="#E0104">E0104</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0106" class="section-header"><a href="#E0106">E0106</a></h2>
<p>This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).</p>

<p>Here are some simple examples of where you&#39;ll run into this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>bool</span> }        <span class='comment'>// error</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> { <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>bool</span> } <span class='comment'>// correct</span>

<span class='kw'>enum</span> <span class='ident'>Bar</span> { <span class='ident'>A</span>(<span class='ident'>u8</span>), <span class='ident'>B</span>(<span class='kw-2'>&amp;</span><span class='ident'>bool</span>), }        <span class='comment'>// error</span>
<span class='kw'>enum</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> { <span class='ident'>A</span>(<span class='ident'>u8</span>), <span class='ident'>B</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>bool</span>), } <span class='comment'>// correct</span>

<span class='kw'>type</span> <span class='ident'>MyStr</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>;        <span class='comment'>// error</span>
<span class='kw'>type</span> <span class='ident'>MyStr</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>; <span class='comment'>// correct</span></pre>

<p>Lifetime elision is a special, limited kind of inference for lifetimes in
function signatures which allows you to leave out lifetimes in certain cases.
For more background on lifetime elision see <a href="https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision">the book</a>.</p>

<p>The lifetime elision rules require that any function signature with an elided
output lifetime must either have</p>

<ul>
<li>exactly one input lifetime</li>
<li>or, multiple input lifetimes, but the function must also be a method with a
<code>&amp;self</code> or <code>&amp;mut self</code> receiver</li>
</ul>

<p>In the first case, the output lifetime is inferred to be the same as the unique
input lifetime. In the second case, the lifetime is instead inferred to be the
same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p>

<p>Here are some examples of elision errors:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, no input lifetimes</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { ... }

<span class='comment'>// error, `x` and `y` have distinct lifetimes inferred</span>
<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { ... }

<span class='comment'>// error, `y`&#39;s lifetime is inferred to be distinct from `x`&#39;s</span>
<span class='kw'>fn</span> <span class='ident'>baz</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { ... }</pre>
</div>
<div class="error-described error-used"><h2 id="E0107" class="section-header"><a href="#E0107">E0107</a></h2>
<p>This error means that an incorrect number of lifetime parameters were provided
for a type (like a struct or enum) or trait.</p>

<p>Some basic examples include:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>);
<span class='kw'>enum</span> <span class='ident'>Bar</span> { <span class='ident'>A</span>, <span class='ident'>B</span>, <span class='ident'>C</span> }

<span class='kw'>struct</span> <span class='ident'>Baz</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='ident'>Foo</span>,     <span class='comment'>// error: expected 1, found 0</span>
    <span class='ident'>bar</span>: <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>, <span class='comment'>// error: expected 0, found 1</span>
}</pre>

<p>Here&#39;s an example that is currently an error, but may work in a future version
of Rust:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>);

<span class='kw'>trait</span> <span class='ident'>Quux</span> { }
<span class='kw'>impl</span> <span class='ident'>Quux</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { } <span class='comment'>// error: expected 1, found 0</span></pre>

<p>Lifetime elision in implementation headers was part of the lifetime elision
RFC. It is, however, <a href="https://github.com/rust-lang/rust/issues/15872">currently unimplemented</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0109" class="section-header"><a href="#E0109">E0109</a></h2>
<p>You tried to give a type parameter to a type which doesn&#39;t need it. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>; <span class='comment'>// error: type parameters are not allowed on this type</span></pre>

<p>Please check that you used the correct type and recheck its definition. Perhaps
it doesn&#39;t need the type parameter.</p>

<p>Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// this compiles</span></pre>

<p>Note that type parameters for enum-variant constructors go after the variant,
not after the enum (Option::None::<u32>, not Option::<u32>::None).</p>
</div>
<div class="error-described error-used"><h2 id="E0110" class="section-header"><a href="#E0110">E0110</a></h2>
<p>You tried to give a lifetime parameter to a type which doesn&#39;t need it.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>; <span class='comment'>// error: lifetime parameters are not allowed on</span>
                       <span class='comment'>//        this type</span></pre>

<p>Please check that the correct type was used and recheck its definition; perhaps
it doesn&#39;t need the lifetime parameter. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0116" class="section-header"><a href="#E0116">E0116</a></h2>
<p>You can only define an inherent implementation for a type in the same crate
where the type was defined. For example, an <code>impl</code> block as below is not allowed
since <code>Vec</code> is defined in the standard library:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> { ... } <span class='comment'>// error</span></pre>

<p>To fix this problem, you can do either of these things:</p>

<ul>
<li>define a trait that has the desired associated functions/types/constants and
implement the trait for the type in question</li>
<li>define a new type wrapping the type and define an implementation on the new
type</li>
</ul>

<p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only
introduces a type alias:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Bytes</span> <span class='op'>=</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>;

<span class='kw'>impl</span> <span class='ident'>Bytes</span> { ... } <span class='comment'>// error, same as above</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0117" class="section-header"><a href="#E0117">E0117</a></h2>
<p>This error indicates a violation of one of Rust&#39;s orphan rules for trait
implementations. The rule prohibits any implementation of a foreign trait (a
trait defined in another crate) where</p>

<ul>
<li>the type that is implementing the trait is foreign</li>
<li>all of the parameters being passed to the trait (if there are any) are also
foreign.</li>
</ul>

<p>Here&#39;s one example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>u32</span> {}</pre>

<p>To avoid this kind of error, ensure that at least one local type is referenced
by the <code>impl</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span>; <span class='comment'>// you define your type in your crate</span>

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { <span class='comment'>// and you can implement the trait on it!</span>
    <span class='comment'>// code of trait implementation here</span>
}

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>i32</span> { <span class='comment'>// or you use a type from your crate as</span>
                         <span class='comment'>// a type parameter</span>
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>i</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='number'>0</span>
    }
}</pre>

<p>Alternatively, define a trait locally and implement that instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>u32</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}</pre>

<p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/pull/1023">RFC 1023</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0118" class="section-header"><a href="#E0118">E0118</a></h2>
<p>Rust can&#39;t find a base type for an implementation you are providing, or the type
cannot have an implementation. For example, only a named type or a trait can
have an implementation:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>NineString</span> <span class='op'>=</span> [<span class='ident'>char</span>, ..<span class='number'>9</span>] <span class='comment'>// This isn&#39;t a named type (struct, enum or trait)</span>
<span class='kw'>impl</span> <span class='ident'>NineString</span> {
    <span class='comment'>// Some code here</span>
}</pre>

<p>In the other, simpler case, Rust just can&#39;t find the type you are providing an
impelementation for:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>SomeTypeThatDoesntExist</span> {  }</pre>
</div>
<div class="error-described error-used"><h2 id="E0119" class="section-header"><a href="#E0119">E0119</a></h2>
<p>There are conflicting trait implementations for the same type.
Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}

<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>value</span>: <span class='ident'>usize</span>
}

<span class='kw'>impl</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { <span class='comment'>// error: conflicting implementations for trait</span>
                       <span class='comment'>//        `MyTrait`</span>
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='self'>self</span>.<span class='ident'>value</span> }
}</pre>

<p>When looking for the implementation for the trait, the compiler finds
both the <code>impl&lt;T&gt; MyTrait for T</code> where T is all types and the <code>impl MyTrait for Foo</code>. Since a trait cannot be implemented multiple times,
this is an error. So, when you write:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}</pre>

<p>This makes the trait implemented on all types in the scope. So if you
try to implement it on another one after that, the implementations will
conflict. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>0</span> }
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span>;

    <span class='ident'>f</span>.<span class='ident'>get</span>(); <span class='comment'>// the trait is implemented so we can use it</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0120" class="section-header"><a href="#E0120">E0120</a></h2>
<p>An attempt was made to implement Drop on a trait, which is not allowed: only
structs and enums can implement Drop. An example causing this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}</pre>

<p>A workaround for this problem is to wrap the trait up in a struct, and implement
Drop on that. An example is shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {}
<span class='kw'>struct</span> <span class='ident'>MyWrapper</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>MyTrait</span><span class='op'>&gt;</span> { <span class='ident'>foo</span>: <span class='ident'>T</span> }

<span class='kw'>impl</span> <span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>MyTrait</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>MyWrapper</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}
</pre>

<p>Alternatively, wrapping trait objects requires something like the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {}

<span class='comment'>//or Box&lt;MyTrait&gt;, if you wanted an owned trait object</span>
<span class='kw'>struct</span> <span class='ident'>MyWrapper</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> { <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>MyTrait</span> }

<span class='kw'>impl</span> <span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>MyWrapper</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0121" class="section-header"><a href="#E0121">E0121</a></h2>
<p>In order to be consistent with Rust&#39;s lack of global type inference, type
placeholders are disallowed by design in item signatures.</p>

<p>Examples of this error include:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> _ { <span class='number'>5</span> } <span class='comment'>// error, explicitly write out the return type instead</span>

<span class='kw'>static</span> <span class='ident'>BAR</span>: _ <span class='op'>=</span> <span class='string'>&quot;test&quot;</span>; <span class='comment'>// error, explicitly write out the type instead</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0122" class="section-header"><a href="#E0122">E0122</a></h2>
<p>An attempt was made to add a generic constraint to a type alias. While Rust will
allow this with a warning, it will not currently enforce the constraint.
Consider the example below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span>{}

<span class='kw'>type</span> <span class='ident'>MyType</span><span class='op'>&lt;</span><span class='ident'>R</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span> <span class='op'>=</span> (<span class='ident'>R</span>, ());

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>t</span>: <span class='ident'>MyType</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>;
}</pre>

<p>We&#39;re able to declare a variable of type <code>MyType&lt;u32&gt;</code>, despite the fact that
<code>u32</code> does not implement <code>Foo</code>. As a result, one should avoid using generic
constraints in concert with type aliases.</p>
</div>
<div class="error-described error-used"><h2 id="E0124" class="section-header"><a href="#E0124">E0124</a></h2>
<p>You declared two fields of a struct with the same name. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>field1</span>: <span class='ident'>i32</span>,
    <span class='ident'>field1</span>: <span class='ident'>i32</span> <span class='comment'>// error: field is already declared</span>
}</pre>

<p>Please verify that the field names have been correctly spelled. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>field1</span>: <span class='ident'>i32</span>,
    <span class='ident'>field2</span>: <span class='ident'>i32</span> <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0128" class="section-header"><a href="#E0128">E0128</a></h2>
<p>Type parameter defaults can only use parameters that occur before them.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>=</span><span class='ident'>U</span>, <span class='ident'>U</span><span class='op'>=</span>()<span class='op'>&gt;</span> {
    <span class='ident'>field1</span>: <span class='ident'>T</span>,
    <span class='ident'>filed2</span>: <span class='ident'>U</span>,
}
<span class='comment'>// error: type parameters with a default cannot use forward declared</span>
<span class='comment'>// identifiers</span></pre>

<p>Since type parameters are evaluated in-order, you may be able to fix this issue
by doing:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>U</span><span class='op'>=</span>(), <span class='ident'>T</span><span class='op'>=</span><span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='ident'>field1</span>: <span class='ident'>T</span>,
    <span class='ident'>filed2</span>: <span class='ident'>U</span>,
}</pre>

<p>Please also verify that this wasn&#39;t because of a name-clash and rename the type
parameter if so.</p>
</div>
<div class="error-described error-used"><h2 id="E0130" class="section-header"><a href="#E0130">E0130</a></h2>
<p>You declared a pattern as an argument in a foreign function declaration.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>((<span class='ident'>a</span>, <span class='ident'>b</span>): (<span class='ident'>u32</span>, <span class='ident'>u32</span>)); <span class='comment'>// error: patterns aren&#39;t allowed in foreign</span>
                                <span class='comment'>//        function declarations</span>
}</pre>

<p>Please replace the pattern argument with a regular one. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>SomeStruct</span> {
    <span class='ident'>a</span>: <span class='ident'>u32</span>,
    <span class='ident'>b</span>: <span class='ident'>u32</span>,
}

<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>s</span>: <span class='ident'>SomeStruct</span>); <span class='comment'>// ok!</span>
}
<span class='comment'>// or</span>
<span class='kw'>extern</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>a</span>: (<span class='ident'>u32</span>, <span class='ident'>u32</span>)); <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0131" class="section-header"><a href="#E0131">E0131</a></h2>
<p>It is not possible to define <code>main</code> with type parameters, or even with function
parameters. When <code>main</code> is present, it must take no arguments and return <code>()</code>.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() { <span class='comment'>// error: main function is not allowed to have type parameters</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0132" class="section-header"><a href="#E0132">E0132</a></h2>
<p>It is not possible to declare type parameters on a function that has the <code>start</code>
attribute. Such a function must have the following type signature:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span>(<span class='ident'>isize</span>, <span class='op'>*</span><span class='kw'>const</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>isize</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0133" class="section-header"><a href="#E0133">E0133</a></h2>
<p>Using unsafe functionality, is potentially dangerous and disallowed
by safety checks. Examples:</p>

<ul>
<li>Dereferencing raw pointers</li>
<li>Calling functions via FFI</li>
<li>Calling functions marked unsafe</li>
</ul>

<p>These safety checks can be relaxed for a section of the code
by wrapping the unsafe instructions with an <code>unsafe</code> block. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>f</span>() { <span class='kw'>return</span>; }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> { <span class='ident'>f</span>(); }
}</pre>

<p>See also <a href="https://doc.rust-lang.org/book/unsafe.html">https://doc.rust-lang.org/book/unsafe.html</a></p>
</div>
<div class="error-described error-used"><h2 id="E0136" class="section-header"><a href="#E0136">E0136</a></h2>
<p>A binary can only have one entry point, and by default that entry point is the
function <code>main()</code>. If there are multiple such functions, please rename one.</p>
</div>
<div class="error-described error-used"><h2 id="E0137" class="section-header"><a href="#E0137">E0137</a></h2>
<p>This error indicates that the compiler found multiple functions with the
<code>#[main]</code> attribute. This is an error because there must be a unique entry
point into a Rust program.</p>
</div>
<div class="error-described error-used"><h2 id="E0138" class="section-header"><a href="#E0138">E0138</a></h2>
<p>This error indicates that the compiler found multiple functions with the
<code>#[start]</code> attribute. This is an error because there must be a unique entry
point into a Rust program.</p>
</div>
<div class="error-described error-used"><h2 id="E0139" class="section-header"><a href="#E0139">E0139</a></h2>
<p>There are various restrictions on transmuting between types in Rust; for example
types being transmuted must have the same size. To apply all these restrictions,
the compiler must know the exact types that may be transmuted. When type
parameters are involved, this cannot always be done.</p>

<p>So, for example, the following is not allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>)

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) {
    <span class='comment'>// we are transmuting between Vec&lt;T&gt; and Foo&lt;T&gt; here</span>
    <span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>transmute</span>(<span class='ident'>x</span>) };
    <span class='comment'>// do something with y</span>
}</pre>

<p>In this specific case there&#39;s a good chance that the transmute is harmless (but
this is not guaranteed by Rust). However, when alignment and enum optimizations
come into the picture, it&#39;s quite likely that the sizes may or may not match
with different type parameter substitutions. It&#39;s not possible to check this for
<em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any
unsubstituted type parameters.</p>

<p>If you need this, there&#39;s a good chance you&#39;re doing something wrong. Keep in
mind that Rust doesn&#39;t guarantee much about the layout of different structs
(even two structs with identical declarations may have different layouts). If
there is a solution that avoids the transmute entirely, try it instead.</p>

<p>If it&#39;s possible, hand-monomorphize the code by writing the function for each
possible type substitution. It&#39;s possible to use traits to do this cleanly,
for example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTransmutableType</span> {
    <span class='kw'>fn</span> <span class='ident'>transmute</span>(<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw'>Self</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='kw'>Self</span><span class='op'>&gt;</span>
}

<span class='kw'>impl</span> <span class='ident'>MyTransmutableType</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>transmute</span>(<span class='ident'>x</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> {
        <span class='ident'>transmute</span>(<span class='ident'>x</span>)
    }
}
<span class='kw'>impl</span> <span class='ident'>MyTransmutableType</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>transmute</span>(<span class='ident'>x</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> {
        <span class='ident'>transmute</span>(<span class='ident'>x</span>)
    }
}
<span class='comment'>// ... more impls for the types you intend to transmute</span>

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>MyTransmutableType</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='op'>&lt;</span><span class='ident'>T</span> <span class='kw'>as</span> <span class='ident'>MyTransmutableType</span><span class='op'>&gt;</span>::<span class='ident'>transmute</span>(<span class='ident'>x</span>);
    <span class='comment'>// do something with y</span>
}</pre>

<p>Each impl will be checked for a size match in the transmute as usual, and since
there are no unbound type parameters involved, this should compile unless there
is a size mismatch in one of the impls.</p>

<p>It is also possible to manually transmute:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>ptr</span>::<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='ident'>v</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> _ <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>SomeType</span>) <span class='comment'>// `v` transmuted to `SomeType`</span></pre>

<p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a
call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p>
</div>
<div class="error-described error-used"><h2 id="E0152" class="section-header"><a href="#E0152">E0152</a></h2>
<p>Lang items are already implemented in the standard library. Unless you are
writing a free-standing application (e.g. a kernel), you do not need to provide
them yourself.</p>

<p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate
attributes:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span></pre>

<p>See also <a href="https://doc.rust-lang.org/book/no-stdlib.html">https://doc.rust-lang.org/book/no-stdlib.html</a></p>
</div>
<div class="error-described error-used"><h2 id="E0154" class="section-header"><a href="#E0154">E0154</a></h2>
<p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as
variable declarations and expression statements.</p>

<p>Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {
    <span class='comment'>// Variable declaration before import</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
    ...
}</pre>

<p>The solution is to declare the imports at the top of the block, function, or
file.</p>

<p>Here is the previous example again, with the correct order:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>f</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>;
    ...
}</pre>

<p>See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:</p>

<p><a href="https://doc.rust-lang.org/reference.html#statements">https://doc.rust-lang.org/reference.html#statements</a></p>
</div>
<div class="error-described error-used"><h2 id="E0158" class="section-header"><a href="#E0158">E0158</a></h2>
<p><code>const</code> and <code>static</code> mean different things. A <code>const</code> is a compile-time
constant, an alias for a literal value. This property means you can match it
directly within a pattern.</p>

<p>The <code>static</code> keyword, on the other hand, guarantees a fixed location in memory.
This does not always mean that the value is constant. For example, a global
mutex can be declared <code>static</code> as well.</p>

<p>If you want to match against a <code>static</code>, consider using a guard instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>FORTY_TWO</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='number'>42</span>) {
    <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>FORTY_TWO</span> <span class='op'>=&gt;</span> ...
    ...
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0161" class="section-header"><a href="#E0161">E0161</a></h2>
<p>In Rust, you can only move a value when its size is known at compile time.</p>

<p>To work around this restriction, consider &quot;hiding&quot; the value behind a reference:
either <code>&amp;x</code> or <code>&amp;mut x</code>. Since a reference has a fixed size, this lets you move
it around as usual.</p>
</div>
<div class="error-described error-used"><h2 id="E0162" class="section-header"><a href="#E0162">E0162</a></h2>
<p>An if-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding instead. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Irrefutable</span>(<span class='ident'>i32</span>);
<span class='kw'>let</span> <span class='ident'>irr</span> <span class='op'>=</span> <span class='ident'>Irrefutable</span>(<span class='number'>0</span>);

<span class='comment'>// This fails to compile because the match is irrefutable.</span>
<span class='kw'>if</span> <span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span> {
    <span class='comment'>// This body will always be executed.</span>
    <span class='ident'>foo</span>(<span class='ident'>x</span>);
}

<span class='comment'>// Try this instead:</span>
<span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span>;
<span class='ident'>foo</span>(<span class='ident'>x</span>);</pre>
</div>
<div class="error-described error-used"><h2 id="E0163" class="section-header"><a href="#E0163">E0163</a></h2>
<p>This error means that an attempt was made to match an enum variant as a
struct type when the variant isn&#39;t a struct type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> { <span class='ident'>B</span>(<span class='ident'>u32</span>) }

<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>foo</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>match</span> <span class='ident'>foo</span> {
        <span class='ident'>Foo</span>::<span class='ident'>B</span>{<span class='ident'>i</span>} <span class='op'>=&gt;</span> <span class='ident'>i</span> <span class='comment'>// error 0163</span>
    }
}</pre>

<p>Try using <code>()</code> instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>foo</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>match</span> <span class='ident'>foo</span> {
        <span class='ident'>Foo</span>::<span class='ident'>B</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='ident'>i</span>
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0164" class="section-header"><a href="#E0164">E0164</a></h2>
<p>This error means that an attempt was made to match a struct type enum
variant as a non-struct type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> { <span class='ident'>B</span>{ <span class='ident'>i</span>: <span class='ident'>u32</span> } }

<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>foo</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>match</span> <span class='ident'>foo</span> {
        <span class='ident'>Foo</span>::<span class='ident'>B</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='ident'>i</span> <span class='comment'>// error 0164</span>
    }
}</pre>

<p>Try using <code>{}</code> instead:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>foo</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>match</span> <span class='ident'>foo</span> {
        <span class='ident'>Foo</span>::<span class='ident'>B</span>{<span class='ident'>i</span>} <span class='op'>=&gt;</span> <span class='ident'>i</span>
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0165" class="section-header"><a href="#E0165">E0165</a></h2>
<p>A while-let pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Irrefutable</span>(<span class='ident'>i32</span>);
<span class='kw'>let</span> <span class='ident'>irr</span> <span class='op'>=</span> <span class='ident'>Irrefutable</span>(<span class='number'>0</span>);

<span class='comment'>// This fails to compile because the match is irrefutable.</span>
<span class='kw'>while</span> <span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span> {
    ...
}

<span class='comment'>// Try this instead:</span>
<span class='kw'>loop</span> {
    <span class='kw'>let</span> <span class='ident'>Irrefutable</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>irr</span>;
    ...
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0166" class="section-header"><a href="#E0166">E0166</a></h2>
<p>This error means that the compiler found a return expression in a function
marked as diverging. A function diverges if it has <code>!</code> in the place of the
return type in its signature. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='kw'>return</span>; } <span class='comment'>// error</span></pre>

<p>For a function that diverges, every control path in the function must never
return, for example with a <code>loop</code> that never breaks or a call to another
diverging function (such as <code>panic!()</code>).</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0167" class="section-header"><a href="#E0167">E0167</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0170" class="section-header"><a href="#E0170">E0170</a></h2>
<p>Enum variants are qualified by default. For example, given this type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Method</span> {
    <span class='ident'>GET</span>,
    <span class='ident'>POST</span>
}</pre>

<p>you would match it using:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>m</span> {
    <span class='ident'>Method</span>::<span class='ident'>GET</span> <span class='op'>=&gt;</span> ...
    <span class='ident'>Method</span>::<span class='ident'>POST</span> <span class='op'>=&gt;</span> ...
}</pre>

<p>If you don&#39;t qualify the names, the code will bind new variables named &quot;GET&quot; and
&quot;POST&quot; instead. This behavior is likely not what you want, so <code>rustc</code> warns when
that happens.</p>

<p>Qualified names are good practice, and most code works well with them. But if
you prefer them unqualified, you can import the variants into scope:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>Method</span>::<span class='op'>*</span>;
<span class='kw'>enum</span> <span class='ident'>Method</span> { <span class='ident'>GET</span>, <span class='ident'>POST</span> }</pre>

<p>If you want others to be able to import variants from your module directly, use
<code>pub use</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>Method</span>::<span class='op'>*</span>;
<span class='kw'>enum</span> <span class='ident'>Method</span> { <span class='ident'>GET</span>, <span class='ident'>POST</span> }</pre>
</div>
<div class="error-described error-used"><h2 id="E0172" class="section-header"><a href="#E0172">E0172</a></h2>
<p>This error means that an attempt was made to specify the type of a variable with
a combination of a concrete type and a trait. Consider the following example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>bar</span>: <span class='ident'>i32</span><span class='op'>+</span><span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Display</span>) {}</pre>

<p>The code is trying to specify that we want to receive a signed 32-bit integer
which also implements <code>Display</code>. This doesn&#39;t make sense: when we pass <code>i32</code>, a
concrete type, it implicitly includes all of the traits that it implements.
This includes <code>Display</code>, <code>Debug</code>, <code>Clone</code>, and a host of others.</p>

<p>If <code>i32</code> implements the trait we desire, there&#39;s no need to specify the trait
separately. If it does not, then we need to <code>impl</code> the trait for <code>i32</code> before
passing it into <code>foo</code>. Either way, a fixed definition for <code>foo</code> will look like
the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>bar</span>: <span class='ident'>i32</span>) {}</pre>

<p>To learn more about traits, take a look at the Book:</p>

<p><a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a></p>
</div>
<div class="error-undescribed error-used"><h2 id="E0174" class="section-header"><a href="#E0174">E0174</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0178" class="section-header"><a href="#E0178">E0178</a></h2>
<p>In types, the <code>+</code> type operator has low precedence, so it is often necessary
to use parentheses.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>w</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='ident'>Copy</span>,   <span class='comment'>// error, use &amp;&#39;a (Foo + Copy)</span>
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span>,     <span class='comment'>// error, use &amp;&#39;a (Foo + &#39;a)</span>
    <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span>, <span class='comment'>// error, use &amp;&#39;a mut (Foo + &#39;a)</span>
    <span class='ident'>z</span>: <span class='kw'>fn</span>() <span class='op'>-&gt;</span> <span class='ident'>Foo</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span>, <span class='comment'>// error, use fn() -&gt; (Foo + &#39;a)</span>
}</pre>

<p>More details can be found in <a href="https://github.com/rust-lang/rfcs/pull/438">RFC 438</a>.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0182" class="section-header"><a href="#E0182">E0182</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0183" class="section-header"><a href="#E0183">E0183</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0184" class="section-header"><a href="#E0184">E0184</a></h2>
<p>Explicitly implementing both Drop and Copy for a type is currently disallowed.
This feature can make some sense in theory, but the current implementation is
incorrect and can lead to memory unsafety (see <a href="https://github.com/rust-lang/rust/issues/20126">issue #20126</a>), so
it has been disabled for now.</p>
</div>
<div class="error-described error-used"><h2 id="E0185" class="section-header"><a href="#E0185">E0185</a></h2>
<p>An associated function for a trait was defined to be static, but an
implementation of the trait declared the same function to be a method (i.e. to
take a <code>self</code> parameter).</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='comment'>// error, method `foo` has a `&amp;self` declaration in the impl, but not in</span>
    <span class='comment'>// the trait</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0186" class="section-header"><a href="#E0186">E0186</a></h2>
<p>An associated function for a trait was defined to be a method (i.e. to take a
<code>self</code> parameter), but an implementation of the trait declared the same function
to be static.</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='comment'>// error, method `foo` has a `&amp;self` declaration in the trait, but not in</span>
    <span class='comment'>// the impl</span>
    <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0191" class="section-header"><a href="#E0191">E0191</a></h2>
<p>Trait objects need to have all associated types specified. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Trait</span>; <span class='comment'>// error: the value of the associated type `Bar` (from</span>
                  <span class='comment'>//        the trait `Trait`) must be specified</span></pre>

<p>Please verify you specified all associated types of the trait and that you
used the right trait. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>Bar</span><span class='op'>=</span><span class='ident'>i32</span><span class='op'>&gt;</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0192" class="section-header"><a href="#E0192">E0192</a></h2>
<p>Negative impls are only allowed for traits with default impls. For more
information see the <a href="https://github.com/rust-lang/%0Arfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0193" class="section-header"><a href="#E0193">E0193</a></h2>
<p><code>where</code> clauses must use generic type parameters: it does not make sense to use
them otherwise. An example causing this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>,<span class='ident'>Clone</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Wrapper</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Wrapped</span>: <span class='ident'>T</span>
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Wrapper</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>Wrapper</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>: <span class='ident'>Clone</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { }
}</pre>

<p>This use of a <code>where</code> clause is strange - a more common usage would look
something like the following:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Wrapper</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>Wrapper</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>: <span class='ident'>Clone</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { }
}</pre>

<p>Here, we&#39;re saying that the implementation exists on Wrapper only when the
wrapped type <code>T</code> implements <code>Clone</code>. The <code>where</code> clause is important because
some types will not implement <code>Clone</code>, and thus will not get this method.</p>

<p>In our erroneous example, however, we&#39;re referencing a single concrete type.
Since we know for certain that <code>Wrapper&lt;u32&gt;</code> implements <code>Clone</code>, there&#39;s no
reason to also specify it in a <code>where</code> clause.</p>
</div>
<div class="error-described error-used"><h2 id="E0194" class="section-header"><a href="#E0194">E0194</a></h2>
<p>A type parameter was declared which shadows an existing one. An example of this
error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>do_something_else</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>bar</span>: <span class='ident'>T</span>);
}</pre>

<p>In this example, the trait <code>Foo</code> and the trait method <code>do_something_else</code> both
define a type parameter <code>T</code>. This is not allowed: if the method wishes to
define a type parameter, it must use a different name for it.</p>
</div>
<div class="error-described error-used"><h2 id="E0195" class="section-header"><a href="#E0195">E0195</a></h2>
<p>Your method&#39;s lifetime parameters do not match the trait declaration.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span>:<span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>);
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) {
    <span class='comment'>// error: lifetime parameters or bounds on method `bar`</span>
    <span class='comment'>// do not match the trait declaration</span>
    }
}</pre>

<p>The lifetime constraint <code>&#39;b</code> for bar() implementation does not match the
trait declaration. Ensure lifetime declarations match exactly in both trait
declaration and implementation. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>fn</span> <span class='ident'>t</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span>:<span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>);
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>t</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>,<span class='lifetime'>&#39;b</span>:<span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) { <span class='comment'>// ok!</span>
    }
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0196" class="section-header"><a href="#E0196">E0196</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0197" class="section-header"><a href="#E0197">E0197</a></h2>
<p>Inherent implementations (one that do not implement a trait but provide
methods associated with a type) are always safe because they are not
implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent
implementation will resolve this error.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='comment'>// this will cause this error</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Foo</span> { }
<span class='comment'>// converting it to this will fix it</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> { }</pre>
</div>
<div class="error-described error-used"><h2 id="E0198" class="section-header"><a href="#E0198">E0198</a></h2>
<p>A negative implementation is one that excludes a type from implementing a
particular trait. Not being able to use a trait is always a safe operation,
so negative implementations are always safe and never need to be marked as
unsafe.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='comment'>// unsafe is unnecessary</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='op'>!</span><span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
<span class='comment'>// this will compile</span>
<span class='kw'>impl</span> <span class='op'>!</span><span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }</pre>
</div>
<div class="error-described error-used"><h2 id="E0199" class="section-header"><a href="#E0199">E0199</a></h2>
<p>Safe traits should not have unsafe implementations, therefore marking an
implementation for a safe trait unsafe will cause a compiler error. Removing the
unsafe marker on the trait noted in the error will resolve this problem.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>trait</span> <span class='ident'>Bar</span> { }

<span class='comment'>// this won&#39;t compile because Bar is safe</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
<span class='comment'>// this will compile</span>
<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }</pre>
</div>
<div class="error-described error-used"><h2 id="E0200" class="section-header"><a href="#E0200">E0200</a></h2>
<p>Unsafe traits must have unsafe implementations. This error occurs when an
implementation for an unsafe trait isn&#39;t marked as unsafe. This may be resolved
by marking the unsafe implementation as unsafe.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>unsafe</span> <span class='kw'>trait</span> <span class='ident'>Bar</span> { }

<span class='comment'>// this won&#39;t compile because Bar is unsafe and impl isn&#39;t unsafe</span>
<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }
<span class='comment'>// this will compile</span>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }</pre>
</div>
<div class="error-described error-used"><h2 id="E0201" class="section-header"><a href="#E0201">E0201</a></h2>
<p>It is an error to define two associated items (like methods, associated types,
associated functions, etc.) with the same identifier.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>u8</span>);

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>&gt;</span> <span class='number'>5</span> }
    <span class='kw'>fn</span> <span class='ident'>bar</span>() {} <span class='comment'>// error: duplicate associated function</span>
}

<span class='kw'>trait</span> <span class='ident'>Baz</span> {
    <span class='kw'>type</span> <span class='ident'>Quux</span>;
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}

<span class='kw'>impl</span> <span class='ident'>Baz</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Quux</span> <span class='op'>=</span> <span class='ident'>u32</span>;

    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='boolval'>true</span> }

    <span class='comment'>// error: duplicate method</span>
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>&gt;</span> <span class='number'>5</span> }

    <span class='comment'>// error: duplicate associated type</span>
    <span class='kw'>type</span> <span class='ident'>Quux</span> <span class='op'>=</span> <span class='ident'>u32</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0202" class="section-header"><a href="#E0202">E0202</a></h2>
<p>Inherent associated types were part of <a href="https://github.com/rust-lang/rfcs/pull/195">RFC 195</a> but are not yet implemented.
See <a href="https://github.com/rust-lang/rust/issues/8995">the tracking issue</a> for the status of this implementation.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0203" class="section-header"><a href="#E0203">E0203</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0204" class="section-header"><a href="#E0204">E0204</a></h2>
<p>An attempt to implement the <code>Copy</code> trait for a struct failed because one of the
fields does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for the
mentioned field. Note that this may not be possible, as in the example of</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>foo</span> : <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>,
}

<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }</pre>

<p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p>

<p>Here&#39;s another example that will fail:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>ty</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>bool</span>,
}</pre>

<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
</div>
<div class="error-described error-used"><h2 id="E0205" class="section-header"><a href="#E0205">E0205</a></h2>
<p>An attempt to implement the <code>Copy</code> trait for an enum failed because one of the
variants does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for
the mentioned variant. Note that this may not be possible, as in the example of</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>(<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>),
    <span class='ident'>Baz</span>,
}

<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { }</pre>

<p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p>

<p>Here&#39;s another example that will fail:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>Bar</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>bool</span>),
    <span class='ident'>Baz</span>
}</pre>

<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
</div>
<div class="error-described error-used"><h2 id="E0206" class="section-header"><a href="#E0206">E0206</a></h2>
<p>You can only implement <code>Copy</code> for a struct or enum. Both of the following
examples will fail, because neither <code>i32</code> (primitive type) nor <code>&amp;&#39;static Bar</code>
(reference to <code>Bar</code>) is a struct or enum:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>i32</span>;
<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { } <span class='comment'>// error</span>

<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>, <span class='ident'>Clone</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;
<span class='kw'>impl</span> <span class='ident'>Copy</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>Bar</span> { } <span class='comment'>// error</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0207" class="section-header"><a href="#E0207">E0207</a></h2>
<p>You declared an unused type parameter when implementing a trait on an object.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='number'>0</span>
    }
}</pre>

<p>Please check your object definition and remove unused type
parameter(s). Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span>;
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>get</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
        <span class='number'>0</span>
    }
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0208" class="section-header"><a href="#E0208">E0208</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0210" class="section-header"><a href="#E0210">E0210</a></h2>
<p>This error indicates a violation of one of Rust&#39;s orphan rules for trait
implementations. The rule concerns the use of type parameters in an
implementation of a foreign trait (a trait defined in another crate), and
states that type parameters must be &quot;covered&quot; by a local type. To understand
what this means, it is perhaps easiest to consider a few examples.</p>

<p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the
following trait <code>impl</code> is an error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>foo</span>;
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>ForeignTrait</span>;

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>ForeignTrait</span> <span class='kw'>for</span> <span class='ident'>T</span> { ... } <span class='comment'>// error</span></pre>

<p>To work around this, it can be covered with a local type, <code>MyType</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>MyType</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>T</span>);
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>ForeignTrait</span> <span class='kw'>for</span> <span class='ident'>MyType</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { ... } <span class='comment'>// Ok</span></pre>

<p>For another example of an error, suppose there&#39;s another trait defined in <code>foo</code>
named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results
in the same rule violation:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>MyType2</span>;
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>ForeignTrait2</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>MyType</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span> <span class='kw'>for</span> <span class='ident'>MyType2</span> { ... } <span class='comment'>// error</span></pre>

<p>The reason for this is that there are two appearances of type parameter <code>T</code> in
the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance
is uncovered, and so runs afoul of the orphan rule.</p>

<p>Consider one more example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>ForeignTrait2</span><span class='op'>&lt;</span><span class='ident'>MyType</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>MyType2</span> { ... } <span class='comment'>// Ok</span></pre>

<p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and
<code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em>
violate the orphan rule; it is permitted.</p>

<p>To see why that last example was allowed, you need to understand the general
rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>P1</span>, ..., <span class='ident'>Pm</span><span class='op'>&gt;</span> <span class='ident'>ForeignTrait</span><span class='op'>&lt;</span><span class='ident'>T1</span>, ..., <span class='ident'>Tn</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>T0</span> { ... }</pre>

<p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code>
are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another
orphan rule, see the explanation for E0117). Let <code>i</code> be the smallest integer
such that <code>Ti</code> is a local type. Then no type parameter can appear in any of the
<code>Tj</code> for <code>j &lt; i</code>.</p>

<p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/pull/1023">RFC 1023</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0211" class="section-header"><a href="#E0211">E0211</a></h2>
<p>You used a function or type which doesn&#39;t fit the requirements for where it was
used. Erroneous code examples:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(); <span class='comment'>// error: intrinsic has wrong type</span>
}

<span class='comment'>// or:</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>0</span> }
<span class='comment'>// error: main function expects type: `fn() {main}`: expected (), found i32</span>

<span class='comment'>// or:</span>

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1u8</span>;
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>0u8</span>...<span class='number'>3i8</span> <span class='op'>=&gt;</span> (),
    <span class='comment'>// error: mismatched types in range: expected u8, found i8</span>
    _ <span class='op'>=&gt;</span> ()
}

<span class='comment'>// or:</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>x</span>(<span class='self'>self</span>: <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span>) {}
    <span class='comment'>// error: mismatched self type: expected `Foo`: expected struct</span>
    <span class='comment'>//        `Foo`, found struct `alloc::rc::Rc`</span>
}</pre>

<p>For the first code example, please check the function definition. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>intrinsics</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>size_of</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span>; <span class='comment'>// ok!</span>
}</pre>

<p>The second case example is a bit particular : the main function must always
have this definition:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>();</pre>

<p>They never take parameters and never return types.</p>

<p>For the third example, when you match, all patterns must have the same type
as the type you&#39;re matching on. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1u8</span>;
<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>0u8</span>...<span class='number'>3u8</span> <span class='op'>=&gt;</span> (), <span class='comment'>// ok!</span>
    _ <span class='op'>=&gt;</span> ()
}</pre>

<p>And finally, for the last example, only <code>Box&lt;Self&gt;</code>, <code>&amp;Self</code>, <code>Self</code>,
or <code>&amp;mut Self</code> work as explicit self parameters. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>x</span>(<span class='self'>self</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span>) {} <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0212" class="section-header"><a href="#E0212">E0212</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0214" class="section-header"><a href="#E0214">E0214</a></h2>
<p>A generic type was described using parentheses rather than angle brackets. For
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span>(<span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;foo&quot;</span>];
}</pre>

<p>This is not currently supported: <code>v</code> should be defined as <code>Vec&lt;&amp;str&gt;</code>.
Parentheses are currently only used with generic types when defining parameters
for <code>Fn</code>-family traits.</p>
</div>
<div class="error-described error-used"><h2 id="E0220" class="section-header"><a href="#E0220">E0220</a></h2>
<p>You used an associated type which isn&#39;t defined in the trait.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>=</span><span class='ident'>i32</span><span class='op'>&gt;</span>; <span class='comment'>// error: associated type `F` not found for</span>
                         <span class='comment'>//        `Trait`</span></pre>

<p>Please verify you used the right trait or you didn&#39;t misspell the
associated type name. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>Bar</span><span class='op'>=</span><span class='ident'>i32</span><span class='op'>&gt;</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0221" class="section-header"><a href="#E0221">E0221</a></h2>
<p>An attempt was made to retrieve an associated type, but the type was ambiguous.
For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>T1</span> {}
<span class='kw'>trait</span> <span class='ident'>T2</span> {}

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>A</span>: <span class='ident'>T1</span>;
}

<span class='kw'>trait</span> <span class='ident'>Bar</span> : <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>A</span>: <span class='ident'>T2</span>;
    <span class='kw'>fn</span> <span class='ident'>do_something</span>() {
        <span class='kw'>let</span> _: <span class='ident'>Self</span>::<span class='ident'>A</span>;
    }
}</pre>

<p>In this example, <code>Foo</code> defines an associated type <code>A</code>. <code>Bar</code> inherits that type
from <code>Foo</code>, and defines another associated type of the same name. As a result,
when we attempt to use <code>Self::A</code>, it&#39;s ambiguous whether we mean the <code>A</code> defined
by <code>Foo</code> or the one defined by <code>Bar</code>.</p>

<p>There are two options to work around this issue. The first is simply to rename
one of the types. Alternatively, one can specify the intended type using the
following syntax:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span>() {
    <span class='kw'>let</span> _: <span class='op'>&lt;</span><span class='kw'>Self</span> <span class='kw'>as</span> <span class='ident'>Bar</span><span class='op'>&gt;</span>::<span class='ident'>A</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0223" class="section-header"><a href="#E0223">E0223</a></h2>
<p>An attempt was made to retrieve an associated type, but the type was ambiguous.
For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {<span class='kw'>type</span> <span class='ident'>X</span>; }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>foo</span>: <span class='ident'>MyTrait</span>::<span class='ident'>X</span>;
}</pre>

<p>The problem here is that we&#39;re attempting to take the type of X from MyTrait.
Unfortunately, the type of X is not defined, because it&#39;s only made concrete in
implementations of the trait. A working version of this code might look like:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>MyTrait</span> {<span class='kw'>type</span> <span class='ident'>X</span>; }
<span class='kw'>struct</span> <span class='ident'>MyStruct</span>;

<span class='kw'>impl</span> <span class='ident'>MyTrait</span> <span class='kw'>for</span> <span class='ident'>MyStruct</span> {
    <span class='kw'>type</span> <span class='ident'>X</span> <span class='op'>=</span> <span class='ident'>u32</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>foo</span>: <span class='op'>&lt;</span><span class='ident'>MyStruct</span> <span class='kw'>as</span> <span class='ident'>MyTrait</span><span class='op'>&gt;</span>::<span class='ident'>X</span>;
}</pre>

<p>This syntax specifies that we want the X type from MyTrait, as made concrete in
MyStruct. The reason that we cannot simply use <code>MyStruct::X</code> is that MyStruct
might implement two different traits with identically-named associated types.
This syntax allows disambiguation between the two.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0224" class="section-header"><a href="#E0224">E0224</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0225" class="section-header"><a href="#E0225">E0225</a></h2>
<p>You attempted to use multiple types as bounds for a closure or trait object.
Rust does not currently support this. A simple example that causes this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> _: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span><span class='op'>+</span><span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Write</span><span class='op'>&gt;</span>;
}</pre>

<p>Builtin traits are an exception to this rule: it&#39;s possible to have bounds of
one non-builtin type, plus any number of builtin types. For example, the
following compiles correctly:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> _: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span><span class='op'>+</span><span class='ident'>Copy</span><span class='op'>+</span><span class='ident'>Sync</span><span class='op'>&gt;</span>;
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0226" class="section-header"><a href="#E0226">E0226</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0227" class="section-header"><a href="#E0227">E0227</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0228" class="section-header"><a href="#E0228">E0228</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0229" class="section-header"><a href="#E0229">E0229</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0230" class="section-header"><a href="#E0230">E0230</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0231" class="section-header"><a href="#E0231">E0231</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0232" class="section-header"><a href="#E0232">E0232</a></h2>
<p>The attribute must have a value. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>rustc_on_unimplemented</span>]</span> <span class='comment'>// error: this attribute must have a value</span>
<span class='kw'>trait</span> <span class='ident'>Bar</span> {}</pre>

<p>Please supply the missing value of the attribute. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>rustc_on_unimplemented</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>]</span> <span class='comment'>// ok!</span>
<span class='kw'>trait</span> <span class='ident'>Bar</span> {}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0236" class="section-header"><a href="#E0236">E0236</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0237" class="section-header"><a href="#E0237">E0237</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0238" class="section-header"><a href="#E0238">E0238</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0242" class="section-header"><a href="#E0242">E0242</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0243" class="section-header"><a href="#E0243">E0243</a></h2>
<p>This error indicates that not enough type parameters were found in a type or
trait.</p>

<p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the
type parameter is missing in the definition of <code>Bar</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>x</span>: <span class='ident'>T</span> }

<span class='kw'>struct</span> <span class='ident'>Bar</span> { <span class='ident'>x</span>: <span class='ident'>Foo</span> }</pre>
</div>
<div class="error-described error-used"><h2 id="E0244" class="section-header"><a href="#E0244">E0244</a></h2>
<p>This error indicates that too many type parameters were found in a type or
trait.</p>

<p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied
with two in the definition of <code>Bar</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>bool</span> }

<span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>S</span>, <span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>x</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>S</span>, <span class='ident'>T</span><span class='op'>&gt;</span> }</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0245" class="section-header"><a href="#E0245">E0245</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0247" class="section-header"><a href="#E0247">E0247</a></h2>
<p>This error indicates an attempt to use a module name where a type is expected.
For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>MyMod</span> {
    <span class='kw'>mod</span> <span class='ident'>MySubMod</span> { }
}

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='ident'>MyMod</span>::<span class='ident'>MySubMod</span>) { }</pre>

<p>In this example, we&#39;re attempting to take a parameter of type <code>MyMod::MySubMod</code>
in the do_something function. This is not legal: <code>MyMod::MySubMod</code> is a module
name, not a type.</p>
</div>
<div class="error-described error-used"><h2 id="E0248" class="section-header"><a href="#E0248">E0248</a></h2>
<p>This error indicates an attempt to use a value where a type is expected. For
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>(<span class='ident'>u32</span>)
}

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='ident'>Foo</span>::<span class='ident'>Bar</span>) { }</pre>

<p>In this example, we&#39;re attempting to take a type of <code>Foo::Bar</code> in the
do_something function. This is not legal: <code>Foo::Bar</code> is a value of type <code>Foo</code>,
not a distinct static type. Likewise, it&#39;s not legal to attempt to
<code>impl Foo::Bar</code>: instead, you must <code>impl Foo</code> and then pattern match to specify
behavior for specific enum variants.</p>
</div>
<div class="error-described error-used"><h2 id="E0249" class="section-header"><a href="#E0249">E0249</a></h2>
<p>This error indicates a constant expression for the array length was found, but
it was not an integer (signed or unsigned) expression.</p>

<p>Some examples of code that produces this error are:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>A</span>: [<span class='ident'>u32</span>; <span class='string'>&quot;hello&quot;</span>] <span class='op'>=</span> []; <span class='comment'>// error</span>
<span class='kw'>const</span> <span class='ident'>B</span>: [<span class='ident'>u32</span>; <span class='boolval'>true</span>] <span class='op'>=</span> []; <span class='comment'>// error</span>
<span class='kw'>const</span> <span class='ident'>C</span>: [<span class='ident'>u32</span>; <span class='number'>0.0</span>] <span class='op'>=</span> []; <span class='comment'>// error</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0250" class="section-header"><a href="#E0250">E0250</a></h2>
<p>There was an error while evaluating the expression for the length of a fixed-
size array type.</p>

<p>Some examples of this error are:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// divide by zero in the length expression</span>
<span class='kw'>const</span> <span class='ident'>A</span>: [<span class='ident'>u32</span>; <span class='number'>1</span><span class='op'>/</span><span class='number'>0</span>] <span class='op'>=</span> [];

<span class='comment'>// Rust currently will not evaluate the function `foo` at compile time</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>usize</span> { <span class='number'>12</span> }
<span class='kw'>const</span> <span class='ident'>B</span>: [<span class='ident'>u32</span>; <span class='ident'>foo</span>()] <span class='op'>=</span> [];

<span class='comment'>// it is an error to try to add `u8` and `f64`</span>
<span class='kw'>use</span> <span class='ident'>std</span>::{<span class='ident'>f64</span>, <span class='ident'>u8</span>};
<span class='kw'>const</span> <span class='ident'>C</span>: [<span class='ident'>u32</span>; <span class='ident'>u8</span>::<span class='ident'>MAX</span> <span class='op'>+</span> <span class='ident'>f64</span>::<span class='ident'>EPSILON</span>] <span class='op'>=</span> [];</pre>
</div>
<div class="error-described error-used"><h2 id="E0251" class="section-header"><a href="#E0251">E0251</a></h2>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>baz</span>;
<span class='kw'>use</span> <span class='ident'>bar</span>::<span class='op'>*</span>; <span class='comment'>// error, do `use foo::baz as quux` instead on the previous line</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {}

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>baz</span>;
}

<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>baz</span> {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0252" class="section-header"><a href="#E0252">E0252</a></h2>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>baz</span>;
<span class='kw'>use</span> <span class='ident'>bar</span>::<span class='ident'>baz</span>; <span class='comment'>// error, do `use bar::baz as quux` instead</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {}

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>baz</span>;
}

<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>baz</span> {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0253" class="section-header"><a href="#E0253">E0253</a></h2>
<p>Attempt was made to import an unimportable value. This can happen when
trying to import a method from a trait. An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>MyTrait</span> {
        <span class='kw'>fn</span> <span class='ident'>do_something</span>();
    }
}
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>MyTrait</span>::<span class='ident'>do_something</span>;</pre>

<p>It&#39;s invalid to directly import methods belonging to a trait or concrete type.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0254" class="section-header"><a href="#E0254">E0254</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0255" class="section-header"><a href="#E0255">E0255</a></h2>
<p>You can&#39;t import a value whose name is the same as another value defined in the
module.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>bar</span>::<span class='ident'>foo</span>; <span class='comment'>// error, do `use bar::foo as baz` instead</span>

<span class='kw'>fn</span> <span class='ident'>foo</span>() {}

<span class='kw'>mod</span> <span class='ident'>bar</span> {
     <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {}</pre>
</div>
<div class="error-described error-used"><h2 id="E0256" class="section-header"><a href="#E0256">E0256</a></h2>
<p>You can&#39;t import a type or module when the name of the item being imported is
the same as another type or submodule defined in the module.</p>

<p>An example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>Bar</span>; <span class='comment'>// error</span>

<span class='kw'>type</span> <span class='ident'>Bar</span> <span class='op'>=</span> <span class='ident'>u32</span>;

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>Bar</span> { }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {}</pre>
</div>
<div class="error-undescribed error-unused"><h2 id="E0257" class="section-header"><a href="#E0257">E0257</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0258" class="section-header"><a href="#E0258">E0258</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0259" class="section-header"><a href="#E0259">E0259</a></h2>
<p>The name chosen for an external crate conflicts with another external crate that
has been imported into the current module.</p>

<p>Wrong example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>a</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>crate_a</span> <span class='kw'>as</span> <span class='ident'>a</span>;</pre>

<p>The solution is to choose a different name that doesn&#39;t conflict with any
external crate imported into the current module.</p>

<p>Correct example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>a</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>crate_a</span> <span class='kw'>as</span> <span class='ident'>other_name</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0260" class="section-header"><a href="#E0260">E0260</a></h2>
<p>The name for an item declaration conflicts with an external crate&#39;s name.</p>

<p>For instance,</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>abc</span>;

<span class='kw'>struct</span> <span class='ident'>abc</span>;</pre>

<p>There are two possible solutions:</p>

<p>Solution #1: Rename the item.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>abc</span>;

<span class='kw'>struct</span> <span class='ident'>xyz</span>;</pre>

<p>Solution #2: Import the crate with a different name.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>abc</span> <span class='kw'>as</span> <span class='ident'>xyz</span>;

<span class='kw'>struct</span> <span class='ident'>abc</span>;</pre>

<p>See the Declaration Statements section of the reference for more information
about what constitutes an Item declaration and what does not:</p>

<p><a href="https://doc.rust-lang.org/reference.html#statements">https://doc.rust-lang.org/reference.html#statements</a></p>
</div>
<div class="error-described error-used"><h2 id="E0261" class="section-header"><a href="#E0261">E0261</a></h2>
<p>When using a lifetime like <code>&#39;a</code> in a type, it must be declared before being
used.</p>

<p>These two examples illustrate the problem:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, use of undeclared lifetime name `&#39;a`</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>) { }

<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='comment'>// error, use of undeclared lifetime name `&#39;a`</span>
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>,
}</pre>

<p>These can be fixed by declaring lifetime parameters:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>) { }

<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>,
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0262" class="section-header"><a href="#E0262">E0262</a></h2>
<p>Declaring certain lifetime names in parameters is disallowed. For example,
because the <code>&#39;static</code> lifetime is a special built-in lifetime name denoting
the lifetime of the entire program, this is an error:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, invalid lifetime parameter name `&#39;static`</span>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>) { }</pre>
</div>
<div class="error-described error-used"><h2 id="E0263" class="section-header"><a href="#E0263">E0263</a></h2>
<p>A lifetime name cannot be declared more than once in the same scope. For
example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error, lifetime name `&#39;a` declared twice in the same scope</span>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span>, <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span>, <span class='ident'>y</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span>) { }</pre>
</div>
<div class="error-described error-used"><h2 id="E0264" class="section-header"><a href="#E0264">E0264</a></h2>
<p>An unknown external lang item was used. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;cake&quot;</span>]</span> <span class='comment'>// error: unknown external lang item: `cake`</span>
    <span class='kw'>fn</span> <span class='ident'>cake</span>();
}</pre>

<p>A list of available external lang items is available in
<code>src/librustc/middle/weak_lang_items.rs</code>. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>)]</span>

<span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> {
    <span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span> <span class='comment'>// ok!</span>
    <span class='kw'>fn</span> <span class='ident'>cake</span>();
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0265" class="section-header"><a href="#E0265">E0265</a></h2>
<p>This error indicates that a static or constant references itself.
All statics and constants need to resolve to a value in an acyclic manner.</p>

<p>For example, neither of the following can be sensibly compiled:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>X</span>;</pre>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>Y</span>;
<span class='kw'>const</span> <span class='ident'>Y</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>X</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0267" class="section-header"><a href="#E0267">E0267</a></h2>
<p>This error indicates the use of a loop keyword (<code>break</code> or <code>continue</code>) inside a
closure but outside of any loop. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='op'>||</span> { <span class='kw'>break</span>; }; <span class='comment'>// error: `break` inside of a closure</span></pre>

<p><code>break</code> and <code>continue</code> keywords can be used as normal inside closures as long as
they are also contained within a loop. To halt the execution of a closure you
should instead use a return statement. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='op'>||</span> {
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>break</span>;
    }
};

<span class='ident'>w</span>();</pre>
</div>
<div class="error-described error-used"><h2 id="E0268" class="section-header"><a href="#E0268">E0268</a></h2>
<p>This error indicates the use of a loop keyword (<code>break</code> or <code>continue</code>) outside
of a loop. Without a loop to break out of or continue in, no sensible action can
be taken. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>some_func</span>() {
    <span class='kw'>break</span>; <span class='comment'>// error: `break` outside of loop</span>
}</pre>

<p>Please verify that you are using <code>break</code> and <code>continue</code> only in loops. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>some_func</span>() {
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>break</span>; <span class='comment'>// ok!</span>
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0269" class="section-header"><a href="#E0269">E0269</a></h2>
<p>Functions must eventually return a value of their return type. For example, in
the following function</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>u8</span> {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
        <span class='ident'>x</span> <span class='comment'>// alternatively, `return x`</span>
    }
    <span class='comment'>// nothing here</span>
}</pre>

<p>if the condition is true, the value <code>x</code> is returned, but if the condition is
false, control exits the <code>if</code> block and reaches a place where nothing is being
returned. All possible control paths must eventually return a <code>u8</code>, which is not
happening here.</p>

<p>An easy fix for this in a complicated function is to specify a default return
value, if possible:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>u8</span> {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
        <span class='ident'>x</span> <span class='comment'>// alternatively, `return x`</span>
    }
    <span class='comment'>// lots of other if branches</span>
    <span class='number'>0</span> <span class='comment'>// return 0 if all else fails</span>
}</pre>

<p>It is advisable to find out what the unhandled cases are and check for them,
returning an appropriate value or panicking if necessary.</p>
</div>
<div class="error-described error-used"><h2 id="E0270" class="section-header"><a href="#E0270">E0270</a></h2>
<p>Rust lets you define functions which are known to never return, i.e. are
&#39;diverging&#39;, by marking its return type as <code>!</code>.</p>

<p>For example, the following functions never return:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='kw'>loop</span> {}
}

<span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='ident'>foo</span>() <span class='comment'>// foo() is diverging, so this will diverge too</span>
}

<span class='kw'>fn</span> <span class='ident'>baz</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='macro'>panic</span><span class='macro'>!</span>(); <span class='comment'>// this macro internally expands to a call to a diverging function</span>
}
</pre>

<p>Such functions can be used in a place where a value is expected without
returning a value of that type,  for instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='number'>1</span>,
    <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='number'>4</span>,
    _ <span class='op'>=&gt;</span> <span class='ident'>foo</span>() <span class='comment'>// diverging function called here</span>
};
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>y</span>)</pre>

<p>If the third arm of the match block is reached, since <code>foo()</code> doesn&#39;t ever
return control to the match block, it is fine to use it in a place where an
integer was expected. The <code>match</code> block will never finish executing, and any
point where <code>y</code> (like the print statement) is needed will not be reached.</p>

<p>However, if we had a diverging function that actually does finish execution</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> {
    <span class='kw'>loop</span> {<span class='kw'>break</span>;}
}</pre>

<p>then we would have an unknown value for <code>y</code> in the following code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='number'>1</span>,
    <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='number'>4</span>,
    _ <span class='op'>=&gt;</span> <span class='ident'>foo</span>()
};
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>y</span>);</pre>

<p>In the previous example, the print statement was never reached when the wildcard
match arm was hit, so we were okay with <code>foo()</code> not returning an integer that we
could set to <code>y</code>. But in this example, <code>foo()</code> actually does return control, so
the print statement will be executed with an uninitialized value.</p>

<p>Obviously we cannot have functions which are allowed to be used in such
positions and yet can return control. So, if you are defining a function that
returns <code>!</code>, make sure that there is no way for it to actually finish executing.</p>
</div>
<div class="error-described error-used"><h2 id="E0271" class="section-header"><a href="#E0271">E0271</a></h2>
<p>This is because of a type mismatch between the associated type of some
trait (e.g. <code>T::Bar</code>, where <code>T</code> implements <code>trait Quux { type Bar; }</code>)
and another type <code>U</code> that is required to be equal to <code>T::Bar</code>, but is not.
Examples follow.</p>

<p>Here is a basic example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span>; }
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>AssociatedType</span><span class='op'>=</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;in foo&quot;</span>);
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>i8</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>; }
<span class='ident'>foo</span>(<span class='number'>3_i8</span>);</pre>

<p>Here is that same example again, with some explanatory comments:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span>; }

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>AssociatedType</span><span class='op'>=</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
<span class='comment'>//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~</span>
<span class='comment'>//                        |            |</span>
<span class='comment'>//         This says `foo` can         |</span>
<span class='comment'>//           only be used with         |</span>
<span class='comment'>//              some type that         |</span>
<span class='comment'>//         implements `Trait`.         |</span>
<span class='comment'>//                                     |</span>
<span class='comment'>//                             This says not only must</span>
<span class='comment'>//                             `T` be an impl of `Trait`</span>
<span class='comment'>//                             but also that the impl</span>
<span class='comment'>//                             must assign the type `u32`</span>
<span class='comment'>//                             to the associated type.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;in foo&quot;</span>);
}

<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>i8</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>; }
<span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span>   <span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span><span class='kw-2'>~</span>
<span class='comment'>//      |                             |</span>
<span class='comment'>// `i8` does have                     |</span>
<span class='comment'>// implementation                     |</span>
<span class='comment'>// of `Trait`...                      |</span>
<span class='comment'>//                     ... but it is an implementation</span>
<span class='comment'>//                     that assigns `&amp;&#39;static str` to</span>
<span class='comment'>//                     the associated type.</span>

<span class='ident'>foo</span>(<span class='number'>3_i8</span>);
<span class='comment'>// Here, we invoke `foo` with an `i8`, which does not satisfy</span>
<span class='comment'>// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and</span>
<span class='comment'>// therefore the type-checker complains with this error code.</span></pre>

<p>Here is a more subtle instance of the same problem, that can
arise with for-loops in Rust:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>vs</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>v</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>vs</span> {
    <span class='kw'>match</span> <span class='ident'>v</span> {
        <span class='number'>1</span> <span class='op'>=&gt;</span> {}
        _ <span class='op'>=&gt;</span> {}
    }
}</pre>

<p>The above fails because of an analogous type mismatch,
though may be harder to see. Again, here are some
explanatory comments for the same example:</p>
<pre class='rust rust-example-rendered'>
{
    <span class='kw'>let</span> <span class='ident'>vs</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];

    <span class='comment'>// `for`-loops use a protocol based on the `Iterator`</span>
    <span class='comment'>// trait. Each item yielded in a `for` loop has the</span>
    <span class='comment'>// type `Iterator::Item` -- that is,I `Item` is the</span>
    <span class='comment'>// associated type of the concrete iterator impl.</span>
    <span class='kw'>for</span> <span class='ident'>v</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>vs</span> {
<span class='comment'>//      ~    ~~~</span>
<span class='comment'>//      |     |</span>
<span class='comment'>//      |    We borrow `vs`, iterating over a sequence of</span>
<span class='comment'>//      |    *references* of type `&amp;Elem` (where `Elem` is</span>
<span class='comment'>//      |    vector&#39;s element type). Thus, the associated</span>
<span class='comment'>//      |    type `Item` must be a reference `&amp;`-type ...</span>
<span class='comment'>//      |</span>
<span class='comment'>//  ... and `v` has the type `Iterator::Item`, as dictated by</span>
<span class='comment'>//  the `for`-loop protocol ...</span>

        <span class='kw'>match</span> <span class='ident'>v</span> {
            <span class='number'>1</span> <span class='op'>=&gt;</span> {}
<span class='comment'>//          ~</span>
<span class='comment'>//          |</span>
<span class='comment'>// ... but *here*, `v` is forced to have some integral type;</span>
<span class='comment'>// only types like `u8`,`i8`,`u16`,`i16`, et cetera can</span>
<span class='comment'>// match the pattern `1` ...</span>

            _ <span class='op'>=&gt;</span> {}
        }

<span class='comment'>// ... therefore, the compiler complains, because it sees</span>
<span class='comment'>// an attempt to solve the equations</span>
<span class='comment'>// `some integral-type` = type-of-`v`</span>
<span class='comment'>//                      = `Iterator::Item`</span>
<span class='comment'>//                      = `&amp;Elem` (i.e. `some reference type`)</span>
<span class='comment'>//</span>
<span class='comment'>// which cannot possibly all be true.</span>

    }
}</pre>

<p>To avoid those issues, you have to make the types match correctly.
So we can fix the previous examples like this:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Basic Example:</span>
<span class='kw'>trait</span> <span class='ident'>Trait</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span>; }
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Trait</span><span class='op'>&lt;</span><span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;in foo&quot;</span>);
}
<span class='kw'>impl</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='ident'>i8</span> { <span class='kw'>type</span> <span class='ident'>AssociatedType</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>; }
<span class='ident'>foo</span>(<span class='number'>3_i8</span>);

<span class='comment'>// For-Loop Example:</span>
<span class='kw'>let</span> <span class='ident'>vs</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>for</span> <span class='ident'>v</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>vs</span> {
    <span class='kw'>match</span> <span class='ident'>v</span> {
        <span class='kw-2'>&amp;</span><span class='number'>1</span> <span class='op'>=&gt;</span> {}
        _ <span class='op'>=&gt;</span> {}
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0272" class="section-header"><a href="#E0272">E0272</a></h2>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn&#39;t implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>){}

<span class='attribute'>#[<span class='ident'>rustc_on_unimplemented</span> <span class='op'>=</span> <span class='string'>&quot;the type `{Self}` cannot be indexed by `{Idx}`&quot;</span>]</span>
<span class='kw'>trait</span> <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>Idx</span><span class='op'>&gt;</span> { ... }

<span class='ident'>foo</span>(<span class='boolval'>true</span>); <span class='comment'>// `bool` does not implement `Index&lt;u8&gt;`</span></pre>

<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying &quot;the type <code>bool</code> cannot be indexed by <code>u8</code>&quot;.</p>

<p>As you can see, you can specify type parameters in curly braces for substitution
with the actual types (using the regular format string syntax) in a given
situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case,
<code>bool</code>) that we tried to use.</p>

<p>This error appears when the curly braces contain an identifier which doesn&#39;t
match with any of the type parameters or the string <code>Self</code>. This might happen if
you misspelled a type parameter, or if you intended to use literal curly braces.
If it is the latter, escape the curly braces with a second curly brace of the
same type; e.g. a literal <code>{</code> is <code>{{</code></p>
</div>
<div class="error-described error-used"><h2 id="E0273" class="section-header"><a href="#E0273">E0273</a></h2>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn&#39;t implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>){}

<span class='attribute'>#[<span class='ident'>rustc_on_unimplemented</span> <span class='op'>=</span> <span class='string'>&quot;the type `{Self}` cannot be indexed by `{Idx}`&quot;</span>]</span>
<span class='kw'>trait</span> <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>Idx</span><span class='op'>&gt;</span> { ... }

<span class='ident'>foo</span>(<span class='boolval'>true</span>); <span class='comment'>// `bool` does not implement `Index&lt;u8&gt;`</span></pre>

<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying &quot;the type <code>bool</code> cannot be indexed by <code>u8</code>&quot;.</p>

<p>As you can see, you can specify type parameters in curly braces for substitution
with the actual types (using the regular format string syntax) in a given
situation. Furthermore, <code>{Self}</code> will substitute to the type (in this case,
<code>bool</code>) that we tried to use.</p>

<p>This error appears when the curly braces do not contain an identifier. Please
add one of the same name as a type parameter. If you intended to use literal
braces, use <code>{{</code> and <code>}}</code> to escape them.</p>
</div>
<div class="error-described error-used"><h2 id="E0274" class="section-header"><a href="#E0274">E0274</a></h2>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn&#39;t implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>){}

<span class='attribute'>#[<span class='ident'>rustc_on_unimplemented</span> <span class='op'>=</span> <span class='string'>&quot;the type `{Self}` cannot be indexed by `{Idx}`&quot;</span>]</span>
<span class='kw'>trait</span> <span class='ident'>Index</span><span class='op'>&lt;</span><span class='ident'>Idx</span><span class='op'>&gt;</span> { ... }

<span class='ident'>foo</span>(<span class='boolval'>true</span>); <span class='comment'>// `bool` does not implement `Index&lt;u8&gt;`</span></pre>

<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying &quot;the type <code>bool</code> cannot be indexed by <code>u8</code>&quot;.</p>

<p>For this to work, some note must be specified. An empty attribute will not do
anything, please remove the attribute or add some helpful note for users of the
trait.</p>
</div>
<div class="error-described error-used"><h2 id="E0275" class="section-header"><a href="#E0275">E0275</a></h2>
<p>This error occurs when there was a recursive trait requirement that overflowed
before it could be evaluated. Often this means that there is unbounded recursion
in resolving some type bounds.</p>

<p>For example, in the following code</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>T</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>T</span> <span class='kw'>where</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>: <span class='ident'>Foo</span> {}</pre>

<p>to determine if a <code>T</code> is <code>Foo</code>, we need to check if <code>Bar&lt;T&gt;</code> is <code>Foo</code>. However,
to do this check, we need to determine that <code>Bar&lt;Bar&lt;T&gt;&gt;</code> is <code>Foo</code>. To determine
this, we check if <code>Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;</code> is <code>Foo</code>, and so on. This is clearly a
recursive requirement that can&#39;t be resolved directly.</p>

<p>Consider changing your trait bounds so that they&#39;re less self-referential.</p>
</div>
<div class="error-described error-used"><h2 id="E0276" class="section-header"><a href="#E0276">E0276</a></h2>
<p>This error occurs when a bound in an implementation of a trait does not match
the bounds specified in the original trait. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
 <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>);
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>bool</span> {
 <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Copy</span> {}
}</pre>

<p>Here, all types implementing <code>Foo</code> must have a method <code>foo&lt;T&gt;(x: T)</code> which can
take any type <code>T</code>. However, in the <code>impl</code> for <code>bool</code>, we have added an extra
bound that <code>T</code> is <code>Copy</code>, which isn&#39;t compatible with the original trait.</p>

<p>Consider removing the bound from the method or adding the bound to the original
method definition in the trait.</p>
</div>
<div class="error-described error-used"><h2 id="E0277" class="section-header"><a href="#E0277">E0277</a></h2>
<p>You tried to use a type which doesn&#39;t implement some trait in a place which
expected that trait. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// here we declare the Foo trait with a bar method</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='comment'>// we now declare a function which takes an object implementing the Foo trait</span>
<span class='kw'>fn</span> <span class='ident'>some_func</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>foo</span>: <span class='ident'>T</span>) {
    <span class='ident'>foo</span>.<span class='ident'>bar</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// we now call the method with the i32 type, which doesn&#39;t implement</span>
    <span class='comment'>// the Foo trait</span>
    <span class='ident'>some_func</span>(<span class='number'>5i32</span>); <span class='comment'>// error: the trait `Foo` is not implemented for the</span>
                     <span class='comment'>//     type `i32`</span>
}</pre>

<p>In order to fix this error, verify that the type you&#39;re using does implement
the trait. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>fn</span> <span class='ident'>some_func</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>foo</span>: <span class='ident'>T</span>) {
    <span class='ident'>foo</span>.<span class='ident'>bar</span>(); <span class='comment'>// we can now use this method since i32 implements the</span>
               <span class='comment'>// Foo trait</span>
}

<span class='comment'>// we implement the trait on the i32 type</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>some_func</span>(<span class='number'>5i32</span>); <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0278" class="section-header"><a href="#E0278">E0278</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0279" class="section-header"><a href="#E0279">E0279</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0280" class="section-header"><a href="#E0280">E0280</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0281" class="section-header"><a href="#E0281">E0281</a></h2>
<p>You tried to supply a type which doesn&#39;t implement some trait in a location
which expected that trait. This error typically occurs when working with
<code>Fn</code>-based types. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>()<span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>F</span>) { }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// type mismatch: the type ... implements the trait `core::ops::Fn&lt;(_,)&gt;`,</span>
    <span class='comment'>// but the trait `core::ops::Fn&lt;()&gt;` is required (expected (), found tuple</span>
    <span class='comment'>// [E0281]</span>
    <span class='ident'>foo</span>(<span class='op'>|</span><span class='ident'>y</span><span class='op'>|</span> { });
}</pre>

<p>The issue in this case is that <code>foo</code> is defined as accepting a <code>Fn</code> with no
arguments, but the closure we attempted to pass to it requires one argument.</p>
</div>
<div class="error-described error-used"><h2 id="E0282" class="section-header"><a href="#E0282">E0282</a></h2>
<p>This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.</p>

<p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type
parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is
implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet
that reverses the characters of a string:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>();</pre>

<p>In this case, the compiler cannot infer what the type of <code>x</code> should be:
<code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type to
use, you can use a type annotation on <code>x</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>char</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>();</pre>

<p>It is not necessary to annotate the full type. Once the ambiguity is resolved,
the compiler can infer the rest:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>();</pre>

<p>Another way to provide the compiler with enough information, is to specify the
generic type parameter:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>char</span><span class='op'>&gt;&gt;</span>();</pre>

<p>Again, you need not specify the full type if the compiler can infer it:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>.<span class='ident'>chars</span>().<span class='ident'>rev</span>().<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>();</pre>

<p>Apart from a method or function with a generic type parameter, this error can
occur when a type parameter of a struct or trait cannot be inferred. In that
case it is not always possible to use a type annotation, because all candidates
have the same return type. For instance:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='comment'>// Some fields omitted.</span>
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='number'>0</span>
    }

    <span class='kw'>fn</span> <span class='ident'>baz</span>() {
        <span class='kw'>let</span> <span class='ident'>number</span> <span class='op'>=</span> <span class='ident'>Foo</span>::<span class='ident'>bar</span>();
    }
}</pre>

<p>This will fail because the compiler does not know which instance of <code>Foo</code> to
call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0283" class="section-header"><a href="#E0283">E0283</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0284" class="section-header"><a href="#E0284">E0284</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0285" class="section-header"><a href="#E0285">E0285</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0296" class="section-header"><a href="#E0296">E0296</a></h2>
<p>This error indicates that the given recursion limit could not be parsed. Ensure
that the value provided is a positive integer between quotes, like so:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>recursion_limit</span><span class='op'>=</span><span class='string'>&quot;1000&quot;</span>]</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0297" class="section-header"><a href="#E0297">E0297</a></h2>
<p>Patterns used to bind names must be irrefutable. That is, they must guarantee
that a name will be extracted in all cases. Instead of pattern matching the
loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For
instance:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This fails because `None` is not covered.</span>
<span class='kw'>for</span> <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='kw'>in</span> <span class='ident'>xs</span> {
    ...
}

<span class='comment'>// Match inside the loop instead:</span>
<span class='kw'>for</span> <span class='ident'>item</span> <span class='kw'>in</span> <span class='ident'>xs</span> {
    <span class='kw'>match</span> <span class='ident'>item</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> ...
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
    }
}

<span class='comment'>// Or use `if let`:</span>
<span class='kw'>for</span> <span class='ident'>item</span> <span class='kw'>in</span> <span class='ident'>xs</span> {
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>x</span>) <span class='op'>=</span> <span class='ident'>item</span> {
        ...
    }
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0298" class="section-header"><a href="#E0298">E0298</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0299" class="section-header"><a href="#E0299">E0299</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0300" class="section-header"><a href="#E0300">E0300</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0301" class="section-header"><a href="#E0301">E0301</a></h2>
<p>Mutable borrows are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if mutable
borrows were allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(()) {
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { },
    <span class='ident'>option</span> <span class='kw'>if</span> <span class='ident'>option</span>.<span class='ident'>take</span>().<span class='ident'>is_none</span>() <span class='op'>=&gt;</span> { <span class='comment'>/* impossible, option is `Some` */</span> },
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> { } <span class='comment'>// When the previous match failed, the option became `None`.</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0302" class="section-header"><a href="#E0302">E0302</a></h2>
<p>Assignments are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if assignments
were allowed:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(()) {
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { },
    <span class='ident'>option</span> <span class='kw'>if</span> { <span class='ident'>option</span> <span class='op'>=</span> <span class='prelude-val'>None</span>; <span class='boolval'>false</span> } { },
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> { } <span class='comment'>// When the previous match failed, the option became `None`.</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0303" class="section-header"><a href="#E0303">E0303</a></h2>
<p>In certain cases it is possible for sub-bindings to violate memory safety.
Updates to the borrow checker in a future version of Rust may remove this
restriction, but for now patterns must be rewritten without sub-bindings.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Before.</span>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='kw-2'>ref</span> <span class='ident'>op_string_ref</span> <span class='kw-2'>@</span> <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>s</span>) <span class='op'>=&gt;</span> ...
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
}

<span class='comment'>// After.</span>
<span class='kw'>match</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;hi&quot;</span>.<span class='ident'>to_string</span>()) {
    <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>s</span>) <span class='op'>=&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>op_string_ref</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='prelude-val'>Some</span>(<span class='ident'>s</span>);
        ...
    }
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ...
}</pre>

<p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p>

<p>See also <a href="https://github.com/rust-lang/rust/issues/14587">https://github.com/rust-lang/rust/issues/14587</a></p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0304" class="section-header"><a href="#E0304">E0304</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-unused"><h2 id="E0305" class="section-header"><a href="#E0305">E0305</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0306" class="section-header"><a href="#E0306">E0306</a></h2>
<p>In an array literal <code>[x; N]</code>, <code>N</code> is the number of elements in the array. This
number cannot be negative.</p>
</div>
<div class="error-described error-used"><h2 id="E0307" class="section-header"><a href="#E0307">E0307</a></h2>
<p>The length of an array is part of its type. For this reason, this length must be
a compile-time constant.</p>
</div>
<div class="error-described error-used"><h2 id="E0308" class="section-header"><a href="#E0308">E0308</a></h2>
<p>This error occurs when the compiler was unable to infer the concrete type of a
variable. It can occur for several cases, the most common of which is a
mismatch in the expected type that the compiler inferred for a variable&#39;s
initializing expression, and the actual type explicitly assigned to the
variable.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='string'>&quot;I am not a number!&quot;</span>;
<span class='comment'>//     ~~~   ~~~~~~~~~~~~~~~~~~~~</span>
<span class='comment'>//      |             |</span>
<span class='comment'>//      |    initializing expression;</span>
<span class='comment'>//      |    compiler infers type `&amp;str`</span>
<span class='comment'>//      |</span>
<span class='comment'>//    type `i32` assigned to variable `x`</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0309" class="section-header"><a href="#E0309">E0309</a></h2>
<p>Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This won&#39;t compile because T is not constrained, meaning the data</span>
<span class='comment'>// stored in it is not guaranteed to last as long as the reference</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span>
}

<span class='comment'>// This will compile, because it has the constraint on the type parameter</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0310" class="section-header"><a href="#E0310">E0310</a></h2>
<p>Types in type definitions have lifetimes associated with them that represent
how long the data stored within them is guaranteed to be live. This lifetime
must be as long as the data needs to be alive, and missing the constraint that
denotes this will cause this error.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// This won&#39;t compile because T is not constrained to the static lifetime</span>
<span class='comment'>// the reference needs</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>T</span>
}

<span class='comment'>// This will compile, because it has the constraint on the type parameter</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='lifetime'>&#39;static</span><span class='op'>&gt;</span> {
    <span class='ident'>foo</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>T</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0311" class="section-header"><a href="#E0311">E0311</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0312" class="section-header"><a href="#E0312">E0312</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0313" class="section-header"><a href="#E0313">E0313</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0314" class="section-header"><a href="#E0314">E0314</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0315" class="section-header"><a href="#E0315">E0315</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0316" class="section-header"><a href="#E0316">E0316</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0317" class="section-header"><a href="#E0317">E0317</a></h2>
<p>User-defined types or type parameters cannot shadow the primitive types.
This error indicates you tried to define a type, struct or enum with the same
name as an existing primitive type.</p>

<p>See the Types section of the reference for more information about the primitive
types:</p>

<p><a href="https://doc.rust-lang.org/reference.html#types">https://doc.rust-lang.org/reference.html#types</a></p>
</div>
<div class="error-described error-used"><h2 id="E0318" class="section-header"><a href="#E0318">E0318</a></h2>
<p>Default impls for a trait must be located in the same crate where the trait was
defined. For more information see the <a href="https://github%0A.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0320" class="section-header"><a href="#E0320">E0320</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0321" class="section-header"><a href="#E0321">E0321</a></h2>
<p>A cross-crate opt-out trait was implemented on something which wasn&#39;t a struct
or enum type. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>optin_builtin_traits</span>)]</span>

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='op'>!</span><span class='ident'>Sync</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {}

<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Send</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>Foo</span> {
<span class='comment'>// error: cross-crate traits with a default impl, like `core::marker::Send`,</span>
<span class='comment'>//        can only be implemented for a struct/enum type, not</span>
<span class='comment'>//        `&amp;&#39;static Foo`</span></pre>

<p>Only structs and enums are permitted to impl Send, Sync, and other opt-out
trait, and the struct or enum must be local to the current crate. So, for
example, <code>unsafe impl Send for Rc&lt;Foo&gt;</code> is not allowed.</p>
</div>
<div class="error-described error-used"><h2 id="E0322" class="section-header"><a href="#E0322">E0322</a></h2>
<p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a
constant size known at compile-time. This trait is automatically implemented
for types as needed by the compiler, and it is currently disallowed to
explicitly implement it for a type.</p>
</div>
<div class="error-described error-used"><h2 id="E0323" class="section-header"><a href="#E0323">E0323</a></h2>
<p>An associated const was implemented when another trait item was expected.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='comment'>// error: item `N` is an associated const, which doesn&#39;t match its</span>
    <span class='comment'>//        trait `&lt;Bar as Foo&gt;`</span>
}</pre>

<p>Please verify that the associated const wasn&#39;t misspelled and the correct trait
was implemented. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>;
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>type</span> <span class='ident'>N</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span>
}

<span class='comment'>// or:</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span>;
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0324" class="section-header"><a href="#E0324">E0324</a></h2>
<p>A method was implemented when another trait item was expected. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span>;

    <span class='kw'>fn</span> <span class='ident'>M</span>();
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>N</span>() {}
    <span class='comment'>// error: item `N` is an associated method, which doesn&#39;t match its</span>
    <span class='comment'>//        trait `&lt;Bar as Foo&gt;`</span>
}</pre>

<p>To fix this error, please verify that the method name wasn&#39;t misspelled and
verify that you are indeed implementing the correct trait items. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span>;

    <span class='kw'>fn</span> <span class='ident'>M</span>();
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>0</span>;

    <span class='kw'>fn</span> <span class='ident'>M</span>() {} <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0325" class="section-header"><a href="#E0325">E0325</a></h2>
<p>An associated type was implemented when another trait item was expected.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span>;
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>type</span> <span class='ident'>N</span> <span class='op'>=</span> <span class='ident'>u32</span>;
    <span class='comment'>// error: item `N` is an associated type, which doesn&#39;t match its</span>
    <span class='comment'>//        trait `&lt;Bar as Foo&gt;`</span>
}</pre>

<p>Please verify that the associated type name wasn&#39;t misspelled and your
implementation corresponds to the trait definition. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>;
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>type</span> <span class='ident'>N</span> <span class='op'>=</span> <span class='ident'>u32</span>; <span class='comment'>// ok!</span>
}

<span class='comment'>//or:</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span>;
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>const</span> <span class='ident'>N</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0326" class="section-header"><a href="#E0326">E0326</a></h2>
<p>The types of any associated constants in a trait implementation must match the
types in the trait definition. This error indicates that there was a mismatch.</p>

<p>Here&#39;s an example of this error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>bool</span>;
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// error, expected bool, found u32</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0327" class="section-header"><a href="#E0327">E0327</a></h2>
<p>You cannot use associated items other than constant items as patterns. This
includes method items. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>B</span> {}

<span class='kw'>impl</span> <span class='ident'>B</span> {
    <span class='kw'>fn</span> <span class='ident'>bb</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='number'>0</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='number'>0</span> {
        <span class='ident'>B</span>::<span class='ident'>bb</span> <span class='op'>=&gt;</span> {} <span class='comment'>// error: associated items in match patterns must</span>
                    <span class='comment'>// be constants</span>
    }
}</pre>

<p>Please check that you&#39;re not using a method as a pattern. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>B</span> {
    <span class='ident'>ba</span>,
    <span class='ident'>bb</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>B</span>::<span class='ident'>ba</span> {
        <span class='ident'>B</span>::<span class='ident'>bb</span> <span class='op'>=&gt;</span> {} <span class='comment'>// ok!</span>
        _ <span class='op'>=&gt;</span> {}
    }
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0328" class="section-header"><a href="#E0328">E0328</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0329" class="section-header"><a href="#E0329">E0329</a></h2>
<p>An attempt was made to access an associated constant through either a generic
type parameter or <code>Self</code>. This is not supported yet. An example causing this
error is shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>f64</span>;
}

<span class='kw'>struct</span> <span class='ident'>MyStruct</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>MyStruct</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='number'>0f64</span>;
}

<span class='kw'>fn</span> <span class='ident'>get_bar_bad</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='ident'>F</span>::<span class='ident'>BAR</span>
}</pre>

<p>Currently, the value of <code>BAR</code> for a particular type can only be accessed through
a concrete type, as shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>get_bar_good</span>() <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='op'>&lt;</span><span class='ident'>MyStruct</span> <span class='kw'>as</span> <span class='ident'>Foo</span><span class='op'>&gt;</span>::<span class='ident'>BAR</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0364" class="section-header"><a href="#E0364">E0364</a></h2>
<p>Private items cannot be publicly re-exported.  This error indicates that
you attempted to <code>pub use</code> a type or value that was not itself public.</p>

<p>Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>X</span>;</pre>

<p>The solution to this problem is to ensure that the items that you are
re-exporting are themselves marked with <code>pub</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>foo</span>::<span class='ident'>X</span>;</pre>

<p>See the &#39;Use Declarations&#39; section of the reference for more information
on this topic:</p>

<p><a href="https://doc.rust-lang.org/reference.html#use-declarations">https://doc.rust-lang.org/reference.html#use-declarations</a></p>
</div>
<div class="error-described error-used"><h2 id="E0365" class="section-header"><a href="#E0365">E0365</a></h2>
<p>Private modules cannot be publicly re-exported.  This error indicates
that you attempted to <code>pub use</code> a module that was not itself public.</p>

<p>Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>foo</span> <span class='kw'>as</span> <span class='ident'>foo2</span>;
</pre>

<p>The solution to this problem is to ensure that the module that you are
re-exporting is itself marked with <code>pub</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='kw'>pub</span> <span class='kw'>const</span> <span class='ident'>X</span>: <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>1</span>;
}
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='ident'>foo</span> <span class='kw'>as</span> <span class='ident'>foo2</span>;</pre>

<p>See the &#39;Use Declarations&#39; section of the reference for more information
on this topic:</p>

<p><a href="https://doc.rust-lang.org/reference.html#use-declarations">https://doc.rust-lang.org/reference.html#use-declarations</a></p>
</div>
<div class="error-described error-used"><h2 id="E0366" class="section-header"><a href="#E0366">E0366</a></h2>
<p>An attempt was made to implement <code>Drop</code> on a concrete specialization of a
generic type. An example is shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>t</span>: <span class='ident'>T</span>
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}</pre>

<p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of
implementations of a generic type. One workaround for this is to wrap the
generic type, as shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>t</span>: <span class='ident'>T</span>
}

<span class='kw'>struct</span> <span class='ident'>Bar</span> {
    <span class='ident'>t</span>: <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0367" class="section-header"><a href="#E0367">E0367</a></h2>
<p>An attempt was made to implement <code>Drop</code> on a specialization of a generic type.
An example is shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span>{}

<span class='kw'>struct</span> <span class='ident'>MyStruct</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>t</span>: <span class='ident'>T</span>
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>MyStruct</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}</pre>

<p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of
implementations of a generic type. In order for this code to work, <code>MyStruct</code>
must also require that <code>T</code> implements <code>Foo</code>. Alternatively, another option is
to wrap the generic type in another that specializes appropriately:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span>{}

<span class='kw'>struct</span> <span class='ident'>MyStruct</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>t</span>: <span class='ident'>T</span>
}

<span class='kw'>struct</span> <span class='ident'>MyStructWrapper</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span> {
    <span class='ident'>t</span>: <span class='ident'>MyStruct</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>
}

<span class='kw'>impl</span> <span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>MyStructWrapper</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0368" class="section-header"><a href="#E0368">E0368</a></h2>
<p>This error indicates that a binary assignment operator like <code>+=</code> or <code>^=</code> was
applied to a type that doesn&#39;t support it. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12f32</span>; <span class='comment'>// error: binary operation `&lt;&lt;` cannot be applied to</span>
               <span class='comment'>//        type `f32`</span>

<span class='ident'>x</span> <span class='op'>&lt;&lt;=</span> <span class='number'>2</span>;</pre>

<p>To fix this error, please check that this type implements this binary
operation. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12u32</span>; <span class='comment'>// the `u32` type does implement the `ShlAssign` trait</span>

<span class='ident'>x</span> <span class='op'>&lt;&lt;=</span> <span class='number'>2</span>; <span class='comment'>// ok!</span></pre>

<p>It is also possible to overload most operators for your own type by
implementing the <code>[OP]Assign</code> traits from <code>std::ops</code>.</p>

<p>Another problem you might be facing is this: suppose you&#39;ve overloaded the <code>+</code>
operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for
<code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Add</span>;

<span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>u32</span>);

<span class='kw'>impl</span> <span class='ident'>Add</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>Foo</span>;

    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>Foo</span>) <span class='op'>-&gt;</span> <span class='ident'>Foo</span> {
        <span class='ident'>Foo</span>(<span class='self'>self</span>.<span class='number'>0</span> <span class='op'>+</span> <span class='ident'>rhs</span>.<span class='number'>0</span>)
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span>(<span class='number'>5</span>);
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>Foo</span>(<span class='number'>7</span>); <span class='comment'>// error, `+= cannot be applied to the type `Foo`</span>
}</pre>

<p>This is because <code>AddAssign</code> is not automatically implemented, so you need to
manually implement it for your type.</p>
</div>
<div class="error-described error-used"><h2 id="E0369" class="section-header"><a href="#E0369">E0369</a></h2>
<p>A binary operation was attempted on a type which doesn&#39;t support it.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12f32</span>; <span class='comment'>// error: binary operation `&lt;&lt;` cannot be applied to</span>
               <span class='comment'>//        type `f32`</span>

<span class='ident'>x</span> <span class='op'>&lt;&lt;</span> <span class='number'>2</span>;</pre>

<p>To fix this error, please check that this type implements this binary
operation. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12u32</span>; <span class='comment'>// the `u32` type does implement it:</span>
               <span class='comment'>// https://doc.rust-lang.org/stable/std/ops/trait.Shl.html</span>

<span class='ident'>x</span> <span class='op'>&lt;&lt;</span> <span class='number'>2</span>; <span class='comment'>// ok!</span></pre>

<p>It is also possible to overload most operators for your own type by
implementing traits from <code>std::ops</code>.</p>
</div>
<div class="error-described error-used"><h2 id="E0370" class="section-header"><a href="#E0370">E0370</a></h2>
<p>The maximum value of an enum was reached, so it cannot be automatically
set in the next enum value. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>0x7fffffffffffffff</span>,
    <span class='ident'>Y</span> <span class='comment'>// error: enum discriminant overflowed on value after</span>
      <span class='comment'>//        9223372036854775807: i64; set explicitly via</span>
      <span class='comment'>//        Y = -9223372036854775808 if that is desired outcome</span>
}</pre>

<p>To fix this, please set manually the next enum value or put the enum variant
with the maximum value at the end of the enum. Examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>0x7fffffffffffffff</span>,
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>0</span>, <span class='comment'>// ok!</span>
}

<span class='comment'>// or:</span>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Y</span> <span class='op'>=</span> <span class='number'>0</span>, <span class='comment'>// ok!</span>
    <span class='ident'>X</span> <span class='op'>=</span> <span class='number'>0x7fffffffffffffff</span>,
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0371" class="section-header"><a href="#E0371">E0371</a></h2>
<p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a
definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement
<code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by
definition, so it is not useful to do this.</p>

<p>Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> { <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { } }
<span class='kw'>trait</span> <span class='ident'>Bar</span>: <span class='ident'>Foo</span> { }
<span class='kw'>trait</span> <span class='ident'>Baz</span>: <span class='ident'>Bar</span> { }

<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='ident'>Baz</span> { } <span class='comment'>// error, `Baz` implements `Bar` by definition</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Baz</span> { } <span class='comment'>// error, `Baz` implements `Bar` which implements `Foo`</span>
<span class='kw'>impl</span> <span class='ident'>Baz</span> <span class='kw'>for</span> <span class='ident'>Baz</span> { } <span class='comment'>// error, `Baz` (trivially) implements `Baz`</span>
<span class='kw'>impl</span> <span class='ident'>Baz</span> <span class='kw'>for</span> <span class='ident'>Bar</span> { } <span class='comment'>// Note: This is OK</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0372" class="section-header"><a href="#E0372">E0372</a></h2>
<p>Trying to implement a trait for a trait object (as in <code>impl Trait1 for Trait2 { ... }</code>) does not work if the trait is not object-safe. Please see the
<a href="https://github.com/rust-lang/rfcs/pull/255">RFC 255</a> for more details on object safety rules.</p>
</div>
<div class="error-described error-used"><h2 id="E0373" class="section-header"><a href="#E0373">E0373</a></h2>
<p>This error occurs when an attempt is made to use data captured by a closure,
when that data may no longer exist. It&#39;s most commonly seen when attempting to
return a closure:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0u32</span>;
    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='op'>|</span><span class='ident'>y</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>)
}</pre>

<p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures
closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no
longer exists. An attempt to access <code>x</code> within the closure would thus be unsafe.</p>

<p>Another situation where this might be encountered is when spawning threads:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0u32</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>1u32</span>;

    <span class='kw'>let</span> <span class='ident'>thr</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='op'>||</span> {
        <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>
    });
}</pre>

<p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code>
may well have disappeared by the time we try to use them. Even if we call
<code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the
stack frame won&#39;t disappear), we will not succeed: the compiler cannot prove
that this behaviour is safe, and so won&#39;t let us do it.</p>

<p>The solution to this problem is usually to switch to using a <code>move</code> closure.
This approach moves (or copies, where possible) data into the closure, rather
than taking references to it. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Fn</span>(<span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0u32</span>;
    <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='kw'>move</span> <span class='op'>|</span><span class='ident'>y</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>)
}</pre>

<p>Now that the closure has its own copy of the data, there&#39;s no need to worry
about safety.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0374" class="section-header"><a href="#E0374">E0374</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0375" class="section-header"><a href="#E0375">E0375</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0376" class="section-header"><a href="#E0376">E0376</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0377" class="section-header"><a href="#E0377">E0377</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0378" class="section-header"><a href="#E0378">E0378</a></h2>
<p>Method calls that aren&#39;t calls to inherent <code>const</code> methods are disallowed
in statics, constants, and constant functions.</p>

<p>For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>BAZ</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>Foo</span>(<span class='number'>25</span>).<span class='ident'>bar</span>(); <span class='comment'>// error, `bar` isn&#39;t `const`</span>

<span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>i32</span>);

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>const</span> <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
        <span class='self'>self</span>.<span class='ident'>bar</span>() <span class='comment'>// error, `bar` isn&#39;t `const`</span>
    }

    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='self'>self</span>.<span class='number'>0</span> }
}</pre>

<p>For more information about <code>const fn</code>&#39;s, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md">RFC 911</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0379" class="section-header"><a href="#E0379">E0379</a></h2>
<p>Trait methods cannot be declared <code>const</code> by design. For more information, see
<a href="https://github.com/rust-lang/rfcs/pull/911">RFC 911</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0380" class="section-header"><a href="#E0380">E0380</a></h2>
<p>Default impls are only allowed for traits with no methods or associated items.
For more information see the <a href="https://github.com/rust%0A-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
</div>
<div class="error-described error-used"><h2 id="E0381" class="section-header"><a href="#E0381">E0381</a></h2>
<p>It is not allowed to use or capture an uninitialized variable. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// error, use of possibly uninitialized variable</span></pre>

<p>To fix this, ensure that any declared variables are initialized before being
used.</p>
</div>
<div class="error-described error-used"><h2 id="E0382" class="section-header"><a href="#E0382">E0382</a></h2>
<p>This error occurs when an attempt is made to use a variable after its contents
have been moved elsewhere. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>MyStruct</span> { <span class='ident'>s</span>: <span class='ident'>u32</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>MyStruct</span>{ <span class='ident'>s</span>: <span class='number'>5u32</span> };
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>;
    <span class='ident'>x</span>.<span class='ident'>s</span> <span class='op'>=</span> <span class='number'>6</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>.<span class='ident'>s</span>);
}</pre>

<p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out
of <code>x</code> when we set <code>y</code>. This is fundamental to Rust&#39;s ownership system: outside
of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p>

<p>If we own the type, the easiest way to address this problem is to implement
<code>Copy</code> and <code>Clone</code> on it, as shown below. This allows <code>y</code> to copy the
information in <code>x</code>, while leaving the original version owned by <code>x</code>. Subsequent
changes to <code>x</code> will not be reflected when accessing <code>y</code>.</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>, <span class='ident'>Clone</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>MyStruct</span> { <span class='ident'>s</span>: <span class='ident'>u32</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>MyStruct</span>{ <span class='ident'>s</span>: <span class='number'>5u32</span> };
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>;
    <span class='ident'>x</span>.<span class='ident'>s</span> <span class='op'>=</span> <span class='number'>6</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>.<span class='ident'>s</span>);
}</pre>

<p>Alternatively, if we don&#39;t control the struct&#39;s definition, or mutable shared
ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='kw'>struct</span> <span class='ident'>MyStruct</span> { <span class='ident'>s</span>: <span class='ident'>u32</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='ident'>MyStruct</span>{ <span class='ident'>s</span>: <span class='number'>5u32</span> }));
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>x</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>s</span> <span class='op'>=</span> <span class='number'>6</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>.<span class='ident'>borrow</span>.<span class='ident'>s</span>);
}</pre>

<p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference
count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring
that at most one writer or multiple readers can access the data at any one time.</p>

<p>If you wish to learn more about ownership in Rust, start with the chapter in the
Book:</p>

<p><a href="https://doc.rust-lang.org/book/ownership.html">https://doc.rust-lang.org/book/ownership.html</a></p>
</div>
<div class="error-described error-used"><h2 id="E0383" class="section-header"><a href="#E0383">E0383</a></h2>
<p>This error occurs when an attempt is made to partially reinitialize a
structure that is currently uninitialized.</p>

<p>For example, this can happen when a drop has taken place:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='number'>1</span> };
<span class='ident'>drop</span>(<span class='ident'>x</span>); <span class='comment'>// `x` is now uninitialized</span>
<span class='ident'>x</span>.<span class='ident'>a</span> <span class='op'>=</span> <span class='number'>2</span>; <span class='comment'>// error, partial reinitialization of uninitialized structure `t`</span></pre>

<p>This error can be fixed by fully reinitializing the structure in question:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='number'>1</span> };
<span class='ident'>drop</span>(<span class='ident'>x</span>);
<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='number'>2</span> };</pre>
</div>
<div class="error-described error-used"><h2 id="E0384" class="section-header"><a href="#E0384">E0384</a></h2>
<p>This error occurs when an attempt is made to reassign an immutable variable.
For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>(){
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>;
    <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// error, reassignment of immutable variable</span>
}</pre>

<p>By default, variables in Rust are immutable. To fix this error, add the keyword
<code>mut</code> after the keyword <code>let</code> when declaring the variable. For example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>(){
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>;
    <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0385" class="section-header"><a href="#E0385">E0385</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0386" class="section-header"><a href="#E0386">E0386</a></h2>
<p>This error occurs when an attempt is made to mutate the target of a mutable
reference stored inside an immutable container.</p>

<p>For example, this can happen when storing a <code>&amp;mut</code> inside an immutable <code>Box</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>i64</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>Box</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>);
<span class='op'>*</span><span class='op'>*</span><span class='ident'>y</span> <span class='op'>=</span> <span class='number'>2</span>; <span class='comment'>// error, cannot assign to data in an immutable container</span></pre>

<p>This error can be fixed by making the container mutable:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>i64</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span>: <span class='ident'>Box</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>);
<span class='op'>*</span><span class='op'>*</span><span class='ident'>y</span> <span class='op'>=</span> <span class='number'>2</span>;</pre>

<p>It can also be fixed by using a type with interior mutability, such as <code>Cell</code> or
<code>RefCell</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i64</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Cell</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='ident'>x</span>));
<span class='ident'>y</span>.<span class='ident'>set</span>(<span class='number'>2</span>);</pre>
</div>
<div class="error-described error-used"><h2 id="E0387" class="section-header"><a href="#E0387">E0387</a></h2>
<p>This error occurs when an attempt is made to mutate or mutably reference data
that a closure has captured immutably. Examples of this error are shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Accepts a function or a closure that captures its environment immutably.</span>
<span class='comment'>// Closures passed to foo will not be able to mutate their closed-over state.</span>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>Fn</span>()<span class='op'>&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) { }

<span class='comment'>// Attempts to mutate closed-over data.  Error message reads:</span>
<span class='comment'>// `cannot assign to data in a captured outer variable...`</span>
<span class='kw'>fn</span> <span class='ident'>mutable</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0u32</span>;
    <span class='ident'>foo</span>(<span class='op'>||</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>2</span>);
}

<span class='comment'>// Attempts to take a mutable reference to closed-over data.  Error message</span>
<span class='comment'>// reads: `cannot borrow data mutably in a captured outer variable...`</span>
<span class='kw'>fn</span> <span class='ident'>mut_addr</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0u32</span>;
    <span class='ident'>foo</span>(<span class='op'>||</span> { <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>; });
}</pre>

<p>The problem here is that foo is defined as accepting a parameter of type <code>Fn</code>.
Closures passed into foo will thus be inferred to be of type <code>Fn</code>, meaning that
they capture their context immutably.</p>

<p>If the definition of <code>foo</code> is under your control, the simplest solution is to
capture the data mutably. This can be done by defining <code>foo</code> to take FnMut
rather than Fn:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>FnMut</span>()<span class='op'>&gt;</span>(<span class='ident'>f</span>: <span class='ident'>F</span>) { }</pre>

<p>Alternatively, we can consider using the <code>Cell</code> and <code>RefCell</code> types to achieve
interior mutability through a shared reference. Our example&#39;s <code>mutable</code> function
could be redefined as below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>Cell</span>;

<span class='kw'>fn</span> <span class='ident'>mutable</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='number'>0u32</span>);
    <span class='ident'>foo</span>(<span class='op'>||</span> <span class='ident'>x</span>.<span class='ident'>set</span>(<span class='number'>2</span>));
}</pre>

<p>You can read more about cell types in the API documentation:</p>

<p><a href="https://doc.rust-lang.org/std/cell/">https://doc.rust-lang.org/std/cell/</a></p>
</div>
<div class="error-undescribed error-used"><h2 id="E0388" class="section-header"><a href="#E0388">E0388</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0389" class="section-header"><a href="#E0389">E0389</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0390" class="section-header"><a href="#E0390">E0390</a></h2>
<p>You tried to implement methods for a primitive type. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>
}

<span class='kw'>impl</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>Foo</span> {}
<span class='comment'>// error: only a single inherent implementation marked with</span>
<span class='comment'>//        `#[lang = &quot;mut_ptr&quot;]` is allowed for the `*mut T` primitive</span></pre>

<p>This isn&#39;t allowed, but using a trait to implement a method is a good solution.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>
}

<span class='kw'>trait</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>();
}

<span class='kw'>impl</span> <span class='ident'>Bar</span> <span class='kw'>for</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() {} <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0391" class="section-header"><a href="#E0391">E0391</a></h2>
<p>This error indicates that some types or traits depend on each other
and therefore cannot be constructed.</p>

<p>The following example contains a circular dependency between two traits:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>FirstTrait</span> : <span class='ident'>SecondTrait</span> {

}

<span class='kw'>trait</span> <span class='ident'>SecondTrait</span> : <span class='ident'>FirstTrait</span> {

}</pre>
</div>
<div class="error-described error-used"><h2 id="E0392" class="section-header"><a href="#E0392">E0392</a></h2>
<p>This error indicates that a type or lifetime parameter has been declared
but not actually used.  Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Bar</span>
}</pre>

<p>If the type parameter was included by mistake, this error can be fixed
by simply removing the type parameter, as shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>
}</pre>

<p>Alternatively, if the type parameter was intentionally inserted, it must be
used. A simple fix is shown below:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Bar</span>(<span class='ident'>T</span>)
}</pre>

<p>This error may also commonly be found when working with unsafe code. For
example, when using raw pointers one may wish to specify the lifetime for
which the pointed-at data is valid. An initial attempt (below) causes this
error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>T</span>
}</pre>

<p>We want to express the constraint that Foo should not outlive <code>&#39;a</code>, because
the data pointed to by <code>T</code> is only valid for that lifetime. The problem is
that there are no actual uses of <code>&#39;a</code>. It&#39;s possible to work around this
by adding a PhantomData type to the struct, using it to tell the compiler
to act as if the struct contained a borrowed reference <code>&amp;&#39;a T</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>marker</span>::<span class='ident'>PhantomData</span>;

<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>T</span>,
    <span class='ident'>phantom</span>: <span class='ident'>PhantomData</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span><span class='op'>&gt;</span>
}</pre>

<p>PhantomData can also be used to express information about unused type
parameters. You can read more about it in the API documentation:</p>

<p><a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">https://doc.rust-lang.org/std/marker/struct.PhantomData.html</a></p>
</div>
<div class="error-undescribed error-used"><h2 id="E0393" class="section-header"><a href="#E0393">E0393</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0394" class="section-header"><a href="#E0394">E0394</a></h2>
<p>From <a href="https://github.com/rust-lang/rfcs/pull/246">RFC 246</a>:</p>

<blockquote>
<p>It is invalid for a static to reference another static by value. It is
required that all references be borrowed.</p>
</blockquote>
</div>
<div class="error-described error-used"><h2 id="E0395" class="section-header"><a href="#E0395">E0395</a></h2>
<p>The value assigned to a constant expression must be known at compile time,
which is not the case when comparing raw pointers. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>static</span> <span class='ident'>bar</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>43</span>;

<span class='kw'>static</span> <span class='ident'>baz</span>: <span class='ident'>bool</span> <span class='op'>=</span> { (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) <span class='op'>==</span> (<span class='kw-2'>&amp;</span><span class='ident'>bar</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) };
<span class='comment'>// error: raw pointers cannot be compared in statics!</span></pre>

<p>Please check that the result of the comparison can be determined at compile time
or isn&#39;t assigned to a constant expression. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>static</span> <span class='ident'>bar</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>43</span>;

<span class='kw'>let</span> <span class='ident'>baz</span>: <span class='ident'>bool</span> <span class='op'>=</span> { (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) <span class='op'>==</span> (<span class='kw-2'>&amp;</span><span class='ident'>bar</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>) };
<span class='comment'>// baz isn&#39;t a constant expression so it&#39;s ok</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0396" class="section-header"><a href="#E0396">E0396</a></h2>
<p>The value assigned to a constant expression must be known at compile time,
which is not the case when dereferencing raw pointers. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>const</span> <span class='ident'>baz</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span> <span class='op'>=</span> (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>);

<span class='kw'>const</span> <span class='ident'>deref</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>baz</span>;
<span class='comment'>// error: raw pointers cannot be dereferenced in constants</span></pre>

<p>To fix this error, please do not assign this value to a constant expression.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>foo</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>42</span>;
<span class='kw'>const</span> <span class='ident'>baz</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span> <span class='op'>=</span> (<span class='kw-2'>&amp;</span><span class='ident'>foo</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>i32</span>);

<span class='kw'>unsafe</span> { <span class='kw'>let</span> <span class='ident'>deref</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>baz</span>; }
<span class='comment'>// baz isn&#39;t a constant expression so it&#39;s ok</span></pre>

<p>You&#39;ll also note that this assignment must be done in an unsafe block!</p>
</div>
<div class="error-described error-used"><h2 id="E0397" class="section-header"><a href="#E0397">E0397</a></h2>
<p>It is not allowed for a mutable static to allocate or have destructors. For
example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// error: mutable statics are not allowed to have boxes</span>
<span class='kw'>static</span> <span class='kw-2'>mut</span> <span class='ident'>FOO</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='comment'>// error: mutable statics are not allowed to have destructors</span>
<span class='kw'>static</span> <span class='kw-2'>mut</span> <span class='ident'>BAR</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;</pre>
</div>
<div class="error-described error-unused"><h2 id="E0398" class="section-header"><a href="#E0398">E0398</a></h2>
<p>In Rust 1.3, the default object lifetime bounds are expected to
change, as described in RFC #1156 <a href="https://github.com/rust-lang/rfcs/pull/1156">1</a>. You are getting a warning
because the compiler thinks it is possible that this change will cause
a compilation error in your code. It is possible, though unlikely,
that this is a false alarm.</p>

<p>The heart of the change is that where <code>&amp;&#39;a Box&lt;SomeTrait&gt;</code> used to
default to <code>&amp;&#39;a Box&lt;SomeTrait+&#39;a&gt;</code>, it now defaults to <code>&amp;&#39;a Box&lt;SomeTrait+&#39;static&gt;</code> (here, <code>SomeTrait</code> is the name of some trait
type). Note that the only types which are affected are references to
boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or <code>&amp;[Box&lt;SomeTrait&gt;]</code>.  More common
types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code> are unaffected.</p>

<p>To silence this warning, edit your code to use an explicit bound.
Most of the time, this means that you will want to change the
signature of a function that you are calling. For example, if
the error is reported on a call like <code>foo(x)</code>, and <code>foo</code> is
defined as follows:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>arg</span>: <span class='kw-2'>&amp;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>SomeTrait</span><span class='op'>&gt;</span>) { ... }</pre>

<p>you might change it to:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>arg</span>: <span class='kw-2'>&amp;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>SomeTrait</span><span class='op'>+</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>) { ... }</pre>

<p>This explicitly states that you expect the trait object <code>SomeTrait</code> to
contain references (with a maximum lifetime of <code>&#39;a</code>).</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0399" class="section-header"><a href="#E0399">E0399</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0400" class="section-header"><a href="#E0400">E0400</a></h2>
<p>A user-defined dereference was attempted in an invalid context. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Deref</span>;

<span class='kw'>struct</span> <span class='ident'>A</span>;

<span class='kw'>impl</span> <span class='ident'>Deref</span> <span class='kw'>for</span> <span class='ident'>A</span> {
    <span class='kw'>type</span> <span class='ident'>Target</span> <span class='op'>=</span> <span class='ident'>str</span>;

    <span class='kw'>fn</span> <span class='ident'>deref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>)<span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { <span class='string'>&quot;foo&quot;</span> }
}

<span class='kw'>const</span> <span class='ident'>S</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>A</span>;
<span class='comment'>// error: user-defined dereference operators are not allowed in constants</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='ident'>S</span>;
}</pre>

<p>You cannot directly use a dereference operation whilst initializing a constant
or a static. To fix this error, restructure your code to avoid this dereference,
perhaps moving it inline:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Deref</span>;

<span class='kw'>struct</span> <span class='ident'>A</span>;

<span class='kw'>impl</span> <span class='ident'>Deref</span> <span class='kw'>for</span> <span class='ident'>A</span> {
    <span class='kw'>type</span> <span class='ident'>Target</span> <span class='op'>=</span> <span class='ident'>str</span>;

    <span class='kw'>fn</span> <span class='ident'>deref</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>)<span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> { <span class='string'>&quot;foo&quot;</span> }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>foo</span> : <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>A</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0401" class="section-header"><a href="#E0401">E0401</a></h2>
<p>Inner functions do not inherit type parameters from the functions they are
embedded in. For example, this will not compile:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>y</span>: <span class='ident'>T</span>) { <span class='comment'>// T is defined in the &quot;outer&quot; function</span>
        <span class='comment'>// ..</span>
    }
    <span class='ident'>bar</span>(<span class='ident'>x</span>);
}</pre>

<p>Functions inside functions are basically just like top-level functions, except
that they can only be called from the function they are in.</p>

<p>There are a couple of solutions for this.</p>

<p>You can use a closure:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='kw'>let</span> <span class='ident'>bar</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>y</span>: <span class='ident'>T</span><span class='op'>|</span> { <span class='comment'>// explicit type annotation may not be necessary</span>
        <span class='comment'>// ..</span>
    }
    <span class='ident'>bar</span>(<span class='ident'>x</span>);
}</pre>

<p>or copy over the parameters:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>y</span>: <span class='ident'>T</span>) {
        <span class='comment'>// ..</span>
    }
    <span class='ident'>bar</span>(<span class='ident'>x</span>);
}</pre>

<p>Be sure to copy over any bounds as well:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Copy</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Copy</span><span class='op'>&gt;</span>(<span class='ident'>y</span>: <span class='ident'>T</span>) {
        <span class='comment'>// ..</span>
    }
    <span class='ident'>bar</span>(<span class='ident'>x</span>);
}</pre>

<p>This may require additional type hints in the function body.</p>

<p>In case the function is in an <code>impl</code>, defining a private helper function might
be easier:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>x</span>: <span class='ident'>T</span>) {
        <span class='self'>self</span>.<span class='ident'>bar</span>(<span class='ident'>x</span>);
    }
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>y</span>: <span class='ident'>T</span>) {
        <span class='comment'>// ..</span>
    }
}</pre>

<p>For default impls in traits, the private helper solution won&#39;t work, however
closures or copying the parameters should still work.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0402" class="section-header"><a href="#E0402">E0402</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0403" class="section-header"><a href="#E0403">E0403</a></h2>
<p>Some type parameters have the same name. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='ident'>T</span>, <span class='ident'>u</span>: <span class='ident'>T</span>) {} <span class='comment'>// error: the name `T` is already used for a type</span>
                            <span class='comment'>//        parameter in this type parameter list</span></pre>

<p>Please verify that none of the type parameterss are misspelled, and rename any
clashing parameters. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>Y</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='ident'>T</span>, <span class='ident'>u</span>: <span class='ident'>Y</span>) {} <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0404" class="section-header"><a href="#E0404">E0404</a></h2>
<p>You tried to implement something which was not a trait on an object. Example of
erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {} <span class='comment'>// error: `Foo` is not a trait</span></pre>

<p>Please verify that you didn&#39;t misspell the trait&#39;s name or otherwise use the
wrong identifier. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='comment'>// some functions</span>
}
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> { <span class='comment'>// ok!</span>
    <span class='comment'>// functions implementation</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0405" class="section-header"><a href="#E0405">E0405</a></h2>
<p>An unknown trait was implemented. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>SomeTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {} <span class='comment'>// error: use of undeclared trait name `SomeTrait`</span></pre>

<p>Please verify that the name of the trait wasn&#39;t misspelled and ensure that it
was imported. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// solution 1:</span>
<span class='kw'>use</span> <span class='ident'>some_file</span>::<span class='ident'>SomeTrait</span>;

<span class='comment'>// solution 2:</span>
<span class='kw'>trait</span> <span class='ident'>SomeTrait</span> {
    <span class='comment'>// some functions</span>
}

<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>SomeTrait</span> <span class='kw'>for</span> <span class='ident'>Foo</span> { <span class='comment'>// ok!</span>
    <span class='comment'>// implements functions</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0406" class="section-header"><a href="#E0406">E0406</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0407" class="section-header"><a href="#E0407">E0407</a></h2>
<p>A definition of a method not in the implemented trait was given in a trait
implementation. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>a</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>a</span>() {}
    <span class='kw'>fn</span> <span class='ident'>b</span>() {} <span class='comment'>// error: method `b` is not a member of trait `Foo`</span>
}</pre>

<p>Please verify you didn&#39;t misspell the method name and you used the correct
trait. First example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>a</span>();
    <span class='kw'>fn</span> <span class='ident'>b</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>a</span>() {}
    <span class='kw'>fn</span> <span class='ident'>b</span>() {} <span class='comment'>// ok!</span>
}</pre>

<p>Second example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>a</span>();
}

<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>a</span>() {}
}

<span class='kw'>impl</span> <span class='ident'>Bar</span> {
    <span class='kw'>fn</span> <span class='ident'>b</span>() {}
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0408" class="section-header"><a href="#E0408">E0408</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0409" class="section-header"><a href="#E0409">E0409</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0410" class="section-header"><a href="#E0410">E0410</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0411" class="section-header"><a href="#E0411">E0411</a></h2>
<p>The <code>Self</code> keyword was used outside an impl or a trait. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='op'>&lt;</span><span class='kw'>Self</span><span class='op'>&gt;</span>::<span class='ident'>foo</span>; <span class='comment'>// error: use of `Self` outside of an impl or trait</span></pre>

<p>The <code>Self</code> keyword represents the current type, which explains why it
can only be used inside an impl or a trait. It gives access to the
associated items of a type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>trait</span> <span class='ident'>Baz</span> : <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Bar</span>; <span class='comment'>// like this</span>
}</pre>

<p>However, be careful when two types has a common associated type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>trait</span> <span class='ident'>Foo2</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span>;
}

<span class='kw'>trait</span> <span class='ident'>Baz</span> : <span class='ident'>Foo</span> <span class='op'>+</span> <span class='ident'>Foo2</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='ident'>Self</span>::<span class='ident'>Bar</span>;
    <span class='comment'>// error: ambiguous associated type `Bar` in bounds of `Self`</span>
}</pre>

<p>This problem can be solved by specifying from which trait we want
to use the <code>Bar</code> type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Baz</span> : <span class='ident'>Foo</span> <span class='op'>+</span> <span class='ident'>Foo2</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='op'>&lt;</span><span class='kw'>Self</span> <span class='kw'>as</span> <span class='ident'>Foo</span><span class='op'>&gt;</span>::<span class='ident'>Bar</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0412" class="section-header"><a href="#E0412">E0412</a></h2>
<p>An undeclared type name was used. Example of erroneous codes:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Something</span> {} <span class='comment'>// error: use of undeclared type name `Something`</span>
<span class='comment'>// or:</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>N</span>); <span class='comment'>// error: use of undeclared type name `N`</span>
}
<span class='comment'>// or:</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {} <span class='comment'>// error: use of undeclared type name `T`</span></pre>

<p>To fix this error, please verify you didn&#39;t misspell the type name,
you did declare it or imported it into the scope. Examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Something</span>;

<span class='kw'>impl</span> <span class='ident'>Something</span> {} <span class='comment'>// ok!</span>
<span class='comment'>// or:</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>type</span> <span class='ident'>N</span>;

    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='ident'>Self</span>::<span class='ident'>N</span>); <span class='comment'>// ok!</span>
}
<span class='comment'>//or:</span>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {} <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0413" class="section-header"><a href="#E0413">E0413</a></h2>
<p>A declaration shadows an enum variant or unit-like struct in scope.
Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>let</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='number'>12i32</span>; <span class='comment'>// error: declaration of `Foo` shadows an enum variant or</span>
                 <span class='comment'>//        unit-like struct in scope</span></pre>

<p>To fix this error, rename the variable such that it doesn&#39;t shadow any enum
variable or structure in scope. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>12i32</span>; <span class='comment'>// ok!</span></pre>

<p>Or:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>FooStruct</span>;

<span class='kw'>let</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='number'>12i32</span>; <span class='comment'>// ok!</span></pre>

<p>The goal here is to avoid a conflict of names.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0414" class="section-header"><a href="#E0414">E0414</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0415" class="section-header"><a href="#E0415">E0415</a></h2>
<p>More than one function parameter have the same name. Example of erroneous
code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>f</span>: <span class='ident'>i32</span>, <span class='ident'>f</span>: <span class='ident'>i32</span>) {} <span class='comment'>// error: identifier `f` is bound more than</span>
                          <span class='comment'>//        once in this parameter list</span></pre>

<p>Please verify you didn&#39;t misspell parameters&#39; name. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>f</span>: <span class='ident'>i32</span>, <span class='ident'>g</span>: <span class='ident'>i32</span>) {} <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0416" class="section-header"><a href="#E0416">E0416</a></h2>
<p>An identifier is bound more than once in a pattern. Example of erroneous
code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> (<span class='number'>1</span>, <span class='number'>2</span>) {
    (<span class='ident'>x</span>, <span class='ident'>x</span>) <span class='op'>=&gt;</span> {} <span class='comment'>// error: identifier `x` is bound more than once in the</span>
                 <span class='comment'>//        same pattern</span>
}</pre>

<p>Please verify you didn&#39;t misspell identifiers&#39; name. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> (<span class='number'>1</span>, <span class='number'>2</span>) {
    (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=&gt;</span> {} <span class='comment'>// ok!</span>
}</pre>

<p>Or maybe did you mean to unify? Consider using a guard:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> (<span class='ident'>A</span>, <span class='ident'>B</span>, <span class='ident'>C</span>) {
    (<span class='ident'>x</span>, <span class='ident'>x2</span>, <span class='ident'>see</span>) <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>x2</span> <span class='op'>=&gt;</span> { <span class='comment'>/* A and B are equal, do one thing */</span> }
    (<span class='ident'>y</span>, <span class='ident'>z</span>, <span class='ident'>see</span>) <span class='op'>=&gt;</span> { <span class='comment'>/* A and B unequal; do another thing */</span> }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0417" class="section-header"><a href="#E0417">E0417</a></h2>
<p>A static variable was referenced in a pattern. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>static</span> <span class='ident'>FOO</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>;

<span class='kw'>match</span> <span class='number'>0</span> {
    <span class='ident'>FOO</span> <span class='op'>=&gt;</span> {} <span class='comment'>// error: static variables cannot be referenced in a</span>
              <span class='comment'>//        pattern, use a `const` instead</span>
    _ <span class='op'>=&gt;</span> {}
}</pre>

<p>The compiler needs to know the value of the pattern at compile time;
compile-time patterns can defined via const or enum items. Please verify
that the identifier is spelled correctly, and if so, use a const instead
of static to define it. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0</span>;

<span class='kw'>match</span> <span class='number'>0</span> {
    <span class='ident'>FOO</span> <span class='op'>=&gt;</span> {} <span class='comment'>// ok!</span>
    _ <span class='op'>=&gt;</span> {}
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0418" class="section-header"><a href="#E0418">E0418</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0419" class="section-header"><a href="#E0419">E0419</a></h2>
<p>An unknown enum variant, struct or const was used. Example of
erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='number'>0</span> {
    <span class='ident'>Something</span>::<span class='ident'>Foo</span> <span class='op'>=&gt;</span> {} <span class='comment'>// error: unresolved enum variant, struct</span>
                         <span class='comment'>//        or const `Foo`</span>
}</pre>

<p>Please verify you didn&#39;t misspell it and the enum variant, struct or const has
been declared and imported into scope. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Something</span> {
    <span class='ident'>Foo</span>,
    <span class='ident'>NotFoo</span>,
}

<span class='kw'>match</span> <span class='ident'>Something</span>::<span class='ident'>NotFoo</span> {
    <span class='ident'>Something</span>::<span class='ident'>Foo</span> <span class='op'>=&gt;</span> {} <span class='comment'>// ok!</span>
    _ <span class='op'>=&gt;</span> {}
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0420" class="section-header"><a href="#E0420">E0420</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0421" class="section-header"><a href="#E0421">E0421</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0422" class="section-header"><a href="#E0422">E0422</a></h2>
<p>You are trying to use an identifier that is either undefined or not a
struct. For instance:
<code>fn main () { let x = Foo { x: 1, y: 2 }; }</code></p>

<p>In this case, <code>Foo</code> is undefined, so it inherently isn&#39;t anything, and
definitely not a struct.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span> () {
    <span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>1</span>;
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>foo</span> { <span class='ident'>x</span>: <span class='number'>1</span>, <span class='ident'>y</span>: <span class='number'>2</span> };
}</pre>

<p>In this case, <code>foo</code> is defined, but is not a struct, so Rust can&#39;t use
it as one.</p>
</div>
<div class="error-described error-used"><h2 id="E0423" class="section-header"><a href="#E0423">E0423</a></h2>
<p>A <code>struct</code> variant name was used like a function name. Example of
erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='ident'>bool</span>};

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span>();
<span class='comment'>// error: `Foo` is a struct variant name, but this expression uses</span>
<span class='comment'>//        it like a function name</span></pre>

<p>Please verify you didn&#39;t misspell the name of what you actually wanted
to use here. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>Foo</span>() <span class='op'>-&gt;</span> <span class='ident'>u32</span> { <span class='number'>0</span> }

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Foo</span>(); <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0424" class="section-header"><a href="#E0424">E0424</a></h2>
<p>The <code>self</code> keyword was used in a static method. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='self'>self</span>) {}

    <span class='kw'>fn</span> <span class='ident'>foo</span>() {
        <span class='self'>self</span>.<span class='ident'>bar</span>(); <span class='comment'>// error: `self` is not available in a static method.</span>
    }
}</pre>

<p>Please check if the method&#39;s argument list should have contained <code>self</code>,
<code>&amp;self</code>, or <code>&amp;mut self</code> (in case you didn&#39;t want to create a static
method), and add it if so. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='self'>self</span>) {}

    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='self'>self</span>) {
        <span class='self'>self</span>.<span class='ident'>bar</span>(); <span class='comment'>// ok!</span>
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0425" class="section-header"><a href="#E0425">E0425</a></h2>
<p>An unresolved name was used. Example of erroneous codes:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>something_that_doesnt_exist</span>::<span class='ident'>foo</span>;
<span class='comment'>// error: unresolved name `something_that_doesnt_exist::foo`</span>

<span class='comment'>// or:</span>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>() {
        <span class='kw'>Self</span>; <span class='comment'>// error: unresolved name `Self`</span>
    }
}

<span class='comment'>// or:</span>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>unknown_variable</span>;  <span class='comment'>// error: unresolved name `unknown_variable`</span></pre>

<p>Please verify that the name wasn&#39;t misspelled and ensure that the
identifier being referred to is valid for the given situation. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>something_that_does_exist</span> {
    <span class='ident'>foo</span>
}

<span class='comment'>// or:</span>
<span class='kw'>mod</span> <span class='ident'>something_that_does_exist</span> {
    <span class='kw'>pub</span> <span class='kw'>static</span> <span class='ident'>foo</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>0i32</span>;
}

<span class='ident'>something_that_does_exist</span>::<span class='ident'>foo</span>; <span class='comment'>// ok!</span>

<span class='comment'>// or:</span>
<span class='kw'>let</span> <span class='ident'>unknown_variable</span> <span class='op'>=</span> <span class='number'>12u32</span>;
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>unknown_variable</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0426" class="section-header"><a href="#E0426">E0426</a></h2>
<p>An undeclared label was used. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>loop</span> {
    <span class='kw'>break</span> <span class='lifetime'>&#39;a</span>; <span class='comment'>// error: use of undeclared label `&#39;a`</span>
}</pre>

<p>Please verify you spelt or declare the label correctly. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='lifetime'>&#39;a</span>: <span class='kw'>loop</span> {
    <span class='kw'>break</span> <span class='lifetime'>&#39;a</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0427" class="section-header"><a href="#E0427">E0427</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0428" class="section-header"><a href="#E0428">E0428</a></h2>
<p>A type or module has been defined more than once. Example of erroneous
code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;
<span class='kw'>struct</span> <span class='ident'>Bar</span>; <span class='comment'>// error: duplicate definition of value `Bar`</span></pre>

<p>Please verify you didn&#39;t misspell the type/module&#39;s name or remove/rename the
duplicated one. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;
<span class='kw'>struct</span> <span class='ident'>Bar2</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0429" class="section-header"><a href="#E0429">E0429</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0430" class="section-header"><a href="#E0430">E0430</a></h2>
<p>The <code>self</code> import appears more than once in the list. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>something</span>::{<span class='self'>self</span>, <span class='self'>self</span>}; <span class='comment'>// error: `self` import can only appear once in</span>
                             <span class='comment'>//        the list</span></pre>

<p>Please verify you didn&#39;t misspell the import name or remove the duplicated
<code>self</code> import. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>something</span>::<span class='self'>self</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0431" class="section-header"><a href="#E0431">E0431</a></h2>
<p><code>self</code> import was made. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> {<span class='self'>self</span>}; <span class='comment'>// error: `self` import can only appear in an import list with a</span>
            <span class='comment'>//        non-empty prefix</span></pre>

<p>You cannot import the current module into itself, please remove this import
or verify you didn&#39;t misspell it.</p>
</div>
<div class="error-described error-used"><h2 id="E0432" class="section-header"><a href="#E0432">E0432</a></h2>
<p>An import was unresolved. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>something</span>::<span class='ident'>Foo</span>; <span class='comment'>// error: unresolved import `something::Foo`.</span></pre>

<p>Please verify you didn&#39;t misspell the import name or the import does exist
in the module from where you tried to import it. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>something</span>::<span class='ident'>Foo</span>; <span class='comment'>// ok!</span>

<span class='kw'>mod</span> <span class='ident'>something</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span>;
}</pre>

<p>Or, if you tried to use a module from an external crate, you may have missed
the <code>extern crate</code> declaration:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>homura</span>; <span class='comment'>// Required to use the `homura` crate</span>

<span class='kw'>use</span> <span class='ident'>homura</span>::<span class='ident'>Madoka</span>;</pre>
</div>
<div class="error-described error-used"><h2 id="E0433" class="section-header"><a href="#E0433">E0433</a></h2>
<p>Invalid import. Example of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>something_which_doesnt_exist</span>;
<span class='comment'>// error: unresolved import `something_which_doesnt_exist`</span></pre>

<p>Please verify you didn&#39;t misspell the import&#39;s name.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0434" class="section-header"><a href="#E0434">E0434</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0435" class="section-header"><a href="#E0435">E0435</a></h2>
<p>A non-constant value was used to initialise a constant. Example of erroneous
code:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>42u32</span>;
<span class='kw'>const</span> <span class='ident'>FOO</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>foo</span>; <span class='comment'>// error: attempt to use a non-constant value in a</span>
                       <span class='comment'>//        constant</span></pre>

<p>To fix this error, please replace the value with a constant. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>const</span> <span class='ident'>FOO</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>42u32</span>; <span class='comment'>// ok!</span>

<span class='comment'>// or:</span>
<span class='kw'>const</span> <span class='ident'>OTHER_FOO</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='number'>42u32</span>;
<span class='kw'>const</span> <span class='ident'>FOO</span> : <span class='ident'>u32</span> <span class='op'>=</span> <span class='ident'>OTHER_FOO</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0436" class="section-header"><a href="#E0436">E0436</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0437" class="section-header"><a href="#E0437">E0437</a></h2>
<p>Trait implementations can only implement associated types that are members of
the trait in question. This error indicates that you attempted to implement
an associated type whose name does not match the name of any associated type
in the trait.</p>

<p>Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>type</span> <span class='ident'>Bar</span> <span class='op'>=</span> <span class='ident'>bool</span>;
}</pre>

<p>The solution to this problem is to remove the extraneous associated type:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>i32</span> {}</pre>
</div>
<div class="error-described error-used"><h2 id="E0438" class="section-header"><a href="#E0438">E0438</a></h2>
<p>Trait implementations can only implement associated constants that are
members of the trait in question. This error indicates that you
attempted to implement an associated constant whose name does not
match the name of any associated constant in the trait.</p>

<p>Here is an example that demonstrates the error:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>associated_consts</span>)]</span>

<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>const</span> <span class='ident'>BAR</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='boolval'>true</span>;
}</pre>

<p>The solution to this problem is to remove the extraneous associated constant:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>i32</span> {}</pre>
</div>
<div class="error-described error-used"><h2 id="E0439" class="section-header"><a href="#E0439">E0439</a></h2>
<p>The length of the platform-intrinsic function <code>simd_shuffle</code>
wasn&#39;t specified. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>simd_shuffle</span><span class='op'>&lt;</span><span class='ident'>A</span>,<span class='ident'>B</span><span class='op'>&gt;</span>(<span class='ident'>a</span>: <span class='ident'>A</span>, <span class='ident'>b</span>: <span class='ident'>A</span>, <span class='ident'>c</span>: [<span class='ident'>u32</span>; <span class='number'>8</span>]) <span class='op'>-&gt;</span> <span class='ident'>B</span>;
    <span class='comment'>// error: invalid `simd_shuffle`, needs length: `simd_shuffle`</span>
}</pre>

<p>The <code>simd_shuffle</code> function needs the length of the array passed as
last parameter in its name. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>simd_shuffle8</span><span class='op'>&lt;</span><span class='ident'>A</span>,<span class='ident'>B</span><span class='op'>&gt;</span>(<span class='ident'>a</span>: <span class='ident'>A</span>, <span class='ident'>b</span>: <span class='ident'>A</span>, <span class='ident'>c</span>: [<span class='ident'>u32</span>; <span class='number'>8</span>]) <span class='op'>-&gt;</span> <span class='ident'>B</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0440" class="section-header"><a href="#E0440">E0440</a></h2>
<p>A platform-specific intrinsic function has the wrong number of type
parameters. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>f64x2</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_movemask_pd</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>f64x2</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;
    <span class='comment'>// error: platform-specific intrinsic has wrong number of type</span>
    <span class='comment'>//        parameters</span>
}</pre>

<p>Please refer to the function declaration to see if it corresponds
with yours. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>f64x2</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_movemask_pd</span>(<span class='ident'>x</span>: <span class='ident'>f64x2</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0441" class="section-header"><a href="#E0441">E0441</a></h2>
<p>An unknown platform-specific intrinsic function was used. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i16x8</span>(<span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_adds_ep16</span>(<span class='ident'>x</span>: <span class='ident'>i16x8</span>, <span class='ident'>y</span>: <span class='ident'>i16x8</span>) <span class='op'>-&gt;</span> <span class='ident'>i16x8</span>;
    <span class='comment'>// error: unrecognized platform-specific intrinsic function</span>
}</pre>

<p>Please verify that the function name wasn&#39;t misspelled, and ensure
that it is declared in the rust source code (in the file
src/librustc_platform_intrinsics/x86.rs). Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i16x8</span>(<span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_adds_epi16</span>(<span class='ident'>x</span>: <span class='ident'>i16x8</span>, <span class='ident'>y</span>: <span class='ident'>i16x8</span>) <span class='op'>-&gt;</span> <span class='ident'>i16x8</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0442" class="section-header"><a href="#E0442">E0442</a></h2>
<p>Intrinsic argument(s) and/or return value have the wrong type.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i8x16</span>(<span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>,
             <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>, <span class='ident'>i8</span>);
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i32x4</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i64x2</span>(<span class='ident'>i64</span>, <span class='ident'>i64</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_adds_epi16</span>(<span class='ident'>x</span>: <span class='ident'>i8x16</span>, <span class='ident'>y</span>: <span class='ident'>i32x4</span>) <span class='op'>-&gt;</span> <span class='ident'>i64x2</span>;
    <span class='comment'>// error: intrinsic arguments/return value have wrong type</span>
}</pre>

<p>To fix this error, please refer to the function declaration to give
it the awaited types. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i16x8</span>(<span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_adds_epi16</span>(<span class='ident'>x</span>: <span class='ident'>i16x8</span>, <span class='ident'>y</span>: <span class='ident'>i16x8</span>) <span class='op'>-&gt;</span> <span class='ident'>i16x8</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0443" class="section-header"><a href="#E0443">E0443</a></h2>
<p>Intrinsic argument(s) and/or return value have the wrong type.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i16x8</span>(<span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>);
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i64x8</span>(<span class='ident'>i64</span>, <span class='ident'>i64</span>, <span class='ident'>i64</span>, <span class='ident'>i64</span>, <span class='ident'>i64</span>, <span class='ident'>i64</span>, <span class='ident'>i64</span>, <span class='ident'>i64</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_adds_epi16</span>(<span class='ident'>x</span>: <span class='ident'>i16x8</span>, <span class='ident'>y</span>: <span class='ident'>i16x8</span>) <span class='op'>-&gt;</span> <span class='ident'>i64x8</span>;
    <span class='comment'>// error: intrinsic argument/return value has wrong type</span>
}</pre>

<p>To fix this error, please refer to the function declaration to give
it the awaited types. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i16x8</span>(<span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>, <span class='ident'>i16</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_adds_epi16</span>(<span class='ident'>x</span>: <span class='ident'>i16x8</span>, <span class='ident'>y</span>: <span class='ident'>i16x8</span>) <span class='op'>-&gt;</span> <span class='ident'>i16x8</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0444" class="section-header"><a href="#E0444">E0444</a></h2>
<p>A platform-specific intrinsic function has wrong number of arguments.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>f64x2</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_movemask_pd</span>(<span class='ident'>x</span>: <span class='ident'>f64x2</span>, <span class='ident'>y</span>: <span class='ident'>f64x2</span>, <span class='ident'>z</span>: <span class='ident'>f64x2</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;
    <span class='comment'>// error: platform-specific intrinsic has invalid number of arguments</span>
}</pre>

<p>Please refer to the function declaration to see if it corresponds
with yours. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>f64x2</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>x86_mm_movemask_pd</span>(<span class='ident'>x</span>: <span class='ident'>f64x2</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>; <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0445" class="section-header"><a href="#E0445">E0445</a></h2>
<p>A private trait was used on a public type parameter bound. Erroneous code
examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>dummy</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { }
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Bar</span> : <span class='ident'>Foo</span> {} <span class='comment'>// error: private trait in exported type parameter bound</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='kw'>pub</span> <span class='ident'>T</span>); <span class='comment'>// same error</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span> (<span class='ident'>t</span>: <span class='ident'>T</span>) {} <span class='comment'>// same error</span></pre>

<p>To solve this error, please ensure that the trait is also public and accessible
at the same level of the public functions or types which are bound on it.
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Foo</span> { <span class='comment'>// we set the Foo trait public</span>
    <span class='kw'>fn</span> <span class='ident'>dummy</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { }
}

<span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Bar</span> : <span class='ident'>Foo</span> {} <span class='comment'>// ok!</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='kw'>pub</span> <span class='ident'>T</span>); <span class='comment'>// ok!</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span> (<span class='ident'>t</span>: <span class='ident'>T</span>) {} <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0446" class="section-header"><a href="#E0446">E0446</a></h2>
<p>A private type was used in an exported type signature. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>Foo</span> {
    <span class='kw'>struct</span> <span class='ident'>Bar</span>(<span class='ident'>u32</span>);

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='ident'>Bar</span> { <span class='comment'>// error: private type in exported type signature</span>
        <span class='ident'>Bar</span>(<span class='number'>0</span>)
    }
}</pre>

<p>To solve this error, please ensure that the type is also public and accessible
at the same level of the public functions or types which use it. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>Foo</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Bar</span>(<span class='ident'>u32</span>); <span class='comment'>// we set the Bar type public</span>

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>bar</span>() <span class='op'>-&gt;</span> <span class='ident'>Bar</span> { <span class='comment'>// ok!</span>
        <span class='ident'>Bar</span>(<span class='number'>0</span>)
    }
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0447" class="section-header"><a href="#E0447">E0447</a></h2>
<p>The <code>pub</code> keyword was used inside a function. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Bar</span>; <span class='comment'>// error: visibility has no effect inside functions</span>
}</pre>

<p>Since we cannot access items defined inside a function, the visibility of its
items does not impact outer code. So using the <code>pub</code> keyword in this context
is invalid.</p>
</div>
<div class="error-described error-unused"><h2 id="E0448" class="section-header"><a href="#E0448">E0448</a></h2>
<p>The <code>pub</code> keyword was used inside a public enum. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='kw'>pub</span> <span class='ident'>Bar</span>, <span class='comment'>// error: unnecessary `pub` visibility</span>
}</pre>

<p>Since the enum is already public, adding <code>pub</code> on one its elements is
unnecessary. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='kw'>pub</span> <span class='ident'>Bar</span>, <span class='comment'>// ok!</span>
}

<span class='comment'>// or:</span>

<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>Bar</span>, <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0449" class="section-header"><a href="#E0449">E0449</a></h2>
<p>A visibility qualifier was used when it was unnecessary. Erroneous code
examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='kw'>pub</span> <span class='kw'>impl</span> <span class='ident'>Bar</span> {} <span class='comment'>// error: unnecessary visibility qualifier</span>

<span class='kw'>pub</span> <span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> { <span class='comment'>// error: unnecessary visibility qualifier</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {} <span class='comment'>// error: unnecessary visibility qualifier</span>
}</pre>

<p>To fix this error, please remove the visibility qualifier when it is not
required. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Bar</span>;

<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>();
}

<span class='comment'>// Directly implemented methods share the visibility of the type itself,</span>
<span class='comment'>// so `pub` is unnecessary here</span>
<span class='kw'>impl</span> <span class='ident'>Bar</span> {}

<span class='comment'>// Trait methods share the visibility of the trait, so `pub` is</span>
<span class='comment'>// unnecessary in either case</span>
<span class='kw'>pub</span> <span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Bar</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() {}
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0450" class="section-header"><a href="#E0450">E0450</a></h2>
<p>A tuple constructor was invoked while some of its fields are private. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>Bar</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>isize</span>);
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Bar</span>::<span class='ident'>Foo</span>(<span class='number'>0</span>); <span class='comment'>// error: cannot invoke tuple struct constructor with</span>
                     <span class='comment'>//        private fields</span></pre>

<p>To solve this issue, please ensure that all of the fields of the tuple struct
are public. Alternatively, provide a new() method to the tuple struct to
construct it from a given inner value. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>Bar</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='kw'>pub</span> <span class='ident'>isize</span>); <span class='comment'>// we set its field to public</span>
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Bar</span>::<span class='ident'>Foo</span>(<span class='number'>0</span>); <span class='comment'>// ok!</span>

<span class='comment'>// or:</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span>(<span class='ident'>isize</span>);

    <span class='kw'>impl</span> <span class='ident'>Foo</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>x</span>: <span class='ident'>isize</span>) {
            <span class='ident'>Foo</span>(<span class='ident'>x</span>)
        }
    }
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>bar</span>::<span class='ident'>Foo</span>::<span class='ident'>new</span>(<span class='number'>1</span>);</pre>
</div>
<div class="error-described error-used"><h2 id="E0451" class="section-header"><a href="#E0451">E0451</a></h2>
<p>A struct constructor with private fields was invoked. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>Bar</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span> {
        <span class='kw'>pub</span> <span class='ident'>a</span>: <span class='ident'>isize</span>,
        <span class='ident'>b</span>: <span class='ident'>isize</span>,
    }
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Bar</span>::<span class='ident'>Foo</span>{ <span class='ident'>a</span>: <span class='number'>0</span>, <span class='ident'>b</span>: <span class='number'>0</span> }; <span class='comment'>// error: field `b` of struct `Bar::Foo`</span>
                                <span class='comment'>//        is private</span></pre>

<p>To fix this error, please ensure that all the fields of the struct, or
implement a function for easy instantiation. Examples:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>mod</span> <span class='ident'>Bar</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span> {
        <span class='kw'>pub</span> <span class='ident'>a</span>: <span class='ident'>isize</span>,
        <span class='kw'>pub</span> <span class='ident'>b</span>: <span class='ident'>isize</span>, <span class='comment'>// we set `b` field public</span>
    }
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Bar</span>::<span class='ident'>Foo</span>{ <span class='ident'>a</span>: <span class='number'>0</span>, <span class='ident'>b</span>: <span class='number'>0</span> }; <span class='comment'>// ok!</span>

<span class='comment'>// or:</span>
<span class='kw'>mod</span> <span class='ident'>Bar</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Foo</span> {
        <span class='kw'>pub</span> <span class='ident'>a</span>: <span class='ident'>isize</span>,
        <span class='ident'>b</span>: <span class='ident'>isize</span>, <span class='comment'>// still private</span>
    }

    <span class='kw'>impl</span> <span class='ident'>Foo</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>() <span class='op'>-&gt;</span> <span class='ident'>Foo</span> { <span class='comment'>// we create a method to instantiate `Foo`</span>
            <span class='ident'>Foo</span> { <span class='ident'>a</span>: <span class='number'>0</span>, <span class='ident'>b</span>: <span class='number'>0</span> }
        }
    }
}

<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>Bar</span>::<span class='ident'>Foo</span>::<span class='ident'>new</span>(); <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0452" class="section-header"><a href="#E0452">E0452</a></h2>
<p>An invalid lint attribute has been given. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>allow</span>(<span class='ident'>foo</span> <span class='op'>=</span> <span class='string'>&quot;&quot;</span>)]</span> <span class='comment'>// error: malformed lint attribute</span></pre>

<p>Lint attributes only accept a list of identifiers (where each identifier is a
lint name). Ensure the attribute is of this form:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>allow</span>(<span class='ident'>foo</span>)]</span> <span class='comment'>// ok!</span>
<span class='comment'>// or:</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>allow</span>(<span class='ident'>foo</span>, <span class='ident'>foo2</span>)]</span> <span class='comment'>// ok!</span></pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0453" class="section-header"><a href="#E0453">E0453</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0471" class="section-header"><a href="#E0471">E0471</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0472" class="section-header"><a href="#E0472">E0472</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0473" class="section-header"><a href="#E0473">E0473</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0474" class="section-header"><a href="#E0474">E0474</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0475" class="section-header"><a href="#E0475">E0475</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0476" class="section-header"><a href="#E0476">E0476</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0477" class="section-header"><a href="#E0477">E0477</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0478" class="section-header"><a href="#E0478">E0478</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0479" class="section-header"><a href="#E0479">E0479</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0480" class="section-header"><a href="#E0480">E0480</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0481" class="section-header"><a href="#E0481">E0481</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0482" class="section-header"><a href="#E0482">E0482</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0483" class="section-header"><a href="#E0483">E0483</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0484" class="section-header"><a href="#E0484">E0484</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0485" class="section-header"><a href="#E0485">E0485</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0486" class="section-header"><a href="#E0486">E0486</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0487" class="section-header"><a href="#E0487">E0487</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0488" class="section-header"><a href="#E0488">E0488</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0489" class="section-header"><a href="#E0489">E0489</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0490" class="section-header"><a href="#E0490">E0490</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0491" class="section-header"><a href="#E0491">E0491</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0492" class="section-header"><a href="#E0492">E0492</a></h2>
<p>A borrow of a constant containing interior mutability was attempted. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>atomic</span>::{<span class='ident'>AtomicUsize</span>, <span class='ident'>ATOMIC_USIZE_INIT</span>};

<span class='kw'>const</span> <span class='ident'>A</span>: <span class='ident'>AtomicUsize</span> <span class='op'>=</span> <span class='ident'>ATOMIC_USIZE_INIT</span>;
<span class='kw'>static</span> <span class='ident'>B</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>AtomicUsize</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>A</span>;
<span class='comment'>// error: cannot borrow a constant which contains interior mutability, create a</span>
<span class='comment'>//        static instead</span></pre>

<p>A <code>const</code> represents a constant value that should never change. If one takes
a <code>&amp;</code> reference to the constant, then one is taking a pointer to some memory
location containing the value. Normally this is perfectly fine: most values
can&#39;t be changed via a shared <code>&amp;</code> pointer, but interior mutability would allow
it. That is, a constant value could be mutated. On the other hand, a <code>static</code> is
explicitly a single memory location, which can be mutated at will.</p>

<p>So, in order to solve this error, either use statics which are <code>Sync</code>:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>atomic</span>::{<span class='ident'>AtomicUsize</span>, <span class='ident'>ATOMIC_USIZE_INIT</span>};

<span class='kw'>static</span> <span class='ident'>A</span>: <span class='ident'>AtomicUsize</span> <span class='op'>=</span> <span class='ident'>ATOMIC_USIZE_INIT</span>;
<span class='kw'>static</span> <span class='ident'>B</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>AtomicUsize</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>A</span>; <span class='comment'>// ok!</span></pre>

<p>You can also have this error while using a cell type:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>const_fn</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>Cell</span>;

<span class='kw'>const</span> <span class='ident'>A</span>: <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='number'>1</span>);
<span class='kw'>const</span> <span class='ident'>B</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>A</span>;
<span class='comment'>// error: cannot borrow a constant which contains interior mutability, create</span>
<span class='comment'>//        a static instead</span>

<span class='comment'>// or:</span>
<span class='kw'>struct</span> <span class='ident'>C</span> { <span class='ident'>a</span>: <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> }

<span class='kw'>const</span> <span class='ident'>D</span>: <span class='ident'>C</span> <span class='op'>=</span> <span class='ident'>C</span> { <span class='ident'>a</span>: <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='number'>1</span>) };
<span class='kw'>const</span> <span class='ident'>E</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>D</span>.<span class='ident'>a</span>; <span class='comment'>// error</span>

<span class='comment'>// or:</span>
<span class='kw'>const</span> <span class='ident'>F</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>C</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>D</span>; <span class='comment'>// error</span></pre>

<p>This is because cell types do operations that are not thread-safe. Due to this,
they don&#39;t implement Sync and thus can&#39;t be placed in statics. In this
case, <code>StaticMutex</code> would work just fine, but it isn&#39;t stable yet:
<a href="https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html">https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html</a></p>

<p>However, if you still wish to use these types, you can achieve this by an unsafe
wrapper:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>const_fn</span>)]</span>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>Cell</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>marker</span>::<span class='ident'>Sync</span>;

<span class='kw'>struct</span> <span class='ident'>NotThreadSafe</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>value</span>: <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>unsafe</span> <span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Sync</span> <span class='kw'>for</span> <span class='ident'>NotThreadSafe</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {}

<span class='kw'>static</span> <span class='ident'>A</span>: <span class='ident'>NotThreadSafe</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>NotThreadSafe</span> { <span class='ident'>value</span> : <span class='ident'>Cell</span>::<span class='ident'>new</span>(<span class='number'>1</span>) };
<span class='kw'>static</span> <span class='ident'>B</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>NotThreadSafe</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>A</span>; <span class='comment'>// ok!</span></pre>

<p>Remember this solution is unsafe! You will have to ensure that accesses to the
cell are synchronized.</p>
</div>
<div class="error-described error-used"><h2 id="E0493" class="section-header"><a href="#E0493">E0493</a></h2>
<p>A type with a destructor was assigned to an invalid type of variable. Erroneous
code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>u32</span>
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {}
}

<span class='kw'>const</span> <span class='ident'>F</span> : <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span> : <span class='number'>0</span> };
<span class='comment'>// error: constants are not allowed to have destructors</span>
<span class='kw'>static</span> <span class='ident'>S</span> : <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span> : <span class='number'>0</span> };
<span class='comment'>// error: statics are not allowed to have destructors</span></pre>

<p>To solve this issue, please use a type which does allow the usage of type with
destructors.</p>
</div>
<div class="error-described error-used"><h2 id="E0494" class="section-header"><a href="#E0494">E0494</a></h2>
<p>A reference of an interior static was assigned to another const/static.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>u32</span>
}

<span class='kw'>static</span> <span class='ident'>S</span> : <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span> : <span class='number'>0</span> };
<span class='kw'>static</span> <span class='ident'>A</span> : <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>S</span>.<span class='ident'>a</span>;
<span class='comment'>// error: cannot refer to the interior of another static, use a</span>
<span class='comment'>//        constant instead</span></pre>

<p>The &quot;base&quot; variable has to be a const if you want another static/const variable
to refer to one of its fields. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>u32</span>
}

<span class='kw'>const</span> <span class='ident'>S</span> : <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>a</span> : <span class='number'>0</span> };
<span class='kw'>static</span> <span class='ident'>A</span> : <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>u32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>S</span>.<span class='ident'>a</span>; <span class='comment'>// ok!</span></pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0495" class="section-header"><a href="#E0495">E0495</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0496" class="section-header"><a href="#E0496">E0496</a></h2>
<p>A lifetime name is shadowing another lifetime name. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>f</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>) { <span class='comment'>// error: lifetime name `&#39;a` shadows a lifetime</span>
                           <span class='comment'>//        name that is already in scope</span>
    }
}</pre>

<p>Please change the name of one of the lifetimes to remove this error. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>f</span><span class='op'>&lt;</span><span class='lifetime'>&#39;b</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>i32</span>) { <span class='comment'>// ok!</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
}</pre>
</div>
<div class="error-described error-unused"><h2 id="E0497" class="section-header"><a href="#E0497">E0497</a></h2>
<p>A stability attribute was used outside of the standard library. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>stable</span>]</span> <span class='comment'>// error: stability attributes may not be used outside of the</span>
          <span class='comment'>//        standard library</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {}</pre>

<p>It is not possible to use stability attributes outside of the standard library.
Also, for now, it is not possible to write deprecation messages either.</p>
</div>
<div class="error-described error-used"><h2 id="E0499" class="section-header"><a href="#E0499">E0499</a></h2>
<p>A variable was borrowed as mutable more than once. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i</span>;
<span class='comment'>// error: cannot borrow `i` as mutable more than once at a time</span></pre>

<p>Please note that in rust, you can either have many immutable references, or one
mutable reference. Take a look at
<a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html">https://doc.rust-lang.org/stable/book/references-and-borrowing.html</a> for more
information. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i</span>; <span class='comment'>// ok!</span>

<span class='comment'>// or:</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>i</span>; <span class='comment'>// ok!</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>i</span>; <span class='comment'>// still ok!</span>
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>i</span>; <span class='comment'>// still ok!</span></pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0500" class="section-header"><a href="#E0500">E0500</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0501" class="section-header"><a href="#E0501">E0501</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0502" class="section-header"><a href="#E0502">E0502</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0503" class="section-header"><a href="#E0503">E0503</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0504" class="section-header"><a href="#E0504">E0504</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0505" class="section-header"><a href="#E0505">E0505</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0506" class="section-header"><a href="#E0506">E0506</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0507" class="section-header"><a href="#E0507">E0507</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0508" class="section-header"><a href="#E0508">E0508</a></h2>
<p>No description.</p>
</div>
<div class="error-undescribed error-used"><h2 id="E0509" class="section-header"><a href="#E0509">E0509</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0510" class="section-header"><a href="#E0510">E0510</a></h2>
<p><code>return_address</code> was used in an invalid context. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>return_address</span>() <span class='op'>-&gt;</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>;
}

<span class='kw'>pub</span> <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>by_value</span>() <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>let</span> _ <span class='op'>=</span> <span class='ident'>return_address</span>();
    <span class='comment'>// error: invalid use of `return_address` intrinsic: function does</span>
    <span class='comment'>//        not use out pointer</span>
    <span class='number'>0</span>
}</pre>

<p>Return values may be stored in a return register(s) or written into a so-called
out pointer. In case the returned value is too big (this is
target-ABI-dependent and generally not portable or future proof) to fit into
the return register(s), the compiler will return the value by writing it into
space allocated in the caller&#39;s stack frame. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;rust-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>return_address</span>() <span class='op'>-&gt;</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>;
}

<span class='kw'>pub</span> <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>by_pointer</span>() <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='kw'>let</span> _ <span class='op'>=</span> <span class='ident'>return_address</span>();
    <span class='ident'>String</span>::<span class='ident'>new</span>() <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0511" class="section-header"><a href="#E0511">E0511</a></h2>
<p>Invalid monomorphization of an intrinsic function was used. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>simd_add</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>a</span>: <span class='ident'>T</span>, <span class='ident'>b</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
}

<span class='kw'>unsafe</span> { <span class='ident'>simd_add</span>(<span class='number'>0</span>, <span class='number'>1</span>); }
<span class='comment'>// error: invalid monomorphization of `simd_add` intrinsic</span></pre>

<p>The generic type has to be a SIMD type. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>simd</span>)]</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Copy</span>, <span class='ident'>Clone</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>i32x1</span>(<span class='ident'>i32</span>);

<span class='kw'>extern</span> <span class='string'>&quot;platform-intrinsic&quot;</span> {
    <span class='kw'>fn</span> <span class='ident'>simd_add</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>a</span>: <span class='ident'>T</span>, <span class='ident'>b</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
}

<span class='kw'>unsafe</span> { <span class='ident'>simd_add</span>(<span class='ident'>i32x1</span>(<span class='number'>0</span>), <span class='ident'>i32x1</span>(<span class='number'>1</span>)); } <span class='comment'>// ok!</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0512" class="section-header"><a href="#E0512">E0512</a></h2>
<p>Transmute with two differently sized types was attempted. Erroneous code
example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>takes_u8</span>(_: <span class='ident'>u8</span>) {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> { <span class='ident'>takes_u8</span>(::<span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='number'>0u16</span>)); }
    <span class='comment'>// error: transmute called with differently sized types</span>
}</pre>

<p>Please use types with same size or use the expected type directly. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>takes_u8</span>(_: <span class='ident'>u8</span>) {}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> { <span class='ident'>takes_u8</span>(::<span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='number'>0i8</span>)); } <span class='comment'>// ok!</span>
    <span class='comment'>// or:</span>
    <span class='kw'>unsafe</span> { <span class='ident'>takes_u8</span>(<span class='number'>0u8</span>); } <span class='comment'>// ok!</span>
}</pre>
</div>
<div class="error-undescribed error-used"><h2 id="E0513" class="section-header"><a href="#E0513">E0513</a></h2>
<p>No description.</p>
</div>
<div class="error-described error-used"><h2 id="E0515" class="section-header"><a href="#E0515">E0515</a></h2>
<p>A constant index expression was out of bounds. Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>][<span class='number'>7</span>]; <span class='comment'>// error: const index-expr is out of bounds</span></pre>

<p>Please specify a valid index (not inferior to 0 or superior to array length).
Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>][<span class='number'>2</span>]; <span class='comment'>// ok</span></pre>
</div>
<div class="error-described error-used"><h2 id="E0516" class="section-header"><a href="#E0516">E0516</a></h2>
<p>The <code>typeof</code> keyword is currently reserved but unimplemented.
Erroneous code example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw'>typeof</span>(<span class='number'>92</span>) <span class='op'>=</span> <span class='number'>92</span>;
}</pre>

<p>Try using type inference instead. Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>92</span>;
}</pre>
</div>
<div class="error-described error-used"><h2 id="E0517" class="section-header"><a href="#E0517">E0517</a></h2>
<p>This error indicates that a <code>#[repr(..)]</code> attribute was placed on an unsupported
item.</p>

<p>Examples of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>C</span>)]</span>
<span class='kw'>type</span> <span class='ident'>Foo</span> <span class='op'>=</span> <span class='ident'>u8</span>;

<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>packed</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {<span class='ident'>Bar</span>, <span class='ident'>Baz</span>}

<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>u8</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {<span class='ident'>bar</span>: <span class='ident'>bool</span>, <span class='ident'>baz</span>: <span class='ident'>bool</span>}

<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>C</span>)]</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    ...
}</pre>

<ul>
<li>The <code>#[repr(C)]</code> attribute can only be placed on structs and enums</li>
<li>The <code>#[repr(packed)]</code> and <code>#[repr(simd)]</code> attributes only work on structs</li>
<li>The <code>#[repr(u8)]</code>, <code>#[repr(i16)]</code>, etc attributes only work on enums</li>
</ul>

<p>These attributes do not work on typedefs, since typedefs are just aliases.</p>

<p>Representations like <code>#[repr(u8)]</code>, <code>#[repr(i64)]</code> are for selecting the
discriminant size for C-like enums (when there is no associated data, e.g. <code>enum Color {Red, Blue, Green}</code>), effectively setting the size of the enum to the size
of the provided type. Such an enum can be cast to a value of the same type as
well. In short, <code>#[repr(u8)]</code> makes the enum behave like an integer with a
constrained set of allowed values.</p>

<p>Only C-like enums can be cast to numerical primitives, so this attribute will
not apply to structs.</p>

<p><code>#[repr(packed)]</code> reduces padding to make the struct size smaller. The
representation of enums isn&#39;t strictly defined in Rust, and this attribute won&#39;t
work on enums.</p>

<p><code>#[repr(simd)]</code> will give a struct consisting of a homogenous series of machine
types (i.e. <code>u8</code>, <code>i32</code>, etc) a representation that permits vectorization via
SIMD. This doesn&#39;t make much sense for enums since they don&#39;t consist of a
single list of data.</p>
</div>
<div class="error-described error-used"><h2 id="E0518" class="section-header"><a href="#E0518">E0518</a></h2>
<p>This error indicates that an <code>#[inline(..)]</code> attribute was incorrectly placed on
something other than a function or method.</p>

<p>Examples of erroneous code:</p>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>inline</span>(<span class='ident'>always</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='attribute'>#[<span class='ident'>inline</span>(<span class='ident'>never</span>)]</span>
<span class='kw'>impl</span> <span class='ident'>Foo</span> {
    ...
}</pre>

<p><code>#[inline]</code> hints the compiler whether or not to attempt to inline a method or
function. By default, the compiler does a pretty good job of figuring this out
itself, but if you feel the need for annotations, <code>#[inline(always)]</code> and
<code>#[inline(never)]</code> can override or force the compiler&#39;s decision.</p>

<p>If you wish to apply this attribute to all methods in an impl, manually annotate
each method; it is not possible to annotate the entire impl with an <code>#[inline]</code>
attribute.</p>
</div>
</body>
</html>