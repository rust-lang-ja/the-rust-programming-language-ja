<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Drop Flags</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ul class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ul>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ul class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ul>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ul class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ul>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ul class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ul>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ul class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a class='active' href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ul>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ul class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ul>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ul class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ul>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ul class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ul>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ul class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ul>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Drop Flags</h1>
    <p>The examples in the previous section introduce an interesting problem for Rust.
We have seen that it&#39;s possible to conditionally initialize, deinitialize, and
reinitialize locations of memory totally safely. For Copy types, this isn&#39;t
particularly notable since they&#39;re just a random pile of bits. However types
with destructors are a different story: Rust needs to know whether to call a
destructor whenever a variable is assigned to, or a variable goes out of scope.
How can it do this with conditional initialization?</p>

<p>Note that this is not a problem that all assignments need worry about. In
particular, assigning through a dereference unconditionally drops, and assigning
in a <code>let</code> unconditionally doesn&#39;t drop:</p>
<span class='rusttest'>fn main() {
    let mut x = Box::new(0); // let makes a fresh variable, so never need to drop
    let y = &amp;mut x;
    *y = Box::new(1); // Deref assumes the referent is initialized, so always drops
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>); <span class='comment'>// let makes a fresh variable, so never need to drop</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>;
<span class='op'>*</span><span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>1</span>); <span class='comment'>// Deref assumes the referent is initialized, so always drops</span></pre>

<p>This is only a problem when overwriting a previously initialized variable or
one of its subfields.</p>

<p>It turns out that Rust actually tracks whether a type should be dropped or not
<em>at runtime</em>. As a variable becomes initialized and uninitialized, a <em>drop flag</em>
for that variable is toggled. When a variable might need to be dropped, this
flag is evaluated to determine if it should be dropped.</p>

<p>Of course, it is often the case that a value&#39;s initialization state can be
statically known at every point in the program. If this is the case, then the
compiler can theoretically generate more efficient code! For instance, straight-
line code has such <em>static drop semantics</em>:</p>
<span class='rusttest'>fn main() {
    let mut x = Box::new(0); // x was uninit; just overwrite.
    let mut y = x;           // y was uninit; just overwrite and make x uninit.
    x = Box::new(0);         // x was uninit; just overwrite.
    y = x;                   // y was init; Drop y, overwrite it, and make x uninit!
                             // y goes out of scope; y was init; Drop y!
                             // x goes out of scope; x was uninit; do nothing.
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>); <span class='comment'>// x was uninit; just overwrite.</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>;           <span class='comment'>// y was uninit; just overwrite and make x uninit.</span>
<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>);         <span class='comment'>// x was uninit; just overwrite.</span>
<span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>;                   <span class='comment'>// y was init; Drop y, overwrite it, and make x uninit!</span>
                         <span class='comment'>// y goes out of scope; y was init; Drop y!</span>
                         <span class='comment'>// x goes out of scope; x was uninit; do nothing.</span></pre>

<p>Similarly, branched code where all branches have the same behavior with respect
to initialization has static drop semantics:</p>
<span class='rusttest'>fn main() {
    let condition = true;
    let mut x = Box::new(0);    // x was uninit; just overwrite.
    if condition {
        drop(x)                 // x gets moved out; make x uninit.
    } else {
        println!(&quot;{}&quot;, x);
        drop(x)                 // x gets moved out; make x uninit.
    }
    x = Box::new(0);            // x was uninit; just overwrite.
                                // x goes out of scope; x was init; Drop x!
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>);    <span class='comment'>// x was uninit; just overwrite.</span>
<span class='kw'>if</span> <span class='ident'>condition</span> {
    <span class='ident'>drop</span>(<span class='ident'>x</span>)                 <span class='comment'>// x gets moved out; make x uninit.</span>
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
    <span class='ident'>drop</span>(<span class='ident'>x</span>)                 <span class='comment'>// x gets moved out; make x uninit.</span>
}
<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>);            <span class='comment'>// x was uninit; just overwrite.</span>
                            <span class='comment'>// x goes out of scope; x was init; Drop x!</span></pre>

<p>However code like this <em>requires</em> runtime information to correctly Drop:</p>
<span class='rusttest'>fn main() {
    let condition = true;
    let x;
    if condition {
        x = Box::new(0);        // x was uninit; just overwrite.
        println!(&quot;{}&quot;, x);
    }
                                // x goes out of scope; x might be uninit;
                                // check the flag!
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>;
<span class='kw'>if</span> <span class='ident'>condition</span> {
    <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>);        <span class='comment'>// x was uninit; just overwrite.</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}
                            <span class='comment'>// x goes out of scope; x might be uninit;</span>
                            <span class='comment'>// check the flag!</span></pre>

<p>Of course, in this case it&#39;s trivial to retrieve static drop semantics:</p>
<span class='rusttest'>fn main() {
    let condition = true;
    if condition {
        let x = Box::new(0);
        println!(&quot;{}&quot;, x);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>if</span> <span class='ident'>condition</span> {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='number'>0</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<p>As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden
field of any type that implements Drop. Rust sets the drop flag by overwriting
the entire value with a particular bit pattern. This is pretty obviously Not
The Fastest and causes a bunch of trouble with optimizing code. It&#39;s legacy from
a time when you could do much more complex conditional initialization.</p>

<p>As such work is currently under way to move the flags out onto the stack frame
where they more reasonably belong. Unfortunately, this work will take some time
as it requires fairly substantial changes to the compiler.</p>

<p>Regardless, Rust programs don&#39;t need to worry about uninitialized values on
the stack for correctness. Although they might care for performance. Thankfully,
Rust makes it easy to take control here! Uninitialized values are there, and
you can work with them in Safe Rust, but you&#39;re never in danger.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>