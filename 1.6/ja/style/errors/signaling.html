<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Signaling errors [RFC #236]</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../style/README.html'><b>2.</b> Style</a>
<ul class='section'>
<li><a  href='../style/whitespace.html'><b>2.1.</b> Whitespace</a>
</li>
<li><a  href='../style/comments.html'><b>2.2.</b> Comments</a>
</li>
<li><a  href='../style/braces.html'><b>2.3.</b> Braces, semicolons, commas</a>
</li>
<li><a  href='../style/naming/README.html'><b>2.4.</b> Naming</a>
<ul class='section'>
<li><a  href='../style/naming/ownership.html'><b>2.4.1.</b> Ownership variants</a>
</li>
<li><a  href='../style/naming/containers.html'><b>2.4.2.</b> Containers/wrappers</a>
</li>
<li><a  href='../style/naming/conversions.html'><b>2.4.3.</b> Conversions</a>
</li>
<li><a  href='../style/naming/iterators.html'><b>2.4.4.</b> Iterators</a>
</li>
</ul>
</li>
<li><a  href='../style/imports.html'><b>2.5.</b> Imports</a>
</li>
<li><a  href='../style/organization.html'><b>2.6.</b> Organization</a>
</li>
</ul>
</li>
<li><a  href='../features/README.html'><b>3.</b> Guidelines by Rust feature</a>
<ul class='section'>
<li><a  href='../features/let.html'><b>3.1.</b> Let binding</a>
</li>
<li><a  href='../features/match.html'><b>3.2.</b> Pattern matching</a>
</li>
<li><a  href='../features/loops.html'><b>3.3.</b> Loops</a>
</li>
<li><a  href='../features/functions-and-methods/README.html'><b>3.4.</b> Functions and methods</a>
<ul class='section'>
<li><a  href='../features/functions-and-methods/input.html'><b>3.4.1.</b> Input</a>
</li>
<li><a  href='../features/functions-and-methods/output.html'><b>3.4.2.</b> Output</a>
</li>
<li><a  href='../features/functions-and-methods/convenience.html'><b>3.4.3.</b> For convenience</a>
</li>
</ul>
</li>
<li><a  href='../features/types/README.html'><b>3.5.</b> Types</a>
<ul class='section'>
<li><a  href='../features/types/conversions.html'><b>3.5.1.</b> Conversions</a>
</li>
<li><a  href='../features/types/newtype.html'><b>3.5.2.</b> The newtype pattern</a>
</li>
</ul>
</li>
<li><a  href='../features/traits/README.html'><b>3.6.</b> Traits</a>
<ul class='section'>
<li><a  href='../features/traits/generics.html'><b>3.6.1.</b> For generics</a>
</li>
<li><a  href='../features/traits/objects.html'><b>3.6.2.</b> For objects</a>
</li>
<li><a  href='../features/traits/overloading.html'><b>3.6.3.</b> For overloading</a>
</li>
<li><a  href='../features/traits/extensions.html'><b>3.6.4.</b> For extensions</a>
</li>
<li><a  href='../features/traits/reuse.html'><b>3.6.5.</b> For reuse</a>
</li>
<li><a  href='../features/traits/common.html'><b>3.6.6.</b> Common traits</a>
</li>
</ul>
</li>
<li><a  href='../features/modules.html'><b>3.7.</b> Modules</a>
</li>
<li><a  href='../features/crates.html'><b>3.8.</b> Crates</a>
</li>
</ul>
</li>
<li><a  href='../ownership/README.html'><b>4.</b> Ownership and resources</a>
<ul class='section'>
<li><a  href='../ownership/constructors.html'><b>4.1.</b> Constructors</a>
</li>
<li><a  href='../ownership/builders.html'><b>4.2.</b> Builders</a>
</li>
<li><a  href='../ownership/destructors.html'><b>4.3.</b> Destructors</a>
</li>
<li><a  href='../ownership/raii.html'><b>4.4.</b> RAII</a>
</li>
<li><a  href='../ownership/cell-smart.html'><b>4.5.</b> Cells and smart pointers</a>
</li>
</ul>
</li>
<li><a  href='../errors/README.html'><b>5.</b> Errors</a>
<ul class='section'>
<li><a class='active' href='../errors/signaling.html'><b>5.1.</b> Signaling</a>
</li>
<li><a  href='../errors/handling.html'><b>5.2.</b> Handling</a>
</li>
<li><a  href='../errors/propagation.html'><b>5.3.</b> Propagation</a>
</li>
<li><a  href='../errors/ergonomics.html'><b>5.4.</b> Ergonomics</a>
</li>
</ul>
</li>
<li><a  href='../safety/README.html'><b>6.</b> Safety and guarantees</a>
<ul class='section'>
<li><a  href='../safety/unsafe.html'><b>6.1.</b> Using unsafe</a>
</li>
<li><a  href='../safety/lib-guarantees.html'><b>6.2.</b> Library guarantees</a>
</li>
</ul>
</li>
<li><a  href='../testing/README.html'><b>7.</b> Testing</a>
<ul class='section'>
<li><a  href='../testing/unit.html'><b>7.1.</b> Unit testing</a>
</li>
</ul>
</li>
<li><a  href='../platform.html'><b>8.</b> FFI, platform-specific code</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Signaling errors [RFC #236]</h1>
    <blockquote>
<p>The guidelines below were approved by <a href="https://github.com/rust-lang/rfcs/pull/236">RFC #236</a>.</p>
</blockquote>

<p>Errors fall into one of three categories:</p>

<ul>
<li>Catastrophic errors, e.g. out-of-memory.</li>
<li>Contract violations, e.g. wrong input encoding, index out of bounds.</li>
<li>Obstructions, e.g. file not found, parse error.</li>
</ul>

<p>The basic principle of the convention is that:</p>

<ul>
<li>Catastrophic errors and programming errors (bugs) can and should only be
recovered at a <em>coarse grain</em>, i.e. a thread boundary.</li>
<li>Obstructions preventing an operation should be reported at a maximally <em>fine
grain</em> -- to the immediate invoker of the operation.</li>
</ul>

<h2 id='catastrophic-errors' class='section-header'><a href='#catastrophic-errors'>Catastrophic errors</a></h2>
<p>An error is <em>catastrophic</em> if there is no meaningful way for the current thread to
continue after the error occurs.</p>

<p>Catastrophic errors are <em>extremely</em> rare, especially outside of <code>libstd</code>.</p>

<p><strong>Canonical examples</strong>: out of memory, stack overflow.</p>

<h3 id='for-catastrophic-errors-panic' class='section-header'><a href='#for-catastrophic-errors-panic'>For catastrophic errors, panic</a></h3>
<p>For errors like stack overflow, Rust currently aborts the process, but
could in principle panic, which (in the best case) would allow
reporting and recovery from a supervisory thread.</p>

<h2 id='contract-violations' class='section-header'><a href='#contract-violations'>Contract violations</a></h2>
<p>An API may define a contract that goes beyond the type checking enforced by the
compiler. For example, slices support an indexing operation, with the contract
that the supplied index must be in bounds.</p>

<p>Contracts can be complex and involve more than a single function invocation. For
example, the <code>RefCell</code> type requires that <code>borrow_mut</code> not be called until all
existing borrows have been relinquished.</p>

<h3 id='for-contract-violations-panic' class='section-header'><a href='#for-contract-violations-panic'>For contract violations, panic</a></h3>
<p>A contract violation is always a bug, and for bugs we follow the Erlang
philosophy of &quot;let it crash&quot;: we assume that software <em>will</em> have bugs, and we
design coarse-grained thread boundaries to report, and perhaps recover, from these
bugs.</p>

<h3 id='contract-design' class='section-header'><a href='#contract-design'>Contract design</a></h3>
<p>One subtle aspect of these guidelines is that the contract for a function is
chosen by an API designer -- and so the designer also determines what counts as
a violation.</p>

<p>This RFC does not attempt to give hard-and-fast rules for designing
contracts. However, here are some rough guidelines:</p>

<ul>
<li><p>Prefer expressing contracts through static types whenever possible.</p></li>
<li><p>It <em>must</em> be possible to write code that uses the API without violating the
contract.</p></li>
<li><p>Contracts are most justified when violations are <em>inarguably</em> bugs -- but this
is surprisingly rare.</p></li>
<li><p>Consider whether the API client could benefit from the contract-checking
logic.  The checks may be expensive. Or there may be useful programming
patterns where the client does not want to check inputs before hand, but would
rather attempt the operation and then find out whether the inputs were invalid.</p></li>
<li><p>When a contract violation is the <em>only</em> kind of error a function may encounter
-- i.e., there are no obstructions to its success other than &quot;bad&quot; inputs --
using <code>Result</code> or <code>Option</code> instead is especially warranted. Clients can then use
<code>unwrap</code> to assert that they have passed valid input, or re-use the error
checking done by the API for their own purposes.</p></li>
<li><p>When in doubt, use loose contracts and instead return a <code>Result</code> or <code>Option</code>.</p></li>
</ul>

<h2 id='obstructions' class='section-header'><a href='#obstructions'>Obstructions</a></h2>
<p>An operation is <em>obstructed</em> if it cannot be completed for some reason, even
though the operation&#39;s contract has been satisfied. Obstructed operations may
have (documented!) side effects -- they are not required to roll back after
encountering an obstruction.  However, they should leave the data structures in
a &quot;coherent&quot; state (satisfying their invariants, continuing to guarantee safety,
etc.).</p>

<p>Obstructions may involve external conditions (e.g., I/O), or they may involve
aspects of the input that are not covered by the contract.</p>

<p><strong>Canonical examples</strong>: file not found, parse error.</p>

<h3 id='for-obstructions-use-result' class='section-header'><a href='#for-obstructions-use-result'>For obstructions, use <code>Result</code></a></h3>
<p>The
<a href="https://doc.rust-lang.org/stable/std/result/index.html"><code>Result&lt;T,E&gt;</code> type</a>
represents either a success (yielding <code>T</code>) or failure (yielding <code>E</code>). By
returning a <code>Result</code>, a function allows its clients to discover and react to
obstructions in a fine-grained way.</p>

<h4 id='what-about-option' class='section-header'><a href='#what-about-option'>What about <code>Option</code>?</a></h4>
<p>The <code>Option</code> type should not be used for &quot;obstructed&quot; operations; it
should only be used when a <code>None</code> return value could be considered a
&quot;successful&quot; execution of the operation.</p>

<p>This is of course a somewhat subjective question, but a good litmus
test is: would a reasonable client ever ignore the result? The
<code>Result</code> type provides a lint that ensures the result is actually
inspected, while <code>Option</code> does not, and this difference of behavior
can help when deciding between the two types.</p>

<p>Another litmus test: can the operation be understood as asking a
question (possibly with sideeffects)? Operations like <code>pop</code> on a
vector can be viewed as asking for the contents of the first element,
with the side effect of removing it if it exists -- with an <code>Option</code>
return value.</p>

<h2 id='do-not-provide-both-result-and-panic-variants' class='section-header'><a href='#do-not-provide-both-result-and-panic-variants'>Do not provide both <code>Result</code> and <code>panic!</code> variants.</a></h2>
<p>An API should not provide both <code>Result</code>-producing and <code>panic</code>king versions of an
operation. It should provide just the <code>Result</code> version, allowing clients to use
<code>try!</code> or <code>unwrap</code> instead as needed. This is part of the general pattern of
cutting down on redundant variants by instead using method chaining.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>