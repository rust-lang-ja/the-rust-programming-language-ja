<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Exotically Sized Types</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ul class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ul>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ul class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a class='active' href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ul>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ul class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ul>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ul class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ul>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ul class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ul>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ul class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ul>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ul class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ul>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ul class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ul>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ul class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ul>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Exotically Sized Types</h1>
    <p>Most of the time, we think in terms of types with a fixed, positive size. This
is not always the case, however.</p>

<h1 id='dynamically-sized-types-dsts' class='section-header'><a href='#dynamically-sized-types-dsts'>Dynamically Sized Types (DSTs)</a></h1>
<p>Rust in fact supports Dynamically Sized Types (DSTs): types without a statically
known size or alignment. On the surface, this is a bit nonsensical: Rust <em>must</em>
know the size and alignment of something in order to correctly work with it! In
this regard, DSTs are not normal types. Due to their lack of a statically known
size, these types can only exist behind some kind of pointer. Any pointer to a
DST consequently becomes a <em>fat</em> pointer consisting of the pointer and the
information that &quot;completes&quot; them (more on this below).</p>

<p>There are two major DSTs exposed by the language: trait objects, and slices.</p>

<p>A trait object represents some type that implements the traits it specifies.
The exact original type is <em>erased</em> in favor of runtime reflection
with a vtable containing all the information necessary to use the type.
This is the information that completes a trait object: a pointer to its vtable.</p>

<p>A slice is simply a view into some contiguous storage -- typically an array or
<code>Vec</code>. The information that completes a slice is just the number of elements
it points to.</p>

<p>Structs can actually store a single DST directly as their last field, but this
makes them a DST as well:</p>
<span class='rusttest'>fn main() {
    // Can&#39;t be stored on the stack directly
    struct Foo {
        info: u32,
        data: [u8],
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// Can&#39;t be stored on the stack directly</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>info</span>: <span class='ident'>u32</span>,
    <span class='ident'>data</span>: [<span class='ident'>u8</span>],
}</pre>

<p><strong>NOTE: <a href="https://github.com/rust-lang/rust/issues/26403">As of Rust 1.0 struct DSTs are broken if the last field has
a variable position based on its alignment</a>.</strong></p>

<h1 id='zero-sized-types-zsts' class='section-header'><a href='#zero-sized-types-zsts'>Zero Sized Types (ZSTs)</a></h1>
<p>Rust actually allows types to be specified that occupy no space:</p>
<span class='rusttest'>fn main() {
    struct Foo; // No fields = no size
    
    // All fields have no size = no size
    struct Baz {
        foo: Foo,
        qux: (),      // empty tuple has no size
        baz: [u8; 0], // empty array has no size
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span>; <span class='comment'>// No fields = no size</span>

<span class='comment'>// All fields have no size = no size</span>
<span class='kw'>struct</span> <span class='ident'>Baz</span> {
    <span class='ident'>foo</span>: <span class='ident'>Foo</span>,
    <span class='ident'>qux</span>: (),      <span class='comment'>// empty tuple has no size</span>
    <span class='ident'>baz</span>: [<span class='ident'>u8</span>; <span class='number'>0</span>], <span class='comment'>// empty array has no size</span>
}</pre>

<p>On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.
However as with many curious layout choices in Rust, their potential is realized
in a generic context: Rust largely understands that any operation that  produces
or stores a ZST can be reduced to a no-op. First off, storing it  doesn&#39;t even
make sense -- it doesn&#39;t occupy any space. Also there&#39;s only one  value of that
type, so anything that loads it can just produce it from the  aether -- which is
also a no-op since it doesn&#39;t occupy any space.</p>

<p>One of the most extreme example&#39;s of this is Sets and Maps. Given a
<code>Map&lt;Key, Value&gt;</code>, it is common to implement a <code>Set&lt;Key&gt;</code> as just a thin wrapper
around <code>Map&lt;Key, UselessJunk&gt;</code>. In many languages, this would necessitate
allocating space for UselessJunk and doing work to store and load UselessJunk
only to discard it. Proving this unnecessary would be a difficult analysis for
the compiler.</p>

<p>However in Rust, we can just say that  <code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>. Now Rust
statically knows that every load and store is useless, and no allocation has any
size. The result is that the monomorphized code is basically a custom
implementation of a HashSet with none of the overhead that HashMap would have to
support values.</p>

<p>Safe code need not worry about ZSTs, but <em>unsafe</em> code must be careful about the
consequence of types with no size. In particular, pointer offsets are no-ops,
and standard allocators (including jemalloc, the one used by default in Rust)
may return <code>nullptr</code> when a zero-sized allocation is requested, which is
indistinguishable from out of memory.</p>

<h1 id='empty-types' class='section-header'><a href='#empty-types'>Empty Types</a></h1>
<p>Rust also enables types to be declared that <em>cannot even be instantiated</em>. These
types can only be talked about at the type level, and never at the value level.
Empty types can be declared by specifying an enum with no variants:</p>
<span class='rusttest'>fn main() {
    enum Void {} // No variants = EMPTY
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Void</span> {} <span class='comment'>// No variants = EMPTY</span></pre>

<p>Empty types are even more marginal than ZSTs. The primary motivating example for
Void types is type-level unreachability. For instance, suppose an API needs to
return a Result in general, but a specific case actually is infallible. It&#39;s
actually possible to communicate this at the type level by returning a
<code>Result&lt;T, Void&gt;</code>. Consumers of the API can confidently unwrap such a Result
knowing that it&#39;s <em>statically impossible</em> for this value to be an <code>Err</code>, as
this would require providing a value of type <code>Void</code>.</p>

<p>In principle, Rust can do some interesting analyses and optimizations based
on this fact. For instance, <code>Result&lt;T, Void&gt;</code> could be represented as just <code>T</code>,
because the <code>Err</code> case doesn&#39;t actually exist. The following <em>could</em> also
compile:</p>
<span class='rusttest'>fn main() {
    enum Void {}
    
    let res: Result&lt;u32, Void&gt; = Ok(0);
    
    // Err doesn&#39;t exist anymore, so Ok is actually irrefutable.
    let Ok(num) = res;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Void</span> {}

<span class='kw'>let</span> <span class='ident'>res</span>: <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>u32</span>, <span class='ident'>Void</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>Ok</span>(<span class='number'>0</span>);

<span class='comment'>// Err doesn&#39;t exist anymore, so Ok is actually irrefutable.</span>
<span class='kw'>let</span> <span class='prelude-val'>Ok</span>(<span class='ident'>num</span>) <span class='op'>=</span> <span class='ident'>res</span>;</pre>

<p>But neither of these tricks work today, so all Void types get you is
the ability to be confident that certain situations are statically impossible.</p>

<p>One final subtle detail about empty types is that raw pointers to them are
actually valid to construct, but dereferencing them is Undefined Behavior
because that doesn&#39;t actually make sense. That is, you could model C&#39;s <code>void *</code>
type with <code>*const Void</code>, but this doesn&#39;t necessarily gain anything over using
e.g. <code>*const ()</code>, which <em>is</em> safe to randomly dereference.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>