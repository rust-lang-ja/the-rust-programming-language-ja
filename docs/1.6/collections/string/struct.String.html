<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `String` struct in crate `collections`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, String">

    <title>collections::string::String - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="https://doc.rust-lang.org/favicon.ico">
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        <a href='../../collections/index.html'><img src='https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>collections</a>::<wbr><a href='index.html'>string</a></p><script>window.sidebarCurrent = {name: 'String', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>collections</a>::<wbr><a href='index.html'>string</a>::<wbr><a class='struct' href=''>String</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-3589' class='srclink' href='../../src/collections/string.rs.html#225-227' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct String {
    // some fields omitted
}</pre><div class='docblock'><p>A UTF-8 encoded, growable string.</p>

<p>The <code>String</code> type is the most common string type that has ownership over the
contents of the string. It has a close relationship with its borrowed
counterpart, the primitive <a href="../primitive.str.html"><code>str</code></a>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<p>You can create a <code>String</code> from a literal string with <code>String::from</code>:</p>
<span class='rusttest'>fn main() {
    let hello = String::from(&quot;Hello, world!&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;Hello, world!&quot;</span>);</pre>

<p>You can append a [<code>char</code>] to a <code>String</code> with the <a href="#method.push"><code>push()</code></a> method, and
append a <a href="../primitive.str.html"><code>&amp;str</code></a> with the <a href="#method.push_str"><code>push_str()</code></a> method:</p>
<span class='rusttest'>fn main() {
    let mut hello = String::from(&quot;Hello, &quot;);
    
    hello.push(&#39;w&#39;);
    hello.push_str(&quot;orld!&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;Hello, &quot;</span>);

<span class='ident'>hello</span>.<span class='ident'>push</span>(<span class='string'>&#39;w&#39;</span>);
<span class='ident'>hello</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;orld!&quot;</span>);</pre>

<p>If you have a vector of UTF-8 bytes, you can create a <code>String</code> from it with
the <a href="#method.from_utf8"><code>from_utf8()</code></a> method:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    // We know these bytes are valid, so we&#39;ll use `unwrap()`.
    let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
    
    assert_eq!(&quot;üíñ&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='comment'>// We know these bytes are valid, so we&#39;ll use `unwrap()`.</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;üíñ&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>

<h1 id='utf-8' class='section-header'><a href='#utf-8'>UTF-8</a></h1>
<p><code>String</code>s are always valid UTF-8. This has a few implications, the first of
which is that if you need a non-UTF-8 string, consider <a href="../ffi/struct.OsString.html"><code>OsString</code></a>. It is
similar, but without the UTF-8 constraint. The second implication is that
you cannot index into a <code>String</code>:</p>
<span class='rusttest'>fn main() {
    let s = &quot;hello&quot;;
    
    println!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The first letter of s is {}&quot;</span>, <span class='ident'>s</span>[<span class='number'>0</span>]); <span class='comment'>// ERROR!!!</span></pre>

<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding
does not allow us to do this. Furtheremore, it&#39;s not clear what sort of
thing the index should return: a byte, a codepoint, or a grapheme cluster.
The <a href="#method.as_bytes"><code>as_bytes()</code></a> and <a href="#method.chars"><code>chars()</code></a> methods return iterators over the first
two, respectively.</p>

<h1 id='deref' class='section-header'><a href='#deref'>Deref</a></h1>
<p><code>String</code>s implement <a href="../ops/trait.Deref.html"><code>Deref</code></a><code>&lt;Target=str&gt;</code>, and so inherit all of <a href="../primitive.str.html"><code>str</code></a>&#39;s
methods. In addition, this means that you can pass a <code>String</code> to any
function which takes a <a href="../primitive.str.html"><code>&amp;str</code></a> by using an ampersand (<code>&amp;</code>):</p>
<span class='rusttest'>fn main() {
    fn takes_str(s: &amp;str) { }
    
    let s = String::from(&quot;Hello&quot;);
    
    takes_str(&amp;s);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>takes_str</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) { }

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;Hello&quot;</span>);

<span class='ident'>takes_str</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);</pre>

<p>This will create a <a href="../primitive.str.html"><code>&amp;str</code></a> from the <code>String</code> and pass it in. This
conversion is very inexpensive, and so generally, functions will accept
<a href="../primitive.str.html"><code>&amp;str</code></a>s as arguments unless they need a <code>String</code> for some specific reason.</p>

<h1 id='representation' class='section-header'><a href='#representation'>Representation</a></h1>
<p>A <code>String</code> is made up of three components: a pointer to some bytes, a
length, and a capacity. The pointer points to an internal buffer <code>String</code>
uses to store its data. The length is the number of bytes currently stored
in the buffer, and the capacity is the size of the buffer in bytes. As such,
the length will always be less than or equal to the capacity.</p>

<p>This buffer is always stored on the heap.</p>

<p>You can look at these with the <a href="#method.as_ptr"><code>as_ptr()</code></a>, [<code>len()</code>], and [<code>capacity()</code>]
methods:</p>
<span class='rusttest'>fn main() {
    use std::mem;
    
    let story = String::from(&quot;Once upon a time...&quot;);
    
    let ptr = story.as_ptr();
    let len = story.len();
    let capacity = story.capacity();
    
    // story has thirteen bytes
    assert_eq!(19, len);
    
    // Now that we have our parts, we throw the story away.
    mem::forget(story);
    
    // We can re-build a String out of ptr, len, and capacity. This is all
    // unsafe becuase we are responsible for making sure the components are
    // valid:
    let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;
    
    assert_eq!(String::from(&quot;Once upon a time...&quot;), s);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;

<span class='kw'>let</span> <span class='ident'>story</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;Once upon a time...&quot;</span>);

<span class='kw'>let</span> <span class='ident'>ptr</span> <span class='op'>=</span> <span class='ident'>story</span>.<span class='ident'>as_ptr</span>();
<span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='ident'>story</span>.<span class='ident'>len</span>();
<span class='kw'>let</span> <span class='ident'>capacity</span> <span class='op'>=</span> <span class='ident'>story</span>.<span class='ident'>capacity</span>();

<span class='comment'>// story has thirteen bytes</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>19</span>, <span class='ident'>len</span>);

<span class='comment'>// Now that we have our parts, we throw the story away.</span>
<span class='ident'>mem</span>::<span class='ident'>forget</span>(<span class='ident'>story</span>);

<span class='comment'>// We can re-build a String out of ptr, len, and capacity. This is all</span>
<span class='comment'>// unsafe becuase we are responsible for making sure the components are</span>
<span class='comment'>// valid:</span>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>String</span>::<span class='ident'>from_raw_parts</span>(<span class='ident'>ptr</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _, <span class='ident'>len</span>, <span class='ident'>capacity</span>) } ;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;Once upon a time...&quot;</span>), <span class='ident'>s</span>);</pre>

<p>[<code>len()</code>]: # method.len
[<code>capacity()</code>]: # method.capacity</p>

<p>If a <code>String</code> has enough capacity, adding elements to it will not
re-allocate. For example, consider this program:</p>
<span class='rusttest'>fn main() {
    let mut s = String::new();
    
    println!(&quot;{}&quot;, s.capacity());
    
    for _ in 0..5 {
        s.push_str(&quot;hello&quot;);
        println!(&quot;{}&quot;, s.capacity());
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>.<span class='ident'>capacity</span>());

<span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>5</span> {
    <span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;hello&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>.<span class='ident'>capacity</span>());
}</pre>

<p>This will output the following:</p>

<pre><code class="language-text">0
5
10
20
20
40
</code></pre>

<p>At first, we have no memory allocated at all, but as we append to the
string, it increases its capacity appropriately. If we instead use the
<a href="#method.with_capacity"><code>with_capacity()</code></a> method to allocate the correct capacity initially:</p>
<span class='rusttest'>fn main() {
    let mut s = String::with_capacity(25);
    
    println!(&quot;{}&quot;, s.capacity());
    
    for _ in 0..5 {
        s.push_str(&quot;hello&quot;);
        println!(&quot;{}&quot;, s.capacity());
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>with_capacity</span>(<span class='number'>25</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>.<span class='ident'>capacity</span>());

<span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>5</span> {
    <span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;hello&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>.<span class='ident'>capacity</span>());
}</pre>

<p>We end up with a different output:</p>

<pre><code class="language-text">25
25
25
25
25
25
</code></pre>

<p>Here, there&#39;s no need to allocate more memory inside the loop.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>() -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<div class='docblock'><p>Creates a new string buffer initialized with the empty string.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1><span class='rusttest'>fn main() {
    #![allow(unused_mut)]
    let mut s = String::new();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();</pre>
</div><h4 id='method.with_capacity' class='method'><code>fn <a href='#method.with_capacity' class='fnname'>with_capacity</a>(capacity: usize) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<div class='docblock'><p>Creates a new string buffer with the given capacity.
The string will be able to hold exactly <code>capacity</code> bytes without
reallocating. If <code>capacity</code> is 0, the string will not allocate.</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::with_capacity(10);
    
    // The String contains no chars, even though it has capacity for more
    assert_eq!(s.len(), 0);
    
    // These are all done without reallocating...
    let cap = s.capacity();
    for i in 0..10 {
        s.push(&#39;a&#39;);
    }
    
    assert_eq!(s.capacity(), cap);
    
    // ...but this may make the vector reallocate
    s.push(&#39;a&#39;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);

<span class='comment'>// The String contains no chars, even though it has capacity for more</span>
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>len</span>(), <span class='number'>0</span>);

<span class='comment'>// These are all done without reallocating...</span>
<span class='kw'>let</span> <span class='ident'>cap</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>capacity</span>();
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
    <span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;a&#39;</span>);
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>(), <span class='ident'>cap</span>);

<span class='comment'>// ...but this may make the vector reallocate</span>
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;a&#39;</span>);</pre>
</div><h4 id='method.from_utf8' class='method'><code>fn <a href='#method.from_utf8' class='fnname'>from_utf8</a>(vec: <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;u8&gt;) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>, <a class='struct' href='../../collections/string/struct.FromUtf8Error.html' title='collections::string::FromUtf8Error'>FromUtf8Error</a>&gt;</code></h4>
<div class='docblock'><p>Converts a vector of bytes to a <code>String</code>.</p>

<p>A string slice (<code>&amp;str</code>) is made of bytes (<code>u8</code>), and a vector of bytes
(<code>Vec&lt;u8&gt;</code>) is made of bytes, so this function converts between the
two. Not all byte slices are valid <code>String</code>s, however: <code>String</code>
requires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that
the bytes are valid UTF-8, and then does the conversion.</p>

<p>If you are sure that the byte slice is valid UTF-8, and you don&#39;t want
to incur the overhead of the validity check, there is an unsafe version
of this function, <a href="struct.String.html#method.from_utf8_unchecked"><code>from_utf8_unchecked()</code></a>, which has the
same behavior but skips the check.</p>

<p>This method will take care to not copy the vector, for efficiency&#39;s
sake.</p>

<p>If you need a <code>&amp;str</code> instead of a <code>String</code>, consider
<a href="../str/fn.from_utf8.html"><code>str::from_utf8()</code></a>.</p>

<h1 id='failure' class='section-header'><a href='#failure'>Failure</a></h1>
<p>Returns <code>Err</code> if the slice is not UTF-8 with a description as to why the
provided bytes are not UTF-8. The vector you moved in is also included.</p>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<p>Basic usage:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    // We know these bytes are valid, so we&#39;ll use `unwrap()`.
    let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
    
    assert_eq!(&quot;üíñ&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='comment'>// We know these bytes are valid, so we&#39;ll use `unwrap()`.</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;üíñ&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>

<p>Incorrect bytes:</p>
<span class='rusttest'>fn main() {
    // some invalid bytes, in a vector
    let sparkle_heart = vec![0, 159, 146, 150];
    
    assert!(String::from_utf8(sparkle_heart).is_err());
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some invalid bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>is_err</span>());</pre>

<p>See the docs for <a href="struct.FromUtf8Error.html"><code>FromUtf8Error</code></a> for more details on what you
can do with this error.</p>
</div><h4 id='method.from_utf8_lossy' class='method'><code>fn <a href='#method.from_utf8_lossy' class='fnname'>from_utf8_lossy</a>&lt;'a&gt;(v: &amp;'a [u8]) -&gt; <a class='enum' href='../../collections/borrow/enum.Cow.html' title='collections::borrow::Cow'>Cow</a>&lt;'a, str&gt;</code></h4>
<div class='docblock'><p>Converts a slice of bytes to a <code>String</code>, including invalid characters.</p>

<p>A string slice (<code>&amp;str</code>) is made of bytes (<code>u8</code>), and a slice of bytes
(<code>&amp;[u8]</code>) is made of bytes, so this function converts between the two.
Not all byte slices are valid string slices, however: <code>&amp;str</code> requires
that it is valid UTF-8. During this conversion, <code>from_utf8_lossy()</code>
will replace any invalid UTF-8 sequences with
<code>U+FFFD REPLACEMENT CHARACTER</code>, which looks like this: ÔøΩ</p>

<p>If you are sure that the byte slice is valid UTF-8, and you don&#39;t want
to incur the overhead of the conversion, there is an unsafe version
of this function, <a href="struct.String.html#method.from_utf8_unchecked"><code>from_utf8_unchecked()</code></a>, which has the
same behavior but skips the checks.</p>

<p>If you need a <code>&amp;str</code> instead of a <code>String</code>, consider
<a href="../str/fn.from_utf8.html"><code>str::from_utf8()</code></a>.</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<p>Basic usage:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    // We know these bytes are valid, so we&#39;ll use `unwrap()`.
    let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();
    
    assert_eq!(&quot;üíñ&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='comment'>// We know these bytes are valid, so we&#39;ll use `unwrap()`.</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8</span>(<span class='ident'>sparkle_heart</span>).<span class='ident'>unwrap</span>();

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;üíñ&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>

<p>Incorrect bytes:</p>
<span class='rusttest'>fn main() {
    // some invalid bytes
    let input = b&quot;Hello \xF0\x90\x80World&quot;;
    let output = String::from_utf8_lossy(input);
    
    assert_eq!(&quot;Hello ÔøΩWorld&quot;, output);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some invalid bytes</span>
<span class='kw'>let</span> <span class='ident'>input</span> <span class='op'>=</span> <span class='string'>b&quot;Hello \xF0\x90\x80World&quot;</span>;
<span class='kw'>let</span> <span class='ident'>output</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_utf8_lossy</span>(<span class='ident'>input</span>);

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;Hello ÔøΩWorld&quot;</span>, <span class='ident'>output</span>);</pre>
</div><h4 id='method.from_utf16' class='method'><code>fn <a href='#method.from_utf16' class='fnname'>from_utf16</a>(v: &amp;[u16]) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>, <a class='struct' href='../../collections/string/struct.FromUtf16Error.html' title='collections::string::FromUtf16Error'>FromUtf16Error</a>&gt;</code></h4>
<div class='docblock'><p>Decode a UTF-16 encoded vector <code>v</code> into a <code>String</code>, returning <code>None</code>
if <code>v</code> contains any invalid data.</p>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1><span class='rusttest'>fn main() {
    // ùÑûmusic
    let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
              0x0073, 0x0069, 0x0063];
    assert_eq!(String::from_utf16(v).unwrap(),
               &quot;ùÑûmusic&quot;.to_string());
    
    // ùÑûmu&lt;invalid&gt;ic
    let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
              0xD800, 0x0069, 0x0063];
    assert!(String::from_utf16(v).is_err());
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// ùÑûmusic</span>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0xD834</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x006d</span>, <span class='number'>0x0075</span>,
          <span class='number'>0x0073</span>, <span class='number'>0x0069</span>, <span class='number'>0x0063</span>];
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf16</span>(<span class='ident'>v</span>).<span class='ident'>unwrap</span>(),
           <span class='string'>&quot;ùÑûmusic&quot;</span>.<span class='ident'>to_string</span>());

<span class='comment'>// ùÑûmu&lt;invalid&gt;ic</span>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0xD834</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x006d</span>, <span class='number'>0x0075</span>,
          <span class='number'>0xD800</span>, <span class='number'>0x0069</span>, <span class='number'>0x0063</span>];
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf16</span>(<span class='ident'>v</span>).<span class='ident'>is_err</span>());</pre>
</div><h4 id='method.from_utf16_lossy' class='method'><code>fn <a href='#method.from_utf16_lossy' class='fnname'>from_utf16_lossy</a>(v: &amp;[u16]) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<div class='docblock'><p>Decode a UTF-16 encoded vector <code>v</code> into a string, replacing
invalid data with the replacement character (U+FFFD).</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1><span class='rusttest'>fn main() {
    // ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;
    let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
              0x0073, 0xDD1E, 0x0069, 0x0063,
              0xD834];
    
    assert_eq!(String::from_utf16_lossy(v),
               &quot;ùÑûmus\u{FFFD}ic\u{FFFD}&quot;.to_string());
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;</span>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>0xD834</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x006d</span>, <span class='number'>0x0075</span>,
          <span class='number'>0x0073</span>, <span class='number'>0xDD1E</span>, <span class='number'>0x0069</span>, <span class='number'>0x0063</span>,
          <span class='number'>0xD834</span>];

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>String</span>::<span class='ident'>from_utf16_lossy</span>(<span class='ident'>v</span>),
           <span class='string'>&quot;ùÑûmus\u{FFFD}ic\u{FFFD}&quot;</span>.<span class='ident'>to_string</span>());</pre>
</div><h4 id='method.from_raw_parts' class='method'><code>unsafe fn <a href='#method.from_raw_parts' class='fnname'>from_raw_parts</a>(buf: *mut u8, length: usize, capacity: usize) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<div class='docblock'><p>Creates a new <code>String</code> from a length, capacity, and pointer.</p>

<h1 id='safety' class='section-header'><a href='#safety'>Safety</a></h1>
<p>This is <em>very</em> unsafe because:</p>

<ul>
<li>We call <code>Vec::from_raw_parts</code> to get a <code>Vec&lt;u8&gt;</code>. Therefore, this
function inherits all of its unsafety, see <a href="../vec/struct.Vec.html#method.from_raw_parts">its
documentation</a>
for the invariants it expects, they also apply to this function.</li>
<li>We assume that the <code>Vec</code> contains valid UTF-8.</li>
</ul>
</div><h4 id='method.from_utf8_unchecked' class='method'><code>unsafe fn <a href='#method.from_utf8_unchecked' class='fnname'>from_utf8_unchecked</a>(bytes: <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;u8&gt;) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<div class='docblock'><p>Converts a vector of bytes to a <code>String</code> without checking that the
string contains valid UTF-8.</p>

<p>See the safe version, <a href="struct.String.html#method.from_utf8"><code>from_utf8()</code></a>, for more.</p>

<h1 id='safety-1' class='section-header'><a href='#safety-1'>Safety</a></h1>
<p>This function is unsafe because it does not check that the bytes passed to
it are valid UTF-8. If this constraint is violated, undefined behavior
results, as the rest of Rust assumes that <code>String</code>s are valid UTF-8.</p>

<h1 id='examples-7' class='section-header'><a href='#examples-7'>Examples</a></h1>
<p>Basic usage:</p>
<span class='rusttest'>fn main() {
    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];
    
    let sparkle_heart = unsafe {
        String::from_utf8_unchecked(sparkle_heart)
    };
    
    assert_eq!(&quot;üíñ&quot;, sparkle_heart);
    
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// some bytes, in a vector</span>
<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>240</span>, <span class='number'>159</span>, <span class='number'>146</span>, <span class='number'>150</span>];

<span class='kw'>let</span> <span class='ident'>sparkle_heart</span> <span class='op'>=</span> <span class='kw'>unsafe</span> {
    <span class='ident'>String</span>::<span class='ident'>from_utf8_unchecked</span>(<span class='ident'>sparkle_heart</span>)
};

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;üíñ&quot;</span>, <span class='ident'>sparkle_heart</span>);</pre>
</div><h4 id='method.into_bytes' class='method'><code>fn <a href='#method.into_bytes' class='fnname'>into_bytes</a>(self) -&gt; <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Returns the underlying byte buffer, encoded as UTF-8.</p>

<h1 id='examples-8' class='section-header'><a href='#examples-8'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::from(&quot;hello&quot;);
    let bytes = s.into_bytes();
    assert_eq!(bytes, [104, 101, 108, 108, 111]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='kw'>let</span> <span class='ident'>bytes</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>into_bytes</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>bytes</span>, [<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);</pre>
</div><h4 id='method.as_str' class='method'><code>fn <a href='#method.as_str' class='fnname'>as_str</a>(&amp;self) -&gt; &amp;str</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>convert</code> <a href="https://github.com/rust-lang/rust/issues/27729">#27729</a>)<p>: waiting on RFC revision</p>
</em></div><div class='docblock'><p>Extracts a string slice containing the entire string.</p>
</div><h4 id='method.push_str' class='method'><code>fn <a href='#method.push_str' class='fnname'>push_str</a>(&amp;mut self, string: &amp;str)</code></h4>
<div class='docblock'><p>Pushes the given string onto this string buffer.</p>

<h1 id='examples-9' class='section-header'><a href='#examples-9'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
    assert_eq!(s, &quot;foobar&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;bar&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;foobar&quot;</span>);</pre>
</div><h4 id='method.capacity' class='method'><code>fn <a href='#method.capacity' class='fnname'>capacity</a>(&amp;self) -&gt; usize</code></h4>
<div class='docblock'><p>Returns the number of bytes that this string buffer can hold without
reallocating.</p>

<h1 id='examples-10' class='section-header'><a href='#examples-10'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::with_capacity(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>with_capacity</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);</pre>
</div><h4 id='method.reserve' class='method'><code>fn <a href='#method.reserve' class='fnname'>reserve</a>(&amp;mut self, additional: usize)</code></h4>
<div class='docblock'><p>Reserves capacity for at least <code>additional</code> more bytes to be inserted
in the given <code>String</code>. The collection may reserve more space to avoid
frequent reallocations.</p>

<h1 id='panics' class='section-header'><a href='#panics'>Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id='examples-11' class='section-header'><a href='#examples-11'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    s.reserve(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='ident'>s</span>.<span class='ident'>reserve</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);</pre>
</div><h4 id='method.reserve_exact' class='method'><code>fn <a href='#method.reserve_exact' class='fnname'>reserve_exact</a>(&amp;mut self, additional: usize)</code></h4>
<div class='docblock'><p>Reserves the minimum capacity for exactly <code>additional</code> more bytes to be
inserted in the given <code>String</code>. Does nothing if the capacity is already
sufficient.</p>

<p>Note that the allocator may give the collection more space than it
requests. Therefore capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>

<h1 id='panics-1' class='section-header'><a href='#panics-1'>Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 id='examples-12' class='section-header'><a href='#examples-12'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::new();
    s.reserve_exact(10);
    assert!(s.capacity() &gt;= 10);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='ident'>s</span>.<span class='ident'>reserve_exact</span>(<span class='number'>10</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>10</span>);</pre>
</div><h4 id='method.shrink_to_fit' class='method'><code>fn <a href='#method.shrink_to_fit' class='fnname'>shrink_to_fit</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Shrinks the capacity of this string buffer to match its length.</p>

<h1 id='examples-13' class='section-header'><a href='#examples-13'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.reserve(100);
    assert!(s.capacity() &gt;= 100);
    s.shrink_to_fit();
    assert_eq!(s.capacity(), 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>reserve</span>(<span class='number'>100</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>() <span class='op'>&gt;=</span> <span class='number'>100</span>);
<span class='ident'>s</span>.<span class='ident'>shrink_to_fit</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>capacity</span>(), <span class='number'>3</span>);</pre>
</div><h4 id='method.push' class='method'><code>fn <a href='#method.push' class='fnname'>push</a>(&amp;mut self, ch: char)</code></h4>
<div class='docblock'><p>Adds the given character to the end of the string.</p>

<h1 id='examples-14' class='section-header'><a href='#examples-14'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;abc&quot;);
    s.push(&#39;1&#39;);
    s.push(&#39;2&#39;);
    s.push(&#39;3&#39;);
    assert_eq!(s, &quot;abc123&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;abc&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;1&#39;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;2&#39;</span>);
<span class='ident'>s</span>.<span class='ident'>push</span>(<span class='string'>&#39;3&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;abc123&quot;</span>);</pre>
</div><h4 id='method.as_bytes' class='method'><code>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; &amp;[u8]</code></h4>
<div class='docblock'><p>Works with the underlying buffer as a byte slice.</p>

<h1 id='examples-15' class='section-header'><a href='#examples-15'>Examples</a></h1><span class='rusttest'>fn main() {
    let s = String::from(&quot;hello&quot;);
    assert_eq!(s.as_bytes(), [104, 101, 108, 108, 111]);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>(), [<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);</pre>
</div><h4 id='method.truncate' class='method'><code>fn <a href='#method.truncate' class='fnname'>truncate</a>(&amp;mut self, new_len: usize)</code></h4>
<div class='docblock'><p>Shortens a string to the specified length.</p>

<h1 id='panics-2' class='section-header'><a href='#panics-2'>Panics</a></h1>
<p>Panics if <code>new_len</code> &gt; current length,
or if <code>new_len</code> is not a character boundary.</p>

<h1 id='examples-16' class='section-header'><a href='#examples-16'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.truncate(2);
    assert_eq!(s, &quot;he&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='ident'>s</span>.<span class='ident'>truncate</span>(<span class='number'>2</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;he&quot;</span>);</pre>
</div><h4 id='method.pop' class='method'><code>fn <a href='#method.pop' class='fnname'>pop</a>(&amp;mut self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;char&gt;</code></h4>
<div class='docblock'><p>Removes the last character from the string buffer and returns it.
Returns <code>None</code> if this string buffer is empty.</p>

<h1 id='examples-17' class='section-header'><a href='#examples-17'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    assert_eq!(s.pop(), Some(&#39;o&#39;));
    assert_eq!(s.pop(), Some(&#39;o&#39;));
    assert_eq!(s.pop(), Some(&#39;f&#39;));
    assert_eq!(s.pop(), None);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;o&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;o&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>Some</span>(<span class='string'>&#39;f&#39;</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>pop</span>(), <span class='prelude-val'>None</span>);</pre>
</div><h4 id='method.remove' class='method'><code>fn <a href='#method.remove' class='fnname'>remove</a>(&amp;mut self, idx: usize) -&gt; char</code></h4>
<div class='docblock'><p>Removes the character from the string buffer at byte position <code>idx</code> and
returns it.</p>

<h1 id='warning' class='section-header'><a href='#warning'>Warning</a></h1>
<p>This is an O(n) operation as it requires copying every element in the
buffer.</p>

<h1 id='panics-3' class='section-header'><a href='#panics-3'>Panics</a></h1>
<p>If <code>idx</code> does not lie on a character boundary, or if it is out of
bounds, then this function will panic.</p>

<h1 id='examples-18' class='section-header'><a href='#examples-18'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;foo&quot;);
    assert_eq!(s.remove(0), &#39;f&#39;);
    assert_eq!(s.remove(1), &#39;o&#39;);
    assert_eq!(s.remove(0), &#39;o&#39;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>0</span>), <span class='string'>&#39;f&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>1</span>), <span class='string'>&#39;o&#39;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>remove</span>(<span class='number'>0</span>), <span class='string'>&#39;o&#39;</span>);</pre>
</div><h4 id='method.insert' class='method'><code>fn <a href='#method.insert' class='fnname'>insert</a>(&amp;mut self, idx: usize, ch: char)</code></h4>
<div class='docblock'><p>Inserts a character into the string buffer at byte position <code>idx</code>.</p>

<h1 id='warning-1' class='section-header'><a href='#warning-1'>Warning</a></h1>
<p>This is an O(n) operation as it requires copying every element in the
buffer.</p>

<h1 id='panics-4' class='section-header'><a href='#panics-4'>Panics</a></h1>
<p>If <code>idx</code> does not lie on a character boundary or is out of bounds, then
this function will panic.</p>
</div><h4 id='method.as_mut_vec' class='method'><code>unsafe fn <a href='#method.as_mut_vec' class='fnname'>as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;u8&gt;</code></h4>
<div class='docblock'><p>Views the string buffer as a mutable sequence of bytes.</p>

<p>This is unsafe because it does not check
to ensure that the resulting string will be valid UTF-8.</p>

<h1 id='examples-19' class='section-header'><a href='#examples-19'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    unsafe {
        let vec = s.as_mut_vec();
        assert!(vec == &amp;[104, 101, 108, 108, 111]);
        vec.reverse();
    }
    assert_eq!(s, &quot;olleh&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;hello&quot;</span>);
<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>vec</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>as_mut_vec</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>vec</span> <span class='op'>==</span> <span class='kw-2'>&amp;</span>[<span class='number'>104</span>, <span class='number'>101</span>, <span class='number'>108</span>, <span class='number'>108</span>, <span class='number'>111</span>]);
    <span class='ident'>vec</span>.<span class='ident'>reverse</span>();
}
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;olleh&quot;</span>);</pre>
</div><h4 id='method.len' class='method'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; usize</code></h4>
<div class='docblock'><p>Returns the number of bytes in this string.</p>

<h1 id='examples-20' class='section-header'><a href='#examples-20'>Examples</a></h1><span class='rusttest'>fn main() {
    let a = &quot;foo&quot;.to_string();
    assert_eq!(a.len(), 3);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='number'>3</span>);</pre>
</div><h4 id='method.is_empty' class='method'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; bool</code></h4>
<div class='docblock'><p>Returns true if the string contains no bytes</p>

<h1 id='examples-21' class='section-header'><a href='#examples-21'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut v = String::new();
    assert!(v.is_empty());
    v.push(&#39;a&#39;);
    assert!(!v.is_empty());
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>v</span>.<span class='ident'>is_empty</span>());
<span class='ident'>v</span>.<span class='ident'>push</span>(<span class='string'>&#39;a&#39;</span>);
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>v</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Truncates the string, returning it to 0 length.</p>

<h1 id='examples-22' class='section-header'><a href='#examples-22'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = &quot;foo&quot;.to_string();
    s.clear();
    assert!(s.is_empty());
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>s</span>.<span class='ident'>clear</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>s</span>.<span class='ident'>is_empty</span>());</pre>
</div><h4 id='method.drain' class='method'><code>fn <a href='#method.drain' class='fnname'>drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class='struct' href='../../collections/string/struct.Drain.html' title='collections::string::Drain'>Drain</a> <span class='where'>where R: <a class='trait' href='../../collections/range/trait.RangeArgument.html' title='collections::range::RangeArgument'>RangeArgument</a>&lt;usize&gt;</span></code></h4>
<div class='docblock'><p>Create a draining iterator that removes the specified range in the string
and yields the removed chars from start to end. The element range is
removed even if the iterator is not consumed until the end.</p>

<h1 id='panics-5' class='section-header'><a href='#panics-5'>Panics</a></h1>
<p>Panics if the starting point or end point are not on character boundaries,
or if they are out of bounds.</p>

<h1 id='examples-23' class='section-header'><a href='#examples-23'>Examples</a></h1><span class='rusttest'>fn main() {
    let mut s = String::from(&quot;Œ± is alpha, Œ≤ is beta&quot;);
    let beta_offset = s.find(&#39;Œ≤&#39;).unwrap_or(s.len());
    
    // Remove the range up until the Œ≤ from the string
    let t: String = s.drain(..beta_offset).collect();
    assert_eq!(t, &quot;Œ± is alpha, &quot;);
    assert_eq!(s, &quot;Œ≤ is beta&quot;);
    
    // A full range clears the string
    s.drain(..);
    assert_eq!(s, &quot;&quot;);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from</span>(<span class='string'>&quot;Œ± is alpha, Œ≤ is beta&quot;</span>);
<span class='kw'>let</span> <span class='ident'>beta_offset</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>find</span>(<span class='string'>&#39;Œ≤&#39;</span>).<span class='ident'>unwrap_or</span>(<span class='ident'>s</span>.<span class='ident'>len</span>());

<span class='comment'>// Remove the range up until the Œ≤ from the string</span>
<span class='kw'>let</span> <span class='ident'>t</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>drain</span>(..<span class='ident'>beta_offset</span>).<span class='ident'>collect</span>();
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>t</span>, <span class='string'>&quot;Œ± is alpha, &quot;</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;Œ≤ is beta&quot;</span>);

<span class='comment'>// A full range clears the string</span>
<span class='ident'>s</span>.<span class='ident'>drain</span>(..);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>s</span>, <span class='string'>&quot;&quot;</span>);</pre>
</div><h4 id='method.into_boxed_str' class='method'><code>fn <a href='#method.into_boxed_str' class='fnname'>into_boxed_str</a>(self) -&gt; <a class='struct' href='../../collections/boxed/struct.Box.html' title='collections::boxed::Box'>Box</a>&lt;str&gt;</code></h4>
<div class='docblock'><p>Converts the string into <code>Box&lt;str&gt;</code>.</p>

<p>Note that this will drop any excess capacity.</p>
</div><h4 id='method.into_boxed_slice' class='method'><code>fn <a href='#method.into_boxed_slice' class='fnname'>into_boxed_slice</a>(self) -&gt; <a class='struct' href='../../collections/boxed/struct.Box.html' title='collections::boxed::Box'>Box</a>&lt;str&gt;</code></h4>
<div class='stability'><em class='stab unstable deprecated'>Deprecated since 1.4.0<p>: renamed to <code>into_boxed_str</code></p>
</em></div><div class='docblock'><p>Converts the string into <code>Box&lt;str&gt;</code>.</p>

<p>Note that this will drop any excess capacity.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='../../collections/borrow/trait.Borrow.html' title='collections::borrow::Borrow'>Borrow</a>&lt;str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.borrow' class='method'><code>fn <a href='../../collections/borrow/trait.Borrow.html#method.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='../../core/clone/trait.Clone.html#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; Self</code></h4>
<h4 id='method.clone_from' class='method'><code>fn <a href='../../core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/iter/trait.FromIterator.html' title='core::iter::FromIterator'>FromIterator</a>&lt;char&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from_iter' class='method'><code>fn <a href='../../core/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=char&gt;&gt;(iterable: I) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../core/iter/trait.FromIterator.html' title='core::iter::FromIterator'>FromIterator</a>&lt;&amp;'a str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from_iter-1' class='method'><code>fn <a href='../../core/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a str&gt;&gt;(iterable: I) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/iter/trait.FromIterator.html' title='core::iter::FromIterator'>FromIterator</a>&lt;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from_iter-2' class='method'><code>fn <a href='../../core/iter/trait.FromIterator.html#method.from_iter' class='fnname'>from_iter</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>&gt;&gt;(iterable: I) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/iter/trait.Extend.html' title='core::iter::Extend'>Extend</a>&lt;char&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend' class='method'><code>fn <a href='../../core/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=char&gt;&gt;(&amp;mut self, iterable: I)</code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../core/iter/trait.Extend.html' title='core::iter::Extend'>Extend</a>&lt;&amp;'a char&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend-1' class='method'><code>fn <a href='../../core/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a char&gt;&gt;(&amp;mut self, iterable: I)</code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../core/iter/trait.Extend.html' title='core::iter::Extend'>Extend</a>&lt;&amp;'a str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend-2' class='method'><code>fn <a href='../../core/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=&amp;'a str&gt;&gt;(&amp;mut self, iterable: I)</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/iter/trait.Extend.html' title='core::iter::Extend'>Extend</a>&lt;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.extend-3' class='method'><code>fn <a href='../../core/iter/trait.Extend.html#method.extend' class='fnname'>extend</a>&lt;I: <a class='trait' href='../../core/iter/trait.IntoIterator.html' title='core::iter::IntoIterator'>IntoIterator</a>&lt;Item=<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>&gt;&gt;(&amp;mut self, iterable: I)</code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../collections/str/pattern/trait.Pattern.html' title='collections::str::pattern::Pattern'>Pattern</a>&lt;'a&gt; for &amp;'b <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='docblock'><p>A convenience impl that delegates to the impl for <code>&amp;str</code></p>
</div><div class='impl-items'><h4 id='assoc_type.Searcher' class='type'><code>type Searcher = &amp;'b str::Searcher</code></h4>
<h4 id='method.into_searcher' class='method'><code>fn <a href='../../collections/str/pattern/trait.Pattern.html#method.into_searcher' class='fnname'>into_searcher</a>(self, haystack: &amp;'a str) -&gt; &amp;'b str::Searcher</code></h4>
<h4 id='method.is_contained_in' class='method'><code>fn <a href='../../collections/str/pattern/trait.Pattern.html#method.is_contained_in' class='fnname'>is_contained_in</a>(self, haystack: &amp;'a str) -&gt; bool</code></h4>
<h4 id='method.is_prefix_of' class='method'><code>fn <a href='../../collections/str/pattern/trait.Pattern.html#method.is_prefix_of' class='fnname'>is_prefix_of</a>(self, haystack: &amp;'a str) -&gt; bool</code></h4>
<h4 id='method.is_suffix_of' class='method'><code>fn <a href='../../collections/str/pattern/trait.Pattern.html#method.is_suffix_of' class='fnname'>is_suffix_of</a>(self, haystack: &amp;'a str) -&gt; bool <span class='where'>where Self::<a class='trait' href='../../collections/str/pattern/trait.Pattern.html' title='collections::str::pattern::Pattern'>Searcher</a>: <a class='trait' href='../../collections/str/pattern/trait.ReverseSearcher.html' title='collections::str::pattern::ReverseSearcher'>ReverseSearcher</a>&lt;'a&gt;</span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; bool</code></h4>
<h4 id='method.ne' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; bool</code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq-1' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;str) -&gt; bool</code></h4>
<h4 id='method.ne-1' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;str) -&gt; bool</code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;&amp;'a str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq-2' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;&amp;'a str) -&gt; bool</code></h4>
<h4 id='method.ne-2' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;&amp;'a str) -&gt; bool</code></h4>
</div><h3 class='impl'><code>impl&lt;'a, 'b&gt; <a class='trait' href='../../core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;<a class='enum' href='../../collections/borrow/enum.Cow.html' title='collections::borrow::Cow'>Cow</a>&lt;'a, str&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.eq-3' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class='enum' href='../../collections/borrow/enum.Cow.html' title='collections::borrow::Cow'>Cow</a>&lt;'a, str&gt;) -&gt; bool</code></h4>
<h4 id='method.ne-3' class='method'><code>fn <a href='../../core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class='enum' href='../../collections/borrow/enum.Cow.html' title='collections::borrow::Cow'>Cow</a>&lt;'a, str&gt;) -&gt; bool</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/default/trait.Default.html' title='core::default::Default'>Default</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.default' class='method'><code>fn <a href='../../core/default/trait.Default.html#method.default' class='fnname'>default</a>() -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../collections/fmt/trait.Display.html' title='collections::fmt::Display'>Display</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='../../collections/fmt/trait.Display.html#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../collections/fmt/struct.Formatter.html' title='collections::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='../../collections/fmt/type.Result.html' title='collections::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../collections/fmt/trait.Debug.html' title='collections::fmt::Debug'>Debug</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.fmt-1' class='method'><code>fn <a href='../../collections/fmt/trait.Debug.html#method.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../collections/fmt/struct.Formatter.html' title='collections::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='../../collections/fmt/type.Result.html' title='collections::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.hash' class='method'><code>fn <a href='../../core/hash/trait.Hash.html#method.hash' class='fnname'>hash</a>&lt;H: <a class='trait' href='../../core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a>&gt;(&amp;self, hasher: &amp;mut H)</code></h4>
<h4 id='method.hash_slice' class='method'><code>fn <a href='../../core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class='where'>where H: <a class='trait' href='../../core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a></span></code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../core/ops/trait.Add.html' title='core::ops::Add'>Add</a>&lt;&amp;'a str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output' class='type'><code>type Output = <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
<h4 id='method.add' class='method'><code>fn <a href='../../core/ops/trait.Add.html#method.add' class='fnname'>add</a>(self, other: &amp;str) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='struct' href='../../core/ops/struct.Range.html' title='core::ops::Range'>Range</a>&lt;usize&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output-1' class='type'><code>type Output = str</code></h4>
<h4 id='method.index' class='method'><code>fn <a href='../../core/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../core/ops/struct.Range.html' title='core::ops::Range'>Range</a>&lt;usize&gt;) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='struct' href='../../core/ops/struct.RangeTo.html' title='core::ops::RangeTo'>RangeTo</a>&lt;usize&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output-2' class='type'><code>type Output = str</code></h4>
<h4 id='method.index-1' class='method'><code>fn <a href='../../core/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../core/ops/struct.RangeTo.html' title='core::ops::RangeTo'>RangeTo</a>&lt;usize&gt;) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='struct' href='../../core/ops/struct.RangeFrom.html' title='core::ops::RangeFrom'>RangeFrom</a>&lt;usize&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output-3' class='type'><code>type Output = str</code></h4>
<h4 id='method.index-2' class='method'><code>fn <a href='../../core/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, index: <a class='struct' href='../../core/ops/struct.RangeFrom.html' title='core::ops::RangeFrom'>RangeFrom</a>&lt;usize&gt;) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.Index.html' title='core::ops::Index'>Index</a>&lt;<a class='struct' href='../../core/ops/struct.RangeFull.html' title='core::ops::RangeFull'>RangeFull</a>&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Output-4' class='type'><code>type Output = str</code></h4>
<h4 id='method.index-3' class='method'><code>fn <a href='../../core/ops/trait.Index.html#method.index' class='fnname'>index</a>(&amp;self, _index: <a class='struct' href='../../core/ops/struct.RangeFull.html' title='core::ops::RangeFull'>RangeFull</a>) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../core/ops/struct.Range.html' title='core::ops::Range'>Range</a>&lt;usize&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut' class='method'><code>fn <a href='../../core/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../core/ops/struct.Range.html' title='core::ops::Range'>Range</a>&lt;usize&gt;) -&gt; &amp;mut str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../core/ops/struct.RangeTo.html' title='core::ops::RangeTo'>RangeTo</a>&lt;usize&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut-1' class='method'><code>fn <a href='../../core/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../core/ops/struct.RangeTo.html' title='core::ops::RangeTo'>RangeTo</a>&lt;usize&gt;) -&gt; &amp;mut str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../core/ops/struct.RangeFrom.html' title='core::ops::RangeFrom'>RangeFrom</a>&lt;usize&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut-2' class='method'><code>fn <a href='../../core/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, index: <a class='struct' href='../../core/ops/struct.RangeFrom.html' title='core::ops::RangeFrom'>RangeFrom</a>&lt;usize&gt;) -&gt; &amp;mut str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.IndexMut.html' title='core::ops::IndexMut'>IndexMut</a>&lt;<a class='struct' href='../../core/ops/struct.RangeFull.html' title='core::ops::RangeFull'>RangeFull</a>&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.index_mut-3' class='method'><code>fn <a href='../../core/ops/trait.IndexMut.html#method.index_mut' class='fnname'>index_mut</a>(&amp;mut self, _index: <a class='struct' href='../../core/ops/struct.RangeFull.html' title='core::ops::RangeFull'>RangeFull</a>) -&gt; &amp;mut str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.Deref.html' title='core::ops::Deref'>Deref</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Target' class='type'><code>type Target = str</code></h4>
<h4 id='method.deref' class='method'><code>fn <a href='../../core/ops/trait.Deref.html#method.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/ops/trait.DerefMut.html' title='core::ops::DerefMut'>DerefMut</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.deref_mut' class='method'><code>fn <a href='../../core/ops/trait.DerefMut.html#method.deref_mut' class='fnname'>deref_mut</a>(&amp;mut self) -&gt; &amp;mut str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../collections/str/trait.FromStr.html' title='collections::str::FromStr'>FromStr</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='assoc_type.Err' class='type'><code>type Err = <a class='enum' href='../../collections/string/enum.ParseError.html' title='collections::string::ParseError'>ParseError</a></code></h4>
<h4 id='method.from_str' class='method'><code>fn <a href='../../collections/str/trait.FromStr.html#method.from_str' class='fnname'>from_str</a>(s: &amp;str) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>, <a class='enum' href='../../collections/string/enum.ParseError.html' title='collections::string::ParseError'>ParseError</a>&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.as_ref' class='method'><code>fn <a href='../../core/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;str</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;[u8]&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.as_ref-1' class='method'><code>fn <a href='../../core/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;[u8]</code></h4>
</div><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../../core/convert/trait.From.html' title='core::convert::From'>From</a>&lt;&amp;'a str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.from' class='method'><code>fn <a href='../../core/convert/trait.From.html#method.from' class='fnname'>from</a>(s: &amp;'a str) -&gt; <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/convert/trait.Into.html' title='core::convert::Into'>Into</a>&lt;<a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;u8&gt;&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.into' class='method'><code>fn <a href='../../core/convert/trait.Into.html#method.into' class='fnname'>into</a>(self) -&gt; <a class='struct' href='../../collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;u8&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../collections/borrow/trait.IntoCow.html' title='collections::borrow::IntoCow'>IntoCow</a>&lt;'static, str&gt; for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.into_cow' class='method'><code>fn <a href='../../collections/borrow/trait.IntoCow.html#method.into_cow' class='fnname'>into_cow</a>(self) -&gt; <a class='enum' href='../../collections/borrow/enum.Cow.html' title='collections::borrow::Cow'>Cow</a>&lt;'static, str&gt;</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../collections/fmt/trait.Write.html' title='collections::fmt::Write'>Write</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.write_str' class='method'><code>fn <a href='../../collections/fmt/trait.Write.html#method.write_str' class='fnname'>write_str</a>(&amp;mut self, s: &amp;str) -&gt; <a class='type' href='../../collections/fmt/type.Result.html' title='collections::fmt::Result'>Result</a></code></h4>
<h4 id='method.write_char' class='method'><code>fn <a href='../../collections/fmt/trait.Write.html#method.write_char' class='fnname'>write_char</a>(&amp;mut self, c: char) -&gt; <a class='type' href='../../collections/fmt/type.Result.html' title='collections::fmt::Result'>Result</a></code></h4>
<h4 id='method.write_fmt' class='method'><code>fn <a href='../../collections/fmt/trait.Write.html#method.write_fmt' class='fnname'>write_fmt</a>(&amp;mut self, args: <a class='struct' href='../../collections/fmt/struct.Arguments.html' title='collections::fmt::Arguments'>Arguments</a>) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;(), <a class='struct' href='../../collections/fmt/struct.Error.html' title='collections::fmt::Error'>Error</a>&gt;</code></h4>
</div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><code>impl <a class='trait' href='../../core/cmp/trait.Ord.html' title='core::cmp::Ord'>Ord</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.cmp' class='method'><code>fn <a href='../../core/cmp/trait.Ord.html#method.cmp' class='fnname'>cmp</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; <a class='enum' href='../../core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../../core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'></div><h3 class='impl'><code>impl <a class='trait' href='../../core/cmp/trait.PartialOrd.html' title='core::cmp::PartialOrd'>PartialOrd</a> for <a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a></code></h3><div class='impl-items'><h4 id='method.partial_cmp' class='method'><code>fn <a href='../../core/cmp/trait.PartialOrd.html#method.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='enum' href='../../core/cmp/enum.Ordering.html' title='core::cmp::Ordering'>Ordering</a>&gt;</code></h4>
<h4 id='method.lt' class='method'><code>fn <a href='../../core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; bool</code></h4>
<h4 id='method.le' class='method'><code>fn <a href='../../core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; bool</code></h4>
<h4 id='method.gt' class='method'><code>fn <a href='../../core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; bool</code></h4>
<h4 id='method.ge' class='method'><code>fn <a href='../../core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, __arg_0: &amp;<a class='struct' href='../../collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; bool</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "collections";
        window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script defer src="../../search-index.js"></script>
</body>
</html>