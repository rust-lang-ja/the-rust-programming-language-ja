<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>トレイトオブジェクト</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a class='active' href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book/second-edition/">第2版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。第2版のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">トレイトオブジェクト</h1>
    <!-- % Trait Objects -->

<!-- When code involves polymorphism, there needs to be a mechanism to determine
which specific version is actually run. This is called ‘dispatch’. There are
two major forms of dispatch: static dispatch and dynamic dispatch. While Rust
favors static dispatch, it also supports dynamic dispatch through a mechanism
called ‘trait objects’. -->

<p>コードがポリモーフィズムを伴う場合、実際に実行するバージョンを決定するメカニズムが必要です。これは「ディスパッチ」(dispatch)と呼ばれます。ディスパッチには主に静的ディスパッチと動的ディスパッチという2つの形態があります。Rustは静的ディスパッチを支持している一方で、「トレイトオブジェクト」(trait objects)と呼ばれるメカニズムにより動的ディスパッチもサポートしています。</p>

<!-- ## Background -->

<h2 id='背景' class='section-header'><a href='#背景'>背景</a></h2>
<!-- For the rest of this chapter, we’ll need a trait and some implementations.
Let’s make a simple one, `Foo`. It has one method that is expected to return a
`String`. -->

<p>本章の後のために、トレイトとその実装が幾つか必要です。単純に <code>Foo</code> としましょう。これは <code>String</code> 型の値を返す関数を1つ持っています。</p>

<span class='rusttest'>fn main() {
    trait Foo {
    fn method(&amp;self) -&gt; String;
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span>;
}</pre>

<!-- We’ll also implement this trait for `u8` and `String`: -->

<p>また、このトレイトを <code>u8</code> と <code>String</code> に実装します。</p>

<span class='rusttest'>fn main() {
    trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>u8</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;u8: {}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>method</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>String</span> { <span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;string: {}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}</pre>

<!-- ## Static dispatch -->

<h2 id='静的ディスパッチ' class='section-header'><a href='#静的ディスパッチ'>静的ディスパッチ</a></h2>
<!-- We can use this trait to perform static dispatch with trait bounds: -->

<p>トレイト境界を使ってこのトレイトで静的ディスパッチが出来ます。</p>

<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something&lt;T: Foo&gt;(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something(x);
    do_something(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Foo</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>do_something</span>(<span class='ident'>x</span>);
    <span class='ident'>do_something</span>(<span class='ident'>y</span>);
}</pre>

<!-- Rust uses ‘monomorphization’ to perform static dispatch here. This means that
Rust will create a special version of `do_something()` for both `u8` and
`String`, and then replace the call sites with calls to these specialized
functions. In other words, Rust generates something like this: -->

<p>これはRustが <code>u8</code> と <code>String</code> それぞれ専用の <code>do_something()</code> を作成し、それら特殊化された関数を宛てがうように呼び出しの部分を書き換えるという意味です。（訳注: 作成された専用の <code>do_something()</code> は「特殊化された関数」(specialized function)と呼ばれます）</p>

<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something_u8(x);
    do_something_string(y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something_u8</span>(<span class='ident'>x</span>: <span class='ident'>u8</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>do_something_string</span>(<span class='ident'>x</span>: <span class='ident'>String</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();

    <span class='ident'>do_something_u8</span>(<span class='ident'>x</span>);
    <span class='ident'>do_something_string</span>(<span class='ident'>y</span>);
}</pre>

<!-- This has a great upside: static dispatch allows function calls to be
inlined because the callee is known at compile time, and inlining is
the key to good optimization. Static dispatch is fast, but it comes at
a tradeoff: ‘code bloat’, due to many copies of the same function
existing in the binary, one for each type. -->

<p>これは素晴らしい利点です。呼び出される関数はコンパイル時に分かっているため、静的ディスパッチは関数呼び出しをインライン化できます。インライン化は優れた最適化の鍵です。静的ディスパッチは高速ですが、バイナリ的には既にあるはずの同じ関数をそれぞれの型毎に幾つもコピーするため、トレードオフとして「コードの膨張」(code bloat)が発生してしまいます。</p>

<!-- Furthermore, compilers aren’t perfect and may “optimize” code to become slower.
For example, functions inlined too eagerly will bloat the instruction cache
(cache rules everything around us). This is part of the reason that `#[inline]`
and `#[inline(always)]` should be used carefully, and one reason why using a
dynamic dispatch is sometimes more efficient. -->

<p>その上、コンパイラは完璧ではなく、「最適化」したコードが遅くなってしまうこともあります。 例えば、あまりにも熱心にインライン化された関数は命令キャッシュを膨張させてしまいます（地獄の沙汰もキャッシュ次第）。それが <code>#[inline]</code> や <code>#[inline(always)]</code> を慎重に使うべきである理由の1つであり、時として動的ディスパッチが静的ディスパッチよりも効率的である1つの理由なのです。</p>

<!-- However, the common case is that it is more efficient to use static dispatch,
and one can always have a thin statically-dispatched wrapper function that does
a dynamic dispatch, but not vice versa, meaning static calls are more flexible.
The standard library tries to be statically dispatched where possible for this
reason. -->

<p>しかしながら、一般的なケースでは静的ディスパッチを使用する方が効率的であり、また、動的ディスパッチを行う薄い静的ディスパッチラッパ関数を実装することは常に可能ですが、その逆はできません。これは静的な呼び出しの方が柔軟性に富むことを示唆しています。標準ライブラリはこの理由から可能な限り静的ディスパッチで実装するよう心がけています。</p>

<blockquote>
<p>訳注: 「動的ディスパッチを行う薄い静的ディスパッチラッパ関数を実装することは常に可能だがその逆はできない」について</p>

<p>静的ディスパッチはコンパイル時に定まるのに対し、動的ディスパッチは実行時に結果が分かります。従って、動的ディスパッチが伴う処理を静的ディスパッチ関数でラッピングし、半静的なディスパッチとすることは常に可能（原文で「thin」と形容しているのはこのため）ですが、動的ディスパッチで遷移した値を元に静的ディスパッチを行うことはできないと言うわけです。</p>
</blockquote>

<h2 id='動的ディスパッチ' class='section-header'><a href='#動的ディスパッチ'>動的ディスパッチ</a></h2>
<!-- ## Dynamic dispatch -->

<!-- Rust provides dynamic dispatch through a feature called ‘trait objects’. Trait
objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of
*any* type that implements the given trait, where the precise type can only be
known at runtime. -->

<p>Rustは「トレイトオブジェクト」と呼ばれる機能によって動的ディスパッチを提供しています。トレイトオブジェクトは <code>&amp;Foo</code> か <code>Box&lt;Foo&gt;</code> の様に記述され、指定されたトレイトを実装する <em>あらゆる</em> 型の値を保持する通常の値です。ただし、その正確な型は実行時になって初めて判明します。</p>

<!-- A trait object can be obtained from a pointer to a concrete type that
implements the trait by *casting* it (e.g. `&x as &Foo`) or *coercing* it
(e.g. using `&x` as an argument to a function that takes `&Foo`). -->

<p>トレイトオブジェクトはトレイトを実装した具体的な型を指すポインタから <em>キャスト</em> する(e.g. <code>&amp;x as &amp;Foo</code> )か、 <em>型強制</em> する（e.g. <code>&amp;Foo</code> を取る関数の引数として <code>&amp;x</code> を用いる）ことで得られます。</p>

<!-- These trait object coercions and casts also work for pointers like `&mut T` to
`&mut Foo` and `Box<T>` to `Box<Foo>`, but that’s all at the moment. Coercions
and casts are identical. -->

<p>これらトレイトオブジェクトの型強制とキャストは <code>&amp;mut T</code> を <code>&amp;mut Foo</code> へ、 <code>Box&lt;T&gt;</code> を <code>Box&lt;Foo&gt;</code> へ、というようにどちらもポインタに対する操作ですが、今の所はこれだけです。型強制とキャストは同一です。</p>

<!-- This operation can be seen as ‘erasing’ the compiler’s knowledge about the
specific type of the pointer, and hence trait objects are sometimes referred to
as ‘type erasure’. -->

<p>この操作がまるでポインタのある型に関するコンパイラの記憶を「消去している」(erasing)ように見えることから、トレイトオブジェクトは時に「型消去」(type erasure)とも呼ばれます。</p>

<!-- Coming back to the example above, we can use the same trait to perform dynamic
dispatch with trait objects by casting: -->

<p>上記の例に立ち帰ると、キャストによるトレイトオブジェクトを用いた動的ディスパッチの実現にも同じトレイトが使用できます。</p>

<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&amp;x as &amp;Foo);
}
</span><pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u8</span>;
    <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>);
}</pre>

<!-- or by coercing: -->

<p>または型強制によって、</p>

<span class='rusttest'>trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hello&quot;.to_string();
    do_something(&amp;x);
}
</span><pre class='rust rust-example-rendered'>

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo</span>) {
    <span class='ident'>x</span>.<span class='ident'>method</span>();
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>do_something</span>(<span class='kw-2'>&amp;</span><span class='ident'>x</span>);
}</pre>

<!-- A function that takes a trait object is not specialized to each of the types
that implements `Foo`: only one copy is generated, often (but not always)
resulting in less code bloat. However, this comes at the cost of requiring
slower virtual function calls, and effectively inhibiting any chance of
inlining and related optimizations from occurring. -->

<p>トレイトオブジェクトを受け取った関数が <code>Foo</code> を実装した型ごとに特殊化されることはありません。関数は1つだけ生成され、多くの場合（とはいえ常にではありませんが）コードの膨張は少なく済みます。しかしながら、これは低速な仮想関数の呼び出しが必要となるため、実質的にインライン化とそれに関連する最適化の機会を阻害してしまいます。</p>

<!-- ### Why pointers? -->

<h3 id='何故ポインタなのか' class='section-header'><a href='#何故ポインタなのか'>何故ポインタなのか？</a></h3>
<!-- Rust does not put things behind a pointer by default, unlike many managed
languages, so types can have different sizes. Knowing the size of the value at
compile time is important for things like passing it as an argument to a
function, moving it about on the stack and allocating (and deallocating) space
on the heap to store it. -->

<p>Rustはガーベジコレクタによって管理される多くの言語とは異なり、デフォルトではポインタの参照先に値を配置するようなことはしませんから、型によってサイズが違います。関数へ引数として渡されるような値を、スタック領域へムーブしたり保存のためヒープ領域上にメモリをアロケート（デアロケートも同様）するには、コンパイル時に値のサイズを知っていることが重要となります。</p>

<!-- For `Foo`, we would need to have a value that could be at least either a
`String` (24 bytes) or a `u8` (1 byte), as well as any other type for which
dependent crates may implement `Foo` (any number of bytes at all). There’s no
way to guarantee that this last point can work if the values are stored without
a pointer, because those other types can be arbitrarily large. -->

<p><code>Foo</code> のためには、 <code>String</code> (24 bytes)か <code>u8</code> (1 byte)もしくは <code>Foo</code> （とにかくどんなサイズでも）を実装する依存クレート内の型のうちから少なくとも1つの値を格納する必要があります。ポインタ無しで値を保存した場合、その直後の動作が正しいかどうかを保証する方法がありません。型によって値のサイズが異なるからです。</p>

<!-- Putting the value behind a pointer means the size of the value is not relevant
when we are tossing a trait object around, only the size of the pointer itself. -->

<p>ポインタの参照先に値を配置することはトレイトオブジェクトを渡す場合に値自体のサイズが無関係になり、ポインタのサイズのみになることを意味しています。</p>

<!-- ### Representation -->

<h3 id='トレイトオブジェクトの内部表現' class='section-header'><a href='#トレイトオブジェクトの内部表現'>トレイトオブジェクトの内部表現</a></h3>
<!-- The methods of the trait can be called on a trait object via a special record
of function pointers traditionally called a ‘vtable’ (created and managed by
the compiler). -->

<p>トレイトのメソッドはトレイトオブジェクト内にある伝統的に「vtable」（これはコンパイラによって作成、管理されます）と呼ばれる特別な関数ポインタのレコードを介して呼び出されます。</p>

<!-- Trait objects are both simple and complicated: their core representation and
layout is quite straight-forward, but there are some curly error messages and
surprising behaviors to discover. -->

<p>トレイトオブジェクトは単純ですが難解でもあります。核となる表現と設計は非常に率直ですが、複雑なエラーメッセージを吐いたり、予期せぬ振る舞いが見つかったりします。</p>

<!-- Let’s start simple, with the runtime representation of a trait object. The
`std::raw` module contains structs with layouts that are the same as the
complicated built-in types, [including trait objects][stdraw]: -->

<p>単純な例として、トレイトオブジェクトの実行時の表現から見て行きましょう。 <code>std::raw</code> モジュールは複雑なビルドインの型と同じレイアウトの構造体を格納しており、 <a href="https://doc.rust-lang.org/std/raw/">トレイトオブジェクトも含まれています</a> 。</p>

<span class='rusttest'>fn main() {
    mod foo {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>TraitObject</span> {
    <span class='kw'>pub</span> <span class='ident'>data</span>: <span class='op'>*</span><span class='kw-2'>mut</span> (),
    <span class='kw'>pub</span> <span class='ident'>vtable</span>: <span class='op'>*</span><span class='kw-2'>mut</span> (),
}</pre>

<!-- That is, a trait object like `&Foo` consists of a ‘data’ pointer and a ‘vtable’ pointer. -->

<p>つまり、 <code>&amp;Foo</code> のようなトレイトオブジェクトは「data」ポインタと「vtable」ポインタから成るわけです。</p>

<!-- The data pointer addresses the data (of some unknown type `T`) that the trait
object is storing, and the vtable pointer points to the vtable (‘virtual method
table’) corresponding to the implementation of `Foo` for `T`. -->

<p>dataポインタはトレイトオブジェクトが保存している（何らかの不明な型 <code>T</code> の）データを指しており、vtableポインタは <code>T</code> への <code>Foo</code> の実装に対応するvtable（「virtual method table」）を指しています。</p>

<!-- A vtable is essentially a struct of function pointers, pointing to the concrete
piece of machine code for each method in the implementation. A method call like
`trait_object.method()` will retrieve the correct pointer out of the vtable and
then do a dynamic call of it. For example: -->

<p>vtableは本質的には関数ポインタの構造体で、実装内における各メソッドの具体的な機械語の命令列を指しています。 <code>trait_object.method()</code> のようなメソッド呼び出しを行うとvtableの中から適切なポインタを取り出し動的に呼び出しを行います。例えば、</p>

<span class='rusttest'>fn main() {
    struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}

// u8:

fn call_method_on_u8(x: *const ()) -&gt; String {
//     // the compiler guarantees that this function is only called
//     // with `x` pointing to a u8
    // コンパイラは `x` がu8を指しているときにのみこの関数が呼ばれることを保障します
    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
//     destructor: /* compiler magic */,
    destructor: /* コンパイラマジック */,
    size: 1,
    align: 1,

//     // cast to a function pointer
    // 関数ポインタへキャスト
    method: call_method_on_u8 as fn(*const ()) -&gt; String,
};


// String:

fn call_method_on_String(x: *const ()) -&gt; String {
//     // the compiler guarantees that this function is only called
//     // with `x` pointing to a String
    // コンパイラは `x` がStringを指しているときにのみこの関数が呼ばれることを保障します
    let string: &amp;String = unsafe { &amp;*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
//     destructor: /* compiler magic */,
    destructor: /* コンパイラマジック */,
//     // values for a 64-bit computer, halve them for 32-bit ones
    // この値は64bitコンピュータ向けのものです、32bitコンピュータではこの半分にします
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -&gt; String,
};
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw-2'>mut</span> ()),
    <span class='ident'>size</span>: <span class='ident'>usize</span>,
    <span class='ident'>align</span>: <span class='ident'>usize</span>,
    <span class='ident'>method</span>: <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
}

<span class='comment'>// u8:</span>

<span class='kw'>fn</span> <span class='ident'>call_method_on_u8</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// コンパイラは `x` がu8を指しているときにのみこの関数が呼ばれることを保障します</span>
    <span class='kw'>let</span> <span class='ident'>byte</span>: <span class='kw-2'>&amp;</span><span class='ident'>u8</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='op'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) };

    <span class='ident'>byte</span>.<span class='ident'>method</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_for_u8_vtable</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* コンパイラマジック */</span>,
    <span class='ident'>size</span>: <span class='number'>1</span>,
    <span class='ident'>align</span>: <span class='number'>1</span>,

    <span class='comment'>// 関数ポインタへキャスト</span>
    <span class='ident'>method</span>: <span class='ident'>call_method_on_u8</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};


<span class='comment'>// String:</span>

<span class='kw'>fn</span> <span class='ident'>call_method_on_String</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span> {
    <span class='comment'>// コンパイラは `x` がStringを指しているときにのみこの関数が呼ばれることを保障します</span>
    <span class='kw'>let</span> <span class='ident'>string</span>: <span class='kw-2'>&amp;</span><span class='ident'>String</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='kw-2'>&amp;</span><span class='op'>*</span>(<span class='ident'>x</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>String</span>) };

    <span class='ident'>string</span>.<span class='ident'>method</span>()
}

<span class='kw'>static</span> <span class='ident'>Foo_for_String_vtable</span>: <span class='ident'>FooVtable</span> <span class='op'>=</span> <span class='ident'>FooVtable</span> {
    <span class='ident'>destructor</span>: <span class='comment'>/* コンパイラマジック */</span>,
    <span class='comment'>// この値は64bitコンピュータ向けのものです、32bitコンピュータではこの半分にします</span>
    <span class='ident'>size</span>: <span class='number'>24</span>,
    <span class='ident'>align</span>: <span class='number'>8</span>,

    <span class='ident'>method</span>: <span class='ident'>call_method_on_String</span> <span class='kw'>as</span> <span class='kw'>fn</span>(<span class='op'>*</span><span class='kw'>const</span> ()) <span class='op'>-&gt;</span> <span class='ident'>String</span>,
};</pre>

<!-- The `destructor` field in each vtable points to a function that will clean up
any resources of the vtable’s type: for `u8` it is trivial, but for `String` it
will free the memory. This is necessary for owning trait objects like
`Box<Foo>`, which need to clean-up both the `Box` allocation as well as the
internal type when they go out of scope. The `size` and `align` fields store
the size of the erased type, and its alignment requirements; these are
essentially unused at the moment since the information is embedded in the
destructor, but will be used in the future, as trait objects are progressively
made more flexible. -->

<p>各vtableの <code>destructor</code> フィールドはvtableが対応する型のリソースを片付ける関数を指しています。 <code>u8</code> のvtableは単純な型なので何もしませんが、 <code>String</code> のvtableはメモリを解放します。このフィールドは <code>Box&lt;Foo&gt;</code> のような自作トレイトオブジェクトのために必要であり、 <code>Box</code> によるアロケートは勿論のことスコープ外に出た際に内部の型のリソースを片付けるのにも必要です。 <code>size</code> 及び <code>align</code> フィールドは消去された型のサイズとアライメント要件を保存しています。これらの情報はデストラクタにも組み込まれているため現時点では基本的に使われていませんが、将来、トレイトオブジェクトがより柔軟になることで使われるようになるでしょう。</p>

<!-- Suppose we’ve got some values that implement `Foo`. The explicit form of
construction and use of `Foo` trait objects might look a bit like (ignoring the
type mismatches: they’re all just pointers anyway): -->

<p>例えば <code>Foo</code> を実装する値を幾つか得たとします。 <code>Foo</code> トレイトオブジェクトを作る、あるいは使う時のコードを明示的に書いたものは少しだけ似ているでしょう。（型の違いを無視すればですが。どのみちただのポインタになります）</p>

<span class='rusttest'>fn main() {
    let a: String = &quot;foo&quot;.to_string();
let x: u8 = 1;

// let b: &amp;Foo = &amp;a;
let b = TraitObject {
//     // store the data
    // データを保存
    data: &amp;a,
//     // store the methods
    // メソッドを保存
    vtable: &amp;Foo_for_String_vtable
};

// let y: &amp;Foo = x;
let y = TraitObject {
//     // store the data
    // データを保存
    data: &amp;x,
//     // store the methods
    // メソッドを保存
    vtable: &amp;Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='string'>&quot;foo&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>u8</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='comment'>// let b: &amp;Foo = &amp;a;</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// データを保存</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>a</span>,
    <span class='comment'>// メソッドを保存</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_for_String_vtable</span>
};

<span class='comment'>// let y: &amp;Foo = x;</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>TraitObject</span> {
    <span class='comment'>// データを保存</span>
    <span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='ident'>x</span>,
    <span class='comment'>// メソッドを保存</span>
    <span class='ident'>vtable</span>: <span class='kw-2'>&amp;</span><span class='ident'>Foo_for_u8_vtable</span>
};

<span class='comment'>// b.method();</span>
(<span class='ident'>b</span>.<span class='ident'>vtable</span>.<span class='ident'>method</span>)(<span class='ident'>b</span>.<span class='ident'>data</span>);

<span class='comment'>// y.method();</span>
(<span class='ident'>y</span>.<span class='ident'>vtable</span>.<span class='ident'>method</span>)(<span class='ident'>y</span>.<span class='ident'>data</span>);</pre>

<!-- ## Object Safety -->

<h2 id='オブジェクトの安全性' class='section-header'><a href='#オブジェクトの安全性'>オブジェクトの安全性</a></h2>
<!-- Not every trait can be used to make a trait object. For example, vectors implement
`Clone`, but if we try to make a trait object: -->

<p>全てのトレイトがトレイトオブジェクトとして使えるわけではありません。例えば、ベクタは <code>Clone</code> を実装していますが、トレイトオブジェクトを作ろうとすると、</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
let o = &amp;v as &amp;Clone;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>o</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>v</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Clone</span>;</pre>

<!-- We get an error: -->

<p>エラーが発生します。</p>

<pre><code class="language-text">error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &amp;v as &amp;Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &amp;v as &amp;Clone;
        ^~
</code></pre>

<!-- The error says that `Clone` is not ‘object-safe’. Only traits that are
object-safe can be made into trait objects. A trait is object-safe if both of
these are true: -->

<p>エラーは <code>Clone</code> が「オブジェクト安全」(object-safe)でないと言っています。トレイトオブジェクトにできるのはオブジェクト安全なトレイトのみです。以下の両方が真であるならばトレイトはオブジェクト安全であるといえます。</p>

<!-- * the trait does not require that `Self: Sized` -->

<!-- * all of its methods are object-safe -->

<ul>
<li>トレイトが <code>Self: Sized</code> を要求しないこと</li>
<li>トレイトのメソッド全てがオブジェクト安全であること</li>
</ul>

<!-- So what makes a method object-safe? Each method must require that `Self: Sized`
or all of the following: -->

<p>では何がメソッドをオブジェクト安全にするのでしょう？各メソッドは <code>Self: Sized</code> を要求するか、以下の全てを満足しなければなりません。</p>

<!-- * must not have any type parameters -->

<!-- * must not use `Self` -->

<ul>
<li>どのような型パラメータも持ってはならない</li>
<li><code>Self</code> を使ってはならない</li>
</ul>

<!-- Whew! As we can see, almost all of these rules talk about `Self`. A good intuition
is “except in special circumstances, if your trait’s method uses `Self`, it is not
object-safe.” -->

<p>ひゃー！見ての通り、これらルールのほとんどは <code>Self</code> について話しています。「特別な状況を除いて、トレイトのメソッドで <code>Self</code> を使うとオブジェクト安全ではなくなる」と考えるのが良いでしょう。</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>