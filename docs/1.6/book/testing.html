<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>テスト</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a class='active' href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book-ja/">最新版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。リンク先のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">テスト</h1>
    <!-- % Testing -->

<!-- &gt; Program testing can be a very effective way to show the presence of bugs, but -->

<!-- &gt; it is hopelessly inadequate for showing their absence. -->

<!-- &gt; -->

<!-- &gt; Edsger W. Dijkstra, "The Humble Programmer" (1972) -->

<blockquote>
<p>プログラムのテストはバグの存在を示すためには非常に効率的な方法ですが、バグの不存在を示すためには絶望的に不十分です。
エドガー・W・ダイクストラ、『謙虚なプログラマ』（1972）</p>
</blockquote>

<!--Let's talk about how to test Rust code. What we will not be talking about is-->

<!--the right way to test Rust code. There are many schools of thought regarding-->

<!--the right and wrong way to write tests. All of these approaches use the same-->

<!--basic tools, and so we'll show you the syntax for using them.-->

<p>Rustのコードをテストする方法について話しましょう。
ここではRustのコードをテストする正しい方法について議論するつもりはありません。
テストを書くための正しい方法、誤った方法に関する流派はたくさんあります。
それらの方法は全て、同じ基本的なツールを使うので、それらのツールを使うための文法をお見せしましょう。</p>

<!--# The `test` attribute-->

<h1 id='test-アトリビュート' class='section-header'><a href='#test-アトリビュート'><code>test</code> アトリビュート</a></h1>
<!--At its simplest, a test in Rust is a function that's annotated with the `test`-->

<!--attribute. Let's make a new project with Cargo called `adder`:-->

<p>Rustでの一番簡単なテストは、 <code>test</code> アトリビュートの付いた関数です。
<code>adder</code> という名前の新しいプロジェクトをCargoで作りましょう。</p>

<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>

<!--Cargo will automatically generate a simple test when you make a new project.-->

<!--Here's the contents of `src/lib.rs`:-->

<p>新しいプロジェクトを作ると、Cargoは自動的に簡単なテストを生成します。
これが <code>src/lib.rs</code> の内容です。</p>

<span class='rusttest'>fn main() {
    #[test]
fn it_works() {
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
}</pre>

<!--Note the `#[test]`. This attribute indicates that this is a test function. It-->

<!--currently has no body. That's good enough to pass! We can run the tests with-->

<!--`cargo test`:-->

<p><code>#[test]</code> に注意しましょう。
このアトリビュートは、この関数がテスト関数であるということを示します。
今のところ、その関数には本文がありません。
成功させるためにはそれで十分なのです!
テストは <code>cargo test</code> で実行することができます。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--Cargo compiled and ran our tests. There are two sets of output here: one-->

<!--for the test we wrote, and another for documentation tests. We'll talk about-->

<!--those later. For now, see this line:-->

<p>Cargoはテストをコンパイルし、実行しました。
ここでは2種類の結果が出力されています。1つは書かれたテストについてのもの、もう1つはドキュメンテーションテストについてのものです。
それらについては後で話しましょう。
とりあえず、この行を見ましょう。</p>

<pre><code class="language-text">test it_works ... ok
</code></pre>

<!--Note the `it_works`. This comes from the name of our function:-->

<p><code>it_works</code> に注意しましょう。
これは関数の名前に由来しています。</p>

<span class='rusttest'>fn main() {
    fn it_works() {
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {</pre>

<!--We also get a summary line:-->

<p>次のようなサマリも出力されています。</p>

<pre><code class="language-text">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--So why does our do-nothing test pass? Any test which doesn't `panic!` passes,-->

<!--and any test that does `panic!` fails. Let's make our test fail:-->

<p>なぜ何も書いていないテストがこのように成功するのでしょうか。
<code>panic!</code> しないテストは全て成功で、 <code>panic!</code> するテストは全て失敗なのです。
テストを失敗させましょう。</p>

<span class='rusttest'>fn main() {
    #[test]
fn it_works() {
    assert!(false);
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolvalue'>false</span>);
}</pre>

<!--`assert!` is a macro provided by Rust which takes one argument: if the argument-->

<!--is `true`, nothing happens. If the argument is `false`, it `panic!`s. Let's run-->

<!--our tests again:-->

<p><code>assert!</code> はRustが提供するマクロで、1つの引数を取ります。引数が <code>true</code> であれば何も起きません。
引数が <code>false</code> であれば <code>panic!</code> します。
テストをもう一度実行しましょう。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread &#39;it_works&#39; panicked at &#39;assertion failed: false&#39;, /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread &#39;&lt;main&gt;&#39; panicked at &#39;Some tests failed&#39;, /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>

<!--Rust indicates that our test failed:-->

<p>Rustは次のとおりテストが失敗したことを示しています。</p>

<pre><code class="language-text">test it_works ... FAILED
</code></pre>

<!--And that's reflected in the summary line:-->

<p>そして、それはサマリにも反映されます。</p>

<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>

<!--We also get a non-zero status code. We can use `$?` on OS X and Linux:-->

<p>ステータスコードも非0になっています。
OS XやLinuxでは <code>$?</code> を使うことができます。</p>

<pre><code class="language-bash">$ echo $?
101
</code></pre>

<!--On Windows, if you’re using `cmd`:-->

<p>Windowsでは、 <code>cmd</code> を使っていればこうです。</p>

<pre><code class="language-bash">&gt; echo %ERRORLEVEL%
</code></pre>

<!--And if you’re using PowerShell:-->

<p>そして、PowerShellを使っていればこうです。</p>

<pre><code class="language-bash">&gt; echo $LASTEXITCODE # the code itself
&gt; echo $? # a boolean, fail or succeed
</code></pre>

<!--This is useful if you want to integrate `cargo test` into other tooling.-->

<p>これは <code>cargo test</code> を他のツールと統合したいときに便利です。</p>

<!--We can invert our test's failure with another attribute: `should_panic`:-->

<p>もう1つのアトリビュート、 <code>should_panic</code> を使ってテストの失敗を反転させることができます。</p>

<span class='rusttest'>fn main() {
    #[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>should_panic</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolvalue'>false</span>);
}</pre>

<!--This test will now succeed if we `panic!` and fail if we complete. Let's try it:-->

<p>今度は、このテストが <code>panic!</code> すれば成功で、完走すれば失敗です。
試しましょう。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--Rust provides another macro, `assert_eq!`, that compares two arguments for-->

<!--equality:-->

<p>Rustはもう1つのマクロ、 <code>assert_eq!</code> を提供しています。これは2つの引数の等価性を調べます。</p>

<span class='rusttest'>fn main() {
    #[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>should_panic</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>);
}</pre>

<!--Does this test pass or fail? Because of the `should_panic` attribute, it-->

<!--passes:-->

<p>このテストは成功でしょうか、失敗でしょうか。
<code>should_panic</code> アトリビュートがあるので、これは成功です。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--`should_panic` tests can be fragile, as it's hard to guarantee that the test-->

<!--didn't fail for an unexpected reason. To help with this, an optional `expected`-->

<!--parameter can be added to the `should_panic` attribute. The test harness will-->

<!--make sure that the failure message contains the provided text. A safer version-->

<!--of the example above would be:-->

<p><code>should_panic</code> を使ったテストは脆いテストです。なぜなら、テストが予想外の理由で失敗したのではないということを保証することが難しいからです。
これを何とかするために、 <code>should_panic</code> アトリビュートにはオプションで <code>expected</code> パラメータを付けることができます。
テストハーネスが、失敗したときのメッセージに与えられたテキストが含まれていることを確かめてくれます。
前述の例のもっと安全なバージョンはこうなります。</p>

<span class='rusttest'>fn main() {
    #[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>should_panic</span>(<span class='ident'>expected</span> <span class='op'>=</span> <span class='string'>&quot;assertion failed&quot;</span>)]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>);
}</pre>

<!--That's all there is to the basics! Let's write one 'real' test:-->

<p>基本はそれだけです!
「リアルな」テストを書いてみましょう。</p>

<span class='rusttest'>fn main() {
    pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>add_two</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>add_two</span>(<span class='number'>2</span>));
}</pre>

<!--This is a very common use of `assert_eq!`: call some function with-->

<!--some known arguments and compare it to the expected output.-->

<p>これは非常に一般的な <code>assert_eq!</code> の使い方です。いくつかの関数に結果の分かっている引数を渡して呼び出し、期待した結果と比較します。</p>

<!--# The `ignore` attribute-->

<h1 id='ignore-アトリビュート' class='section-header'><a href='#ignore-アトリビュート'><code>ignore</code> アトリビュート</a></h1>
<!--Sometimes a few specific tests can be very time-consuming to execute. These-->

<!--can be disabled by default by using the `ignore` attribute:-->

<p>ときどき、特定のテストの実行に非常に時間が掛かることがあります。
そのようなテストは、 <code>ignore</code> アトリビュートを使ってデフォルトでは無効にすることができます。</p>

<span class='rusttest'>fn main() {
    #[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#[test]
#[ignore]
fn expensive_test() {
  // code that takes an hour to run
    // 実行に1時間掛かるコード
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>add_two</span>(<span class='number'>2</span>));
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='attribute'>#[<span class='ident'>ignore</span>]</span>
<span class='kw'>fn</span> <span class='ident'>expensive_test</span>() {
    <span class='comment'>// 実行に1時間掛かるコード</span>
}</pre>

<!--Now we run our tests and see that `it_works` is run, but `expensive_test` is-->

<!--not:-->

<p>テストを実行すると、 <code>it_works</code> が実行されることを確認できますが、今度は <code>expensive_test</code> は実行されません。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--The expensive tests can be run explicitly using `cargo test -- --ignored`:-->

<p>無効にされた高コストなテストは <code>cargo test -- --ignored</code> を使って明示的に実行することができます。</p>

<pre><code class="language-bash">$ cargo test -- --ignored
     Running target/adder-91b3e234d4ed382a

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--The `--ignored` argument is an argument to the test binary, and not to Cargo,-->

<!--which is why the command is `cargo test -- --ignored`.-->

<p><code>--ignored</code> アトリビュートはテストバイナリの引数であって、Cargoのものではありません。
コマンドが <code>cargo test -- --ignored</code> となっているのはそういうことです。</p>

<!--# The `tests` module-->

<h1 id='tests-モジュール' class='section-header'><a href='#tests-モジュール'><code>tests</code> モジュール</a></h1>
<!--There is one way in which our existing example is not idiomatic: it's-->

<!--missing the `tests` module. The idiomatic way of writing our example-->

<!--looks like this:-->

<p>今までの例における手法は、慣用的ではありません。 <code>tests</code> モジュールがないからです。
今までの例の慣用的な書き方はこのようになります。</p>

<span class='rusttest'>fn main() {
    pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>add_two</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='kw'>super</span>::<span class='ident'>add_two</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>it_works</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>add_two</span>(<span class='number'>2</span>));
    }
}</pre>

<!--There's a few changes here. The first is the introduction of a `mod tests` with-->

<!--a `cfg` attribute. The module allows us to group all of our tests together, and-->

<!--to also define helper functions if needed, that don't become a part of the rest-->

<!--of our crate. The `cfg` attribute only compiles our test code if we're-->

<!--currently trying to run the tests. This can save compile time, and also ensures-->

<!--that our tests are entirely left out of a normal build.-->

<p>ここでは、いくつかの変更点があります。
まず、 <code>cfg</code> アトリビュートの付いた <code>mod tests</code> を導入しました。
このモジュールを使うと、全てのテストをグループ化することができます。また、必要であれば、ヘルパ関数を定義し、それをクレートの一部に含まれないようにすることもできます。
 <code>cfg</code> アトリビュートによって、テストを実行しようとしているときにだけテストコードがコンパイルされるようになります。
これは、コンパイル時間を節約し、テストが通常のビルドに全く影響しないことを保証してくれます。</p>

<!--The second change is the `use` declaration. Because we're in an inner module,-->

<!--we need to bring our test function into scope. This can be annoying if you have-->

<!--a large module, and so this is a common use of globs. Let's change our-->

<!--`src/lib.rs` to make use of it:-->

<p>2つ目の変更点は、 <code>use</code> 宣言です。
ここは内部モジュールの中なので、テスト関数をスコープの中に持ち込む必要があります。
モジュールが大きい場合、これは面倒かもしれないので、ここがグロブの一般的な使い所です。
<code>src/lib.rs</code> をグロブを使うように変更しましょう。</p>

<span class='rusttest'>fn main() {
    pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>add_two</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='kw'>super</span>::<span class='op'>*</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>it_works</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>add_two</span>(<span class='number'>2</span>));
    }
}</pre>

<!--Note the different `use` line. Now we run our tests:-->

<p><code>use</code> 行が変わったことに注意しましょう。
さて、テストを実行します。</p>

<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--It works!-->

<p>動きます!</p>

<!--The current convention is to use the `tests` module to hold your "unit-style"-->

<!--tests. Anything that just tests one small bit of functionality makes sense to-->

<!--go here. But what about "integration-style" tests instead? For that, we have-->

<!--the `tests` directory.-->

<p>現在の慣習では、 <code>tests</code> モジュールは「ユニット」テストを入れるために使うことになっています。
単一の小さな機能の単位をテストするだけのものは全て、ここに入れる意味があります。
しかし、「結合」テストはどうでしょうか。
結合テストのためには、 <code>tests</code> ディレクトリがあります。</p>

<!--# The `tests` directory-->

<h1 id='tests-ディレクトリ' class='section-header'><a href='#tests-ディレクトリ'><code>tests</code> ディレクトリ</a></h1>
<!--To write an integration test, let's make a `tests` directory, and-->

<!--put a `tests/lib.rs` file inside, with this as its contents:-->

<p>結合テストを書くために、 <code>tests</code> ディレクトリを作りましょう。そして、その中に次の内容の <code>tests/lib.rs</code> ファイルを置きます。</p>

<span class='rusttest'>fn main() {
    extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>adder</span>;

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>it_works</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>adder</span>::<span class='ident'>add_two</span>(<span class='number'>2</span>));
}</pre>

<!--This looks similar to our previous tests, but slightly different. We now have-->

<!--an `extern crate adder` at the top. This is because the tests in the `tests`-->

<!--directory are an entirely separate crate, and so we need to import our library.-->

<!--This is also why `tests` is a suitable place to write integration-style tests:-->

<!--they use the library like any other consumer of it would.-->

<p>これは前のテストと似ていますが、少し違います。
今回は、 <code>extern crate adder</code> を先頭に書いています。
これは、 <code>tests</code> ディレクトリの中のテストが全く別のクレートであるため、ライブラリをインポートしなければならないからです。
これは、なぜ <code>tests</code> が結合テストを書くのに適切な場所なのかという理由でもあります。そこにあるテストは、そのライブラリを他のプログラムと同じようなやり方で使うからです。</p>

<!--Let's run them:-->

<p>テストを実行しましょう。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--Now we have three sections: our previous test is also run, as well as our new-->

<!--one.-->

<p>今度は3つのセクションが出力されました。新しいテストが実行され、前に書いたテストも同様に実行されます。</p>

<!--That's all there is to the `tests` directory. The `tests` module isn't needed-->

<!--here, since the whole thing is focused on tests.-->

<p><code>tests</code> ディレクトリについてはそれだけです。
<code>tests</code> モジュールはここでは必要ありません。全てのものがテストのためのものだからです。</p>

<!--Let's finally check out that third section: documentation tests.-->

<p>最後に、3つ目のセクションを確認しましょう。ドキュメンテーションテストです。</p>

<!--# Documentation tests-->

<h1 id='ドキュメンテーションテスト' class='section-header'><a href='#ドキュメンテーションテスト'>ドキュメンテーションテスト</a></h1>
<!--Nothing is better than documentation with examples. Nothing is worse than-->

<!--examples that don't actually work, because the code has changed since the-->

<!--documentation has been written. To this end, Rust supports automatically-->

<!--running examples in your documentation (**note:** this only works in library-->

<!--crates, not binary crates). Here's a fleshed-out `src/lib.rs` with examples:-->

<p>例の付いたドキュメントほどよいものはありません。
ドキュメントを書いた後にコードが変更された結果、実際に動かなくなった例ほど悪いものはありません。
この状況を終わらせるために、Rustはあなたのドキュメント内の例の自動実行をサポートします（ <strong>注意：</strong> これはライブラリクレートの中でのみ動作し、バイナリクレートの中では動作しません）。
これが例を付けた具体的な <code>src/lib.rs</code> です。</p>

<span class='rusttest'>fn main() {
    //! The `adder` crate provides functions that add numbers to other numbers.
//! `adder`クレートはある数値を数値に加える関数を提供する
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
/// この関数は引数に2を加える
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='doccomment'>//! `adder`クレートはある数値を数値に加える関数を提供する</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! # Examples</span>
<span class='doccomment'>//!</span>
<span class='doccomment'>//! ```</span>
<span class='doccomment'>//! assert_eq!(4, adder::add_two(2));</span>
<span class='doccomment'>//! ```</span>

<span class='doccomment'>/// この関数は引数に2を加える</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// # Examples</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// ```</span>
<span class='doccomment'>/// use adder::add_two;</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// assert_eq!(4, add_two(2));</span>
<span class='doccomment'>/// ```</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>add_two</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>a</span> <span class='op'>+</span> <span class='number'>2</span>
}

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>test</span>)]</span>
<span class='kw'>mod</span> <span class='ident'>tests</span> {
    <span class='kw'>use</span> <span class='kw'>super</span>::<span class='op'>*</span>;

    <span class='attribute'>#[<span class='ident'>test</span>]</span>
    <span class='kw'>fn</span> <span class='ident'>it_works</span>() {
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>4</span>, <span class='ident'>add_two</span>(<span class='number'>2</span>));
    }
}</pre>

<!--Note the module-level documentation with `//!` and the function-level-->

<!--documentation with `///`. Rust's documentation supports Markdown in comments,-->

<!--and so triple graves mark code blocks. It is conventional to include the-->

<!--`# Examples` section, exactly like that, with examples following.-->

<p>モジュールレベルのドキュメントには <code>//!</code> を付け、関数レベルのドキュメントには <code>///</code> を付けていることに注意しましょう。
RustのドキュメントはMarkdown形式のコメントをサポートしていて、3連バッククオートはコードブロックを表します。
<code># Examples</code> セクションを含めるのが慣習で、そのとおり、例が後に続きます。</p>

<!--Let's run the tests again:-->

<p>テストをもう一度実行しましょう。</p>

<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<!--Now we have all three kinds of tests running! Note the names of the-->

<!--documentation tests: the `_0` is generated for the module test, and `add_two_0`-->

<!--for the function test. These will auto increment with names like `add_two_1` as-->

<!--you add more examples.-->

<p>今回は全ての種類のテストを実行しています!
ドキュメンテーションテストの名前に注意しましょう。 <code>_0</code> はモジュールテストのために生成された名前で、 <code>add_two_0</code> は関数テストのために生成された名前です。
例を追加するにつれて、それらの名前は <code>add_two_1</code> というような形で数値が増えていきます。</p>

<!--We haven’t covered all of the details with writing documentation tests. For more,-->

<!--please see the [Documentation chapter](documentation.html)-->

<p>まだドキュメンテーションテストの書き方の詳細について、全てをカバーしてはいません。
詳しくは <a href="documentation.html">ドキュメントの章</a> を見てください。</p>

<!--One final note: documentation tests *cannot* be run on binary crates.-->

<!--To see more on file arrangement see the [Crates and-->

<!--Modules](crates-and-modules.html) section.-->

<p>最後の注意：バイナリクレート上のテストは実行 <em>できません</em> 。
ファイルの配置についてもっと知りたい場合は <a href="crates-and-modules.html">クレートとモジュール</a> セクションを見ましょう。</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>