<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>インラインアセンブリ</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a class='active' href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book/second-edition/">第2版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。第2版のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">インラインアセンブリ</h1>
    <!-- % Inline Assembly -->

<!-- For extremely low-level manipulations and performance reasons, one -->

<!-- might wish to control the CPU directly. Rust supports using inline -->

<!-- assembly to do this via the `asm!` macro. The syntax roughly matches -->

<!-- that of GCC & Clang: -->

<p>極めて低レベルな技巧やパフォーマンス上の理由から、CPUを直接コントロールしたいと思う人もいるでしょう。
Rustはそのような処理を行うためにインラインアセンブリを <code>asm!</code> マクロによってサポートしています。
インラインアセンブリの構文はGCCやClangのものとおおまかに一致しています。</p>

<span class='rusttest'>fn main() {
    // asm!(assembly template
asm!(アセンブリのテンプレート
//   : output operands
   : 出力オペランド
//   : input operands
   : 入力オペランド
//   : clobbers
   : 破壊されるデータ
//   : options
   : オプション
   );
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='ident'>アセンブリのテンプレート</span>
   : <span class='ident'>出力オペランド</span>
   : <span class='ident'>入力オペランド</span>
   : <span class='ident'>破壊されるデータ</span>
   : <span class='ident'>オプション</span>
   );</pre>

<!-- Any use of `asm` is feature gated (requires `#![feature(asm)]` on the -->

<!-- crate to allow) and of course requires an `unsafe` block. -->

<p><code>asm</code> のいかなる利用もフィーチャーゲートの対象です(利用するには <code>#![feature(asm)]</code> がクレートに必要になります)、
そしてもちろん <code>unsafe</code> ブロックも必要です。</p>

<!-- > **Note**: the examples here are given in x86/x86-64 assembly, but -->

<!-- > all platforms are supported. -->

<blockquote>
<p><strong>メモ</strong>: ここでの例はx86/x86-64のアセンブリで示されますが、すべてのプラットフォームがサポートされています。</p>
</blockquote>

<!-- ## Assembly template -->

<h2 id='アセンブリテンプレート' class='section-header'><a href='#アセンブリテンプレート'>アセンブリテンプレート</a></h2>
<!-- The `assembly template` is the only required parameter and must be a -->

<!-- literal string (i.e. `""`) -->

<p><code>アセンブリテンプレート</code> のみが要求されるパラメータであり、文字列リテラル (例: &quot;&quot;) である必要があります。</p>

<span class='rusttest'>#![feature(asm)]

#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn foo() {
    unsafe {
        asm!(&quot;NOP&quot;);
    }
}

// other platforms
// その他のプラットフォーム
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>asm</span>)]</span>

<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>any</span>(<span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86&quot;</span>, <span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86_64&quot;</span>))]</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>unsafe</span> {
        <span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;NOP&quot;</span>);
    }
}

<span class='comment'>// その他のプラットフォーム</span>
<span class='attribute'>#[<span class='ident'>cfg</span>(<span class='ident'>not</span>(<span class='ident'>any</span>(<span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86&quot;</span>, <span class='ident'>target_arch</span> <span class='op'>=</span> <span class='string'>&quot;x86_64&quot;</span>)))]</span>
<span class='kw'>fn</span> <span class='ident'>foo</span>() { <span class='comment'>/* ... */</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// ...</span>
    <span class='ident'>foo</span>();
    <span class='comment'>// ...</span>
}</pre>

<!-- (The `feature(asm)` and `#[cfg]`s are omitted from now on.) -->

<p>以後は、 <code>feature(asm)</code> と <code>#[cfg]</code> は省略して示します。</p>

<!-- Output operands, input operands, clobbers and options are all optional -->

<!-- but you must add the right number of `:` if you skip them: -->

<p>出力オペランド、入力オペランド、破壊されるデータ、オプションはすべて省略可能ですが、省略する場合は <code>:</code> を正しい数書く必要が有ります。</p>

<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot;
    :
    :
    : &quot;{eax}&quot;
   );
} }
</span><pre class='rust rust-example-rendered'>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;xor %eax, %eax&quot;</span>
    :
    :
    : <span class='string'>&quot;{eax}&quot;</span>
   );</pre>

<!-- Whitespace also doesn't matter: -->

<p>空白も必要ではありません:</p>

<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot; ::: &quot;{eax}&quot;);
} }
</span><pre class='rust rust-example-rendered'>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;xor %eax, %eax&quot;</span> ::: <span class='string'>&quot;{eax}&quot;</span>);</pre>

<!-- ## Operands -->

<h2 id='オペランド' class='section-header'><a href='#オペランド'>オペランド</a></h2>
<!-- Input and output operands follow the same format: `: -->

<!-- "constraints1"(expr1), "constraints2"(expr2), ..."`. Output operand -->

<!-- expressions must be mutable lvalues, or not yet assigned: -->

<p>入力と出力のオペランドは、 <code>: &quot;制約1&quot;(式1), &quot;制約2&quot;(式2), ...</code> というフォーマットに従います。
出力オペランドの式は変更可能な左辺値か、アサインされていない状態でなければなりません。</p>

<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn add(a: i32, b: i32) -&gt; i32 {
    let c: i32;
    unsafe {
        asm!(&quot;add $2, $0&quot;
             : &quot;=r&quot;(c)
             : &quot;0&quot;(a), &quot;r&quot;(b)
             );
    }
    c
}
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>add</span>(<span class='ident'>a</span>: <span class='ident'>i32</span>, <span class='ident'>b</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>let</span> <span class='ident'>c</span>: <span class='ident'>i32</span>;
    <span class='kw'>unsafe</span> {
        <span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;add $2, $0&quot;</span>
             : <span class='string'>&quot;=r&quot;</span>(<span class='ident'>c</span>)
             : <span class='string'>&quot;0&quot;</span>(<span class='ident'>a</span>), <span class='string'>&quot;r&quot;</span>(<span class='ident'>b</span>)
             );
    }
    <span class='ident'>c</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>add</span>(<span class='number'>3</span>, <span class='number'>14159</span>), <span class='number'>14162</span>)
}</pre>

<!-- If you would like to use real operands in this position, however, -->

<!-- you are required to put curly braces `{}` around the register that -->

<!-- you want, and you are required to put the specific size of the -->

<!-- operand. This is useful for very low level programming, where -->

<!-- which register you use is important: -->

<p>もし本当のオペランドをここで利用したい場合、 波括弧 <code>{}</code> で利用したいレジスタの周りを囲む必要があり、また、オペランドの特有のサイズを置く必要があります。
これは、どのレジスタを利用するかが重要になる低レベルなプログラミングで有用です。</p>

<span class='rusttest'>#![feature(asm)]
fn main() {
    #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
unsafe fn read_byte_in(port: u16) -&gt; u8 {
let result: u8;
asm!(&quot;in %dx, %al&quot; : &quot;={al}&quot;(result) : &quot;{dx}&quot;(port));
result
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>result</span>: <span class='ident'>u8</span>;
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;in %dx, %al&quot;</span> : <span class='string'>&quot;={al}&quot;</span>(<span class='ident'>result</span>) : <span class='string'>&quot;{dx}&quot;</span>(<span class='ident'>port</span>));
<span class='ident'>result</span></pre>

<!-- ## Clobbers -->

<h2 id='破壊されるデータ' class='section-header'><a href='#破壊されるデータ'>破壊されるデータ</a></h2>
<!-- Some instructions modify registers which might otherwise have held -->

<!-- different values so we use the clobbers list to indicate to the -->

<!-- compiler not to assume any values loaded into those registers will -->

<!-- stay valid. -->

<p>幾つかのインストラクションは異なる値を持っている可能性のあるレジスタを変更する事があります、
そのため、コンパイラがそれらのレジスタに格納された値が処理後にも有効であると思わないように、
破壊されるデータのリストを利用します。</p>

<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() { unsafe {
// Put the value 0x200 in eax
// eaxに0x200を格納します
// asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;{eax}&quot;);
asm!(&quot;mov $$0x200, %eax&quot; : /* 出力なし */ : /* 入力無し */ : &quot;{eax}&quot;);
} }
</span><pre class='rust rust-example-rendered'>
<span class='comment'>// eaxに0x200を格納します</span>
<span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;mov $$0x200, %eax&quot;</span> : <span class='comment'>/* 出力なし */</span> : <span class='comment'>/* 入力無し */</span> : <span class='string'>&quot;{eax}&quot;</span>);</pre>

<!-- Input and output registers need not be listed since that information -->

<!-- is already communicated by the given constraints. Otherwise, any other -->

<!-- registers used either implicitly or explicitly should be listed. -->

<p>入力と出力のレジスタは変更される可能性があることが制約によってすでに伝わっているためにリストに載せる必要はありません。
それ以外では、その他の暗黙的、明示的に利用されるレジスタをリストに載せる必要があります。</p>

<!-- If the assembly changes the condition code register `cc` should be -->

<!-- specified as one of the clobbers. Similarly, if the assembly modifies -->

<!-- memory, `memory` should also be specified. -->

<p>もしアセンブリが条件コードを変更する場合レジスタ <code>cc</code> も破壊されるデータのリストに指定する必要があります。
同様に、もしアセンブリがメモリを変更する場合 <code>memory</code> もリストに指定する必要があります。</p>

<!-- ## Options -->

<h2 id='オプション' class='section-header'><a href='#オプション'>オプション</a></h2>
<!-- The last section, `options` is specific to Rust. The format is comma -->

<!-- separated literal strings (i.e. `:"foo", "bar", "baz"`). It's used to -->

<!-- specify some extra info about the inline assembly: -->

<p>最後のセクション、 <code>options</code> はRust特有のものです。
<code>options</code> の形式は、コンマで区切られた文字列リテラルのリスト(例: <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>)です。
これはインラインアセンブリについての追加の情報を指定するために利用されます:</p>

<!-- Current valid options are: -->

<p>現在有効なオプションは以下の通りです:</p>

<!-- 1. *volatile* - specifying this is analogous to-->

<!--    `__asm__ __volatile__ (...)` in gcc/clang.-->

<!-- 2. *alignstack* - certain instructions expect the stack to be-->

<!--    aligned a certain way (i.e. SSE) and specifying this indicates to-->

<!--    the compiler to insert its usual stack alignment code-->

<!-- 3. *intel* - use intel syntax instead of the default AT&T.-->

<ol>
<li><em>volatile</em> - このオプションを指定することは、gcc/clangで <code>__asm__ __volatile__ (...)</code> を指定することと類似しています。</li>
<li><em>alignstack</em> - いくつかのインストラクションはスタックが決まった方式(例: SSE)でアラインされていることを期待しています、
このオプションを指定することはコンパイラに通常のスタックをアラインメントするコードの挿入を指示します。</li>
<li><em>intel</em> - デフォルトのAT&amp;T構文の代わりにインテル構文を利用することを意味しています。</li>
</ol>

<span class='rusttest'>#![feature(asm)]
#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn main() {
let result: i32;
unsafe {
   asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)
}
println!(&quot;eax is currently {}&quot;, result);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>result</span>: <span class='ident'>i32</span>;
<span class='kw'>unsafe</span> {
   <span class='macro'>asm</span><span class='macro'>!</span>(<span class='string'>&quot;mov eax, 2&quot;</span> : <span class='string'>&quot;={eax}&quot;</span>(<span class='ident'>result</span>) : : : <span class='string'>&quot;intel&quot;</span>)
}
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;eax is currently {}&quot;</span>, <span class='ident'>result</span>);</pre>

<!-- ## More Information -->

<h2 id='さらなる情報' class='section-header'><a href='#さらなる情報'>さらなる情報</a></h2>
<!-- The current implementation of the `asm!` macro is a direct binding to [LLVM's -->

<!-- inline assembler expressions][llvm-docs], so be sure to check out [their -->

<!-- documentation as well][llvm-docs] for more information about clobbers, -->

<!-- constraints, etc. -->

<p>現在の <code>asm!</code> マクロの実装は <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">LLVMのインラインアセンブリ表現</a> への直接的なバインディングです、
そのため破壊されるデータのリストや、制約、その他の情報について <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">LLVMのドキュメント</a> を確認してください。</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>