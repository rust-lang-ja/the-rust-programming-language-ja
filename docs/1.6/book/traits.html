<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>トレイト</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a class='active' href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book-ja/">最新版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。リンク先のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">トレイト</h1>
    <!-- % Traits -->

<!-- A trait is a language feature that tells the Rust compiler about
functionality a type must provide. -->

<p>トレイトはある型が提供しなければならない機能をRustのコンパイラに伝える言語機能です。</p>

<!-- Recall the `impl` keyword, used to call a function with [method
syntax][methodsyntax]: -->

<p><a href="method-syntax.html">メソッド構文</a>で関数を呼び出すのに用いていた、 <code>impl</code> キーワードを思い出して下さい。</p>

<span class='rusttest'>fn main() {
    struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>impl</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}</pre>

<!-- Traits are similar, except that we first define a trait with a method
signature, then implement the trait for a type. In this example, we implement the trait `HasArea` for `Circle`: -->

<p>始めにトレイトをメソッドのシグネチャと共に定義し、続いてある型のためにトレイトを実装するという流れを除けばトレイトはメソッド構文に似ています。
この例では、 <code>Circle</code> に <code>HasArea</code> トレイトを実装しています。</p>

<span class='rusttest'>fn main() {
    struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>;
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}</pre>

<!-- As you can see, the `trait` block looks very similar to the `impl` block,
but we don’t define a body, just a type signature. When we `impl` a trait,
we use `impl Trait for Item`, rather than just `impl Item`. -->

<p>このように、 <code>trait</code> ブロックは <code>impl</code> ブロックにとても似ているように見えますが、関数本体を定義せず、型シグネチャだけを定義しています。トレイトを <code>impl</code> するときは、ただ <code>impl Item</code> とするのではなく、 <code>impl Trait for Item</code> と記述します。</p>

<!-- ## Trait bounds on generic functions -->

<h2 id='ジェネリック関数におけるトレイト境界' class='section-header'><a href='#ジェネリック関数におけるトレイト境界'>ジェネリック関数におけるトレイト境界</a></h2>
<!-- Traits are useful because they allow a type to make certain promises about its
behavior. Generic functions can exploit this to constrain, or [bound][bounds], the types they
accept. Consider this function, which does not compile: -->

<p>トレイトはある型の振る舞いを確約できるため有用です。ジェネリック関数は制約、あるいは <a href="glossary.html#bounds">境界</a> が許容する型のみを受け取るためにトレイトを利用できます。以下の関数を考えて下さい、これはコンパイルできません。</p>

<span class='rusttest'>fn main() {
    fn print_area&lt;T&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}</pre>

<!-- Rust complains: -->

<p>Rustは以下のエラーを吐きます。</p>

<pre><code class="language-text">error: no method named `area` found for type `T` in the current scope
</code></pre>

<!-- Because `T` can be any type, we can’t be sure that it implements the `area`
method. But we can add a trait bound to our generic `T`, ensuring
that it does: -->

<p><code>T</code> はあらゆる型になれるため、 <code>area</code> メソッドが実装されているか確認できません。ですがジェネリックな <code>T</code> にはトレイト境界を追加でき、境界が実装を保証してくれます。</p>

<span class='rusttest'>fn main() {
    trait HasArea {
    fn area(&amp;self) -&gt; f64;
}
fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>HasArea</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}</pre>

<!-- The syntax `<T: HasArea>` means “any type that implements the `HasArea` trait.”
Because traits define function type signatures, we can be sure that any type
which implements `HasArea` will have an `.area()` method. -->

<p><code>&lt;T: HasArea&gt;</code> 構文は「 <code>HasArea</code> トレイトを実装するあらゆる型」という意味です。トレイトは関数の型シグネチャを定義しているため、 <code>HasArea</code> を実装するあらゆる型が <code>.area()</code> メソッドを持っていることを確認できます。</p>

<!-- Here’s an extended example of how this works: -->

<p>トレイトの動作を確認するために拡張した例が以下になります。</p>

<span class='rusttest'>trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>;
}

<span class='kw'>struct</span> <span class='ident'>Circle</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>radius</span>: <span class='ident'>f64</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> (<span class='self'>self</span>.<span class='ident'>radius</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>radius</span>)
    }
}

<span class='kw'>struct</span> <span class='ident'>Square</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>,
    <span class='ident'>side</span>: <span class='ident'>f64</span>,
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>Square</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='self'>self</span>.<span class='ident'>side</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>side</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>print_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>HasArea</span><span class='op'>&gt;</span>(<span class='ident'>shape</span>: <span class='ident'>T</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;This shape has an area of {}&quot;</span>, <span class='ident'>shape</span>.<span class='ident'>area</span>());
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>Circle</span> {
        <span class='ident'>x</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>y</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>radius</span>: <span class='number'>1.0f64</span>,
    };

    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>Square</span> {
        <span class='ident'>x</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>y</span>: <span class='number'>0.0f64</span>,
        <span class='ident'>side</span>: <span class='number'>1.0f64</span>,
    };

    <span class='ident'>print_area</span>(<span class='ident'>c</span>);
    <span class='ident'>print_area</span>(<span class='ident'>s</span>);
}</pre>

<!-- This program outputs: -->

<p>このプログラムの出力は、</p>

<pre><code class="language-text">This shape has an area of 3.141593
This shape has an area of 1
</code></pre>

<!-- As you can see, `print_area` is now generic, but also ensures that we have
passed in the correct types. If we pass in an incorrect type: -->

<p>見ての通り、上記の <code>print_area</code> はジェネリックですが、適切な型が渡されることを保証しています。もし不適切な型を渡すと、</p>

<span class='rusttest'>fn main() {
    print_area(5);
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>print_area</span>(<span class='number'>5</span>);</pre>

<!-- We get a compile-time error: -->

<p>コンパイル時エラーが発生します。</p>

<pre><code class="language-text">error: the trait `HasArea` is not implemented for the type `_` [E0277]
</code></pre>

<!-- ## Trait bounds on generic structs -->

<h2 id='ジェネリック構造体におけるトレイト境界' class='section-header'><a href='#ジェネリック構造体におけるトレイト境界'>ジェネリック構造体におけるトレイト境界</a></h2>
<!-- Your generic structs can also benefit from trait bounds. All you need to
do is append the bound when you declare type parameters. Here is a new
type `Rectangle<T>` and its operation `is_square()`: -->

<p>ジェネリック構造体もトレイト境界による恩恵を受けることができます。型パラメータを宣言する際に境界を追加するだけで良いのです。以下が新しい型 <code>Rectangle&lt;T&gt;</code> とそのメソッド <code>is_square()</code> です。</p>

<span class='rusttest'>struct Rectangle&lt;T&gt; {
    x: T,
    y: T,
    width: T,
    height: T,
}

impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; {
    fn is_square(&amp;self) -&gt; bool {
        self.width == self.height
    }
}

fn main() {
    let mut r = Rectangle {
        x: 0,
        y: 0,
        width: 47,
        height: 47,
    };

    assert!(r.is_square());

    r.height = 42;
    assert!(!r.is_square());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Rectangle</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>x</span>: <span class='ident'>T</span>,
    <span class='ident'>y</span>: <span class='ident'>T</span>,
    <span class='ident'>width</span>: <span class='ident'>T</span>,
    <span class='ident'>height</span>: <span class='ident'>T</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span> <span class='ident'>Rectangle</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>is_square</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='self'>self</span>.<span class='ident'>width</span> <span class='op'>==</span> <span class='self'>self</span>.<span class='ident'>height</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>Rectangle</span> {
        <span class='ident'>x</span>: <span class='number'>0</span>,
        <span class='ident'>y</span>: <span class='number'>0</span>,
        <span class='ident'>width</span>: <span class='number'>47</span>,
        <span class='ident'>height</span>: <span class='number'>47</span>,
    };

    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>r</span>.<span class='ident'>is_square</span>());

    <span class='ident'>r</span>.<span class='ident'>height</span> <span class='op'>=</span> <span class='number'>42</span>;
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>r</span>.<span class='ident'>is_square</span>());
}</pre>

<!-- `is_square()` needs to check that the sides are equal, so the sides must be of
a type that implements the [`core::cmp::PartialEq`][PartialEq] trait: -->

<p><code>is_square()</code> は両辺が等しいかチェックする必要があるため、両辺の型は <a href="../core/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> トレイトを実装しなければなりません。</p>

<span class='rusttest'>fn main() {
    impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { ... }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span> <span class='ident'>Rectangle</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { ... }</pre>

<!-- Now, a rectangle can be defined in terms of any type that can be compared for
equality. -->

<p>これで、長方形を等値性の比較できる任意の型として定義できました。</p>

<!-- Here we defined a new struct `Rectangle` that accepts numbers of any
precision—really, objects of pretty much any type—as long as they can be
compared for equality. Could we do the same for our `HasArea` structs, `Square`
and `Circle`? Yes, but they need multiplication, and to work with that we need
to know more about [operator traits][operators-and-overloading]. -->

<p>上記の例では任意の精度の数値を受け入れる <code>Rectangle</code> 構造体を新たに定義しました-実は、等値性を比較できるほぼ全ての型に対して利用可能なオブジェクトです。同じことを <code>Square</code> や <code>Circle</code> のような <code>HasArea</code> を実装する構造体に対してできるでしょうか?可能では有りますが乗算が必要になるため、それをするには <a href="operators-and-overloading.html">オペレータトレイト</a> についてより詳しく知らなければなりません。</p>

<!-- # Rules for implementing traits -->

<h1 id='トレイト実装のルール' class='section-header'><a href='#トレイト実装のルール'>トレイト実装のルール</a></h1>
<!-- So far, we’ve only added trait implementations to structs, but you can
implement a trait for any type. So technically, we _could_ implement `HasArea`
for `i32`: -->

<p>ここまでで、構造体へトレイトの実装を追加することだけを説明してきましたが、あらゆる型についてトレイトを実装することもできます。技術的には、 <code>i32</code> に <code>HasArea</code> を実装することも <em>できなくはない</em> です。</p>

<span class='rusttest'>fn main() {
    trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        println!(&quot;this is silly&quot;);

        *self as f64
    }
}

5.area();
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>HasArea</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>;
}

<span class='kw'>impl</span> <span class='ident'>HasArea</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;this is silly&quot;</span>);

        <span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='ident'>f64</span>
    }
}

<span class='number'>5</span>.<span class='ident'>area</span>();</pre>

<!-- It is considered poor style to implement methods on such primitive types, even
though it is possible. -->

<p>しかし例え可能であったとしても、そのようなプリミティブ型のメソッドを実装するのは適切でない手法だと考えられています。</p>

<!-- This may seem like the Wild West, but there are two restrictions around
implementing traits that prevent this from getting out of hand. The first is
that if the trait isn’t defined in your scope, it doesn’t apply. Here’s an
example: the standard library provides a [`Write`][write] trait which adds
extra functionality to `File`s, for doing file I/O. By default, a `File`
won’t have its methods: -->

<p>ここまでくると世紀末感が漂いますが、手に負えなくなることを防ぐためにトレイトの実装周りには2つの制限が設けられています。第1に、あなたのスコープ内で定義されていないトレイトは適用されません。例えば、標準ライブラリは <code>File</code> にI/O機能を追加するための <code>Write</code> トレイトを提供しています。デフォルトでは、 <code>File</code> は <code>Write</code> で定義されるメソッド群を持っていません。</p>

<span class='rusttest'>fn main() {
    let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
// let buf = b&quot;whatever&quot;; // byte string literal. buf: &amp;[u8; 8]
let buf = b&quot;whatever&quot;; // buf: &amp;[u8; 8] はバイト文字列リテラルです。
let result = f.write(buf);
// result.unwrap(); // ignore the error
// result.unwrap(); // エラーを無視します。
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='string'>&quot;foo.txt&quot;</span>).<span class='ident'>expect</span>(<span class='string'>&quot;Couldn’t open foo.txt&quot;</span>);
<span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='string'>b&quot;whatever&quot;</span>; <span class='comment'>// buf: &amp;[u8; 8] はバイト文字列リテラルです。</span>
<span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>f</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>);</pre>

<!-- Here’s the error: -->

<p>エラーは以下のようになります。</p>

<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>

<!-- We need to `use` the `Write` trait first: -->

<p>始めに <code>Write</code> トレイトを <code>use</code> する必要があります。</p>

<span class='rusttest'>fn main() {
    use std::io::Write;

let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
// result.unwrap(); // ignore the error
// result.unwrap(); // エラーを無視します。
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Write</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='string'>&quot;foo.txt&quot;</span>).<span class='ident'>expect</span>(<span class='string'>&quot;Couldn’t open foo.txt&quot;</span>);
<span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='string'>b&quot;whatever&quot;</span>;
<span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>f</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>);</pre>

<!-- This will compile without error. -->

<p>これはエラー無しでコンパイルされます。</p>

<!-- This means that even if someone does something bad like add methods to `i32`,
it won’t affect you, unless you `use` that trait. -->

<p>これは、例え誰かが <code>i32</code> へメソッドを追加するような望ましくない何かを行ったとしても、あなたがトレイトを <code>use</code> しない限り、影響はないことを意味します。</p>

<!-- There’s one more restriction on implementing traits: either the trait, or the
type you’re writing the `impl` for, must be defined by you. So, we could
implement the `HasArea` type for `i32`, because `HasArea` is in our code. But
if we tried to implement `ToString`, a trait provided by Rust, for `i32`, we could
not, because neither the trait nor the type are in our code. -->

<p>トレイトの実装における制限はもう1つあります。トレイト、またはあなたが書いている <code>impl</code> の対象となる型は、あなた自身によって実装されなければなりません。 <code>HasArea</code> は私たちが記述したコードであるため、 <code>i32</code> のための <code>HasArea</code> を実装することができます。しかし、 <code>i32</code> のためにRustによって提供されている <code>ToString</code> トレイトを実装したいとしても、トレイトと型が共に私たちの記述したコードでないため、それはできません。</p>

<!-- One last thing about traits: generic functions with a trait bound use
‘monomorphization’ (mono: one, morph: form), so they are statically dispatched.
What’s that mean? Check out the chapter on [trait objects][to] for more details. -->

<p>トレイトに関して最後に1つ。トレイト境界が設定されたジェネリック関数は「単相化」(monomorphization)（mono: 単一の、morph: 相）されるため、静的ディスパッチが行われます。一体どういう意味でしょうか？詳細については、 <a href="trait-objects.html">トレイトオブジェクト</a> の章をチェックしてください。</p>

<!-- # Multiple trait bounds -->

<h1 id='複数のトレイト境界' class='section-header'><a href='#複数のトレイト境界'>複数のトレイト境界</a></h1>
<!-- You’ve seen that you can bound a generic type parameter with a trait: -->

<p>トレイトによってジェネリックな型パラメータに境界が与えられることを見てきました。</p>

<span class='rusttest'>fn main() {
    fn foo&lt;T: Clone&gt;(x: T) {
    x.clone();
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
}</pre>

<!-- If you need more than one bound, you can use `+`: -->

<p>2つ以上の境界を与えたい場合、 <code>+</code> を使えます。</p>

<span class='rusttest'>fn main() {
    use std::fmt::Debug;

fn foo&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    println!(&quot;{:?}&quot;, x);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<!-- `T` now needs to be both `Clone` as well as `Debug`. -->

<p>この <code>T</code> 型は <code>Clone</code> と <code>Debug</code> 両方が必要です。</p>

<!-- # Where clause -->

<h1 id='where-節' class='section-header'><a href='#where-節'>Where 節</a></h1>
<!-- Writing functions with only a few generic types and a small number of trait
bounds isn’t too bad, but as the number increases, the syntax gets increasingly
awkward: -->

<p>ジェネリック型もトレイト境界の数も少ない関数を書いているうちは悪く無いのですが、数が増えるとこの構文ではいよいよ不便になってきます。</p>

<span class='rusttest'>fn main() {
    use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span>, <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}</pre>

<!-- The name of the function is on the far left, and the parameter list is on the
far right. The bounds are getting in the way. -->

<p>関数名は左端にあり、引数リストは右端にあります。境界を記述する部分が邪魔になっているのです。</p>

<!-- Rust has a solution, and it’s called a ‘`where` clause’: -->

<p>Rustは「 <code>where</code> 節」と呼ばれる解決策を持っています。</p>

<span class='rusttest'>use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn main() {
    foo(&quot;Hello&quot;, &quot;world&quot;);
    bar(&quot;Hello&quot;, &quot;world&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span>, <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>) {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}

<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>K</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>) <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Clone</span>, <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span> {
    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>(<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>);
    <span class='ident'>bar</span>(<span class='string'>&quot;Hello&quot;</span>, <span class='string'>&quot;world&quot;</span>);
}</pre>

<!-- `foo()` uses the syntax we showed earlier, and `bar()` uses a `where` clause.
All you need to do is leave off the bounds when defining your type parameters,
and then add `where` after the parameter list. For longer lists, whitespace can
be added: -->

<p><code>foo()</code> は先程見せたままの構文で、 <code>bar()</code> は <code>where</code> 節を用いています。型パラメータを定義する際に境界の設定をせず、引数リストの後ろに <code>where</code> を追加するだけで良いのです。長いリストであれば、空白を加えることもできます。</p>

<span class='rusttest'>fn main() {
    use std::fmt::Debug;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span>;

<span class='kw'>fn</span> <span class='ident'>bar</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>K</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='ident'>T</span>, <span class='ident'>y</span>: <span class='ident'>K</span>)
    <span class='kw'>where</span> <span class='ident'>T</span>: <span class='ident'>Clone</span>,
          <span class='ident'>K</span>: <span class='ident'>Clone</span> <span class='op'>+</span> <span class='ident'>Debug</span> {

    <span class='ident'>x</span>.<span class='ident'>clone</span>();
    <span class='ident'>y</span>.<span class='ident'>clone</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>y</span>);
}</pre>

<!-- This flexibility can add clarity in complex situations. -->

<p>この柔軟性により複雑な状況であっても可読性を改善できます。</p>

<!-- `where` is also more powerful than the simpler syntax. For example: -->

<p>また、<code>where</code> は基本の構文よりも強力です。例えば、</p>

<span class='rusttest'>fn main() {
    trait ConvertTo&lt;Output&gt; {
    fn convert(&amp;self) -&gt; Output;
}

impl ConvertTo&lt;i64&gt; for i32 {
    fn convert(&amp;self) -&gt; i64 { *self as i64 }
}

// can be called with T == i32
// T == i32の時に呼び出せる
fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
    x.convert()
}

// can be called with T == i64
// T == i64の時に呼び出せる
fn inverse&lt;T&gt;() -&gt; T
       // this is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;
        // これは「ConvertTo&lt;i64&gt;」であるかのようにConvertToを用いている
        where i32: ConvertTo&lt;T&gt; {
    42.convert()
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>Output</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>convert</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Output</span>;
}

<span class='kw'>impl</span> <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i64</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>i32</span> {
    <span class='kw'>fn</span> <span class='ident'>convert</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>i64</span> { <span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='ident'>i64</span> }
}

<span class='comment'>// T == i32の時に呼び出せる</span>
<span class='kw'>fn</span> <span class='ident'>normal</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>i64</span><span class='op'>&gt;&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>i64</span> {
    <span class='ident'>x</span>.<span class='ident'>convert</span>()
}

<span class='comment'>// T == i64の時に呼び出せる</span>
<span class='kw'>fn</span> <span class='ident'>inverse</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>() <span class='op'>-&gt;</span> <span class='ident'>T</span>
        <span class='comment'>// これは「ConvertTo&lt;i64&gt;」であるかのようにConvertToを用いている</span>
        <span class='kw'>where</span> <span class='ident'>i32</span>: <span class='ident'>ConvertTo</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='number'>42</span>.<span class='ident'>convert</span>()
}</pre>

<!-- This shows off the additional feature of `where` clauses: they allow bounds
on the left-hand side not only of type parameters `T`, but also of types (`i32` in this case). In this example, `i32` must implement
`ConvertTo<T>`. Rather than defining what `i32` is (since that's obvious), the
`where` clause here constrains `T`. -->

<p>ここでは <code>where</code> 節の追加機能を披露しています。この節は左辺に型パラメータ <code>T</code> だけでなく具体的な型(このケースでは <code>i32</code> )を指定できます。この例だと、 <code>i32</code> は <code>ConvertTo&lt;T&gt;</code> を実装していなければなりません。(それは明らかですから)ここの <code>where</code> 節は <code>i32</code> が何であるか定義しているというよりも、 <code>T</code> に対して制約を設定しているといえるでしょう。</p>

<!-- # Default methods -->

<h1 id='デフォルトメソッド' class='section-header'><a href='#デフォルトメソッド'>デフォルトメソッド</a></h1>
<!-- A default method can be added to a trait definition if it is already known how a typical implementor will define a method. For example, `is_invalid()` is defined as the opposite of `is_valid()`: -->

<p>典型的な実装者がどうメソッドを定義するか既に分かっているならば、トレイトの定義にデフォルトメソッドを加えることができます。例えば、以下の <code>is_invalid()</code> は <code>is_valid()</code> の反対として定義されます。</p>

<span class='rusttest'>fn main() {
    trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>is_valid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;

    <span class='kw'>fn</span> <span class='ident'>is_invalid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='op'>!</span><span class='self'>self</span>.<span class='ident'>is_valid</span>() }
}</pre>

<!-- Implementors of the `Foo` trait need to implement `is_valid()` but not `is_invalid()` due to the added default behavior. This default behavior can still be overridden as in: -->

<p><code>Foo</code> トレイトの実装者は <code>is_valid()</code> を実装する必要がありますが、デフォルトの動作が加えられている <code>is_invalid()</code> には必要ありません。</p>

<span class='rusttest'>fn main() {
    trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
struct UseDefault;

impl Foo for UseDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called UseDefault.is_valid.&quot;);
        true
    }
}

struct OverrideDefault;

impl Foo for OverrideDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_valid.&quot;);
        true
    }

    fn is_invalid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_invalid!&quot;);
//         true // overrides the expected value of is_invalid()
        true // 予期されるis_invalid()の値をオーバーライドする
    }
}

let default = UseDefault;
// assert!(!default.is_invalid()); // prints &quot;Called UseDefault.is_valid.&quot;
assert!(!default.is_invalid()); // 「Called UseDefault.is_valid.」を表示

let over = OverrideDefault;
// assert!(over.is_invalid()); // prints &quot;Called OverrideDefault.is_invalid!&quot;
assert!(over.is_invalid()); // 「Called OverrideDefault.is_invalid!」を表示
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>UseDefault</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>UseDefault</span> {
    <span class='kw'>fn</span> <span class='ident'>is_valid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Called UseDefault.is_valid.&quot;</span>);
        <span class='boolvalue'>true</span>
    }
}

<span class='kw'>struct</span> <span class='ident'>OverrideDefault</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>OverrideDefault</span> {
    <span class='kw'>fn</span> <span class='ident'>is_valid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Called OverrideDefault.is_valid.&quot;</span>);
        <span class='boolvalue'>true</span>
    }

    <span class='kw'>fn</span> <span class='ident'>is_invalid</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Called OverrideDefault.is_invalid!&quot;</span>);
        <span class='boolvalue'>true</span> <span class='comment'>// 予期されるis_invalid()の値をオーバーライドする</span>
    }
}

<span class='kw'>let</span> <span class='ident'>default</span> <span class='op'>=</span> <span class='ident'>UseDefault</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>default</span>.<span class='ident'>is_invalid</span>()); <span class='comment'>// 「Called UseDefault.is_valid.」を表示</span>

<span class='kw'>let</span> <span class='ident'>over</span> <span class='op'>=</span> <span class='ident'>OverrideDefault</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>over</span>.<span class='ident'>is_invalid</span>()); <span class='comment'>// 「Called OverrideDefault.is_invalid!」を表示</span></pre>

<!-- # Inheritance -->

<h1 id='継承' class='section-header'><a href='#継承'>継承</a></h1>
<!-- Sometimes, implementing a trait requires implementing another trait: -->

<p>時々、1つのトレイトの実装に他のトレイトの実装が必要になります。</p>

<span class='rusttest'>fn main() {
    trait Foo {
    fn foo(&amp;self);
}

trait FooBar : Foo {
    fn foobar(&amp;self);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}

<span class='kw'>trait</span> <span class='ident'>FooBar</span> : <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>foobar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}</pre>

<!-- Implementors of `FooBar` must also implement `Foo`, like this: -->

<p><code>FooBar</code> の実装者は <code>Foo</code> も実装しなければなりません。以下のようになります。</p>

<span class='rusttest'>fn main() {
    trait Foo {
    fn foo(&amp;self);
}
trait FooBar : Foo {
    fn foobar(&amp;self);
}
struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Baz</span>;

<span class='kw'>impl</span> <span class='ident'>Foo</span> <span class='kw'>for</span> <span class='ident'>Baz</span> {
    <span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;foo&quot;</span>); }
}

<span class='kw'>impl</span> <span class='ident'>FooBar</span> <span class='kw'>for</span> <span class='ident'>Baz</span> {
    <span class='kw'>fn</span> <span class='ident'>foobar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;foobar&quot;</span>); }
}</pre>

<!-- If we forget to implement `Foo`, Rust will tell us: -->

<p><code>Foo</code> の実装を忘れると、Rustは以下のように伝えるでしょう。</p>

<pre><code class="language-text">error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
</code></pre>

<!-- # Deriving -->

<h1 id='derive' class='section-header'><a href='#derive'>Derive</a></h1>
<!-- Implementing traits like `Debug` and `Default` repeatedly can become
quite tedious. For that reason, Rust provides an [attribute][attributes] that
allows you to let Rust automatically implement traits for you: -->

<p>繰り返し<code>Debug</code> や <code>Default</code> のようなトレイトを実装するのは非常にうんざりさせられます。そのような理由から、Rustは自動的にトレイトを実装するための <a href="attributes.html">アトリビュート</a> を提供しています。</p>

<span class='rusttest'>#[derive(Debug)]
struct Foo;

fn main() {
    println!(&quot;{:?}&quot;, Foo);
}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>Foo</span>);
}</pre>

<!-- However, deriving is limited to a certain set of traits: -->

<p>ただし、deriveは以下の特定のトレイトに制限されています。</p>

<ul>
<li><a href="../core/clone/trait.Clone.html"><code>Clone</code></a></li>
<li><a href="../core/marker/trait.Copy.html"><code>Copy</code></a></li>
<li><a href="../core/fmt/trait.Debug.html"><code>Debug</code></a></li>
<li><a href="../core/default/trait.Default.html"><code>Default</code></a></li>
<li><a href="../core/cmp/trait.Eq.html"><code>Eq</code></a></li>
<li><a href="../core/hash/trait.Hash.html"><code>Hash</code></a></li>
<li><a href="../core/cmp/trait.Ord.html"><code>Ord</code></a></li>
<li><a href="../core/cmp/trait.PartialEq.html"><code>PartialEq</code></a></li>
<li><a href="../core/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>