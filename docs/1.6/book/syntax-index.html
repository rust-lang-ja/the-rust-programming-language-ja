<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>構文の索引</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a class='active' href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book-ja/">最新版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。リンク先のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">構文の索引</h1>
    <!-- % Syntax Index -->

<!-- ## Keywords -->

<h2 id='キーワード' class='section-header'><a href='#キーワード'>キーワード</a></h2>
<!-- * `as`: primitive casting.  See [Casting Between Types (`as`)]. -->

<!-- * `break`: break out of loop.  See [Loops (Ending Iteration Early)]. -->

<!-- * `const`: constant items and constant raw pointers.  See [`const` and `static`], [Raw Pointers]. -->

<!-- * `continue`: continue to next loop iteration.  See [Loops (Ending Iteration Early)]. -->

<!-- * `crate`: external crate linkage.  See [Crates and Modules (Importing External Crates)]. -->

<!-- * `else`: fallback for `if` and `if let` constructs.  See [`if`], [`if let`]. -->

<!-- * `enum`: defining enumeration.  See [Enums]. -->

<!-- * `extern`: external crate, function, and variable linkage.  See [Crates and Modules (Importing External Crates)], [Foreign Function Interface]. -->

<!-- * `false`: boolean false literal.  See [Primitive Types (Booleans)]. -->

<!-- * `fn`: function definition and function pointer types.  See [Functions]. -->

<!-- * `for`: iterator loop, part of trait `impl` syntax, and higher-ranked lifetime syntax.  See [Loops (`for`)], [Method Syntax]. -->

<!-- * `if`: conditional branching.  See [`if`], [`if let`]. -->

<!-- * `impl`: inherent and trait implementation blocks.  See [Method Syntax]. -->

<!-- * `in`: part of `for` loop syntax.  See [Loops (`for`)]. -->

<!-- * `let`: variable binding.  See [Variable Bindings]. -->

<!-- * `loop`: unconditional, infinite loop.  See [Loops (`loop`)]. -->

<!-- * `match`: pattern matching.  See [Match]. -->

<!-- * `mod`: module declaration.  See [Crates and Modules (Defining Modules)]. -->

<!-- * `move`: part of closure syntax.  See [Closures (`move` closures)]. -->

<!-- * `mut`: denotes mutability in pointer types and pattern bindings.  See [Mutability]. -->

<!-- * `pub`: denotes public visibility in `struct` fields, `impl` blocks, and modules.  See [Crates and Modules (Exporting a Public Interface)]. -->

<!-- * `ref`: by-reference binding.  See [Patterns (`ref` and `ref mut`)]. -->

<!-- * `return`: return from function.  See [Functions (Early Returns)]. -->

<!-- * `Self`: implementor type alias.  See [Traits]. -->

<!-- * `self`: method subject.  See [Method Syntax (Method Calls)]. -->

<!-- * `static`: global variable.  See [`const` and `static` (`static`)]. -->

<!-- * `struct`: structure definition.  See [Structs]. -->

<!-- * `trait`: trait definition.  See [Traits]. -->

<!-- * `true`: boolean true literal.  See [Primitive Types (Booleans)]. -->

<!-- * `type`: type alias, and associated type definition.  See [`type` Aliases], [Associated Types]. -->

<!-- * `unsafe`: denotes unsafe code, functions, traits, and implementations.  See [Unsafe]. -->

<!-- * `use`: import symbols into scope.  See [Crates and Modules (Importing Modules with `use`)]. -->

<!-- * `where`: type constraint clauses.  See [Traits (`where` clause)]. -->

<!-- * `while`: conditional loop.  See [Loops (`while`)]. -->

<ul>
<li><code>as</code>: プリミティブのキャスト。 <a href="casting-between-types.html#as">型間のキャスト (<code>as</code>)</a> 参照。</li>
<li><code>break</code>: ループからの脱却。<a href="loops.html#%E5%8F%8D%E5%BE%A9%E3%81%AE%E6%97%A9%E6%9C%9F%E7%B5%82%E4%BA%86">ループ (反復の早期終了)</a> 参照。</li>
<li><code>const</code>: 定数および定数ポインタ。 <a href="const-and-static.html"><code>const</code> と <code>static</code></a> 、 <a href="raw-pointers.html">生ポインタ</a> 参照。</li>
<li><code>continue</code>: 次の反復への継続。 <a href="loops.html#%E5%8F%8D%E5%BE%A9%E3%81%AE%E6%97%A9%E6%9C%9F%E7%B5%82%E4%BA%86">ループ (反復の早期終了)</a> 参照。</li>
<li><code>crate</code>: 外部クレートのリンク。 <a href="crates-and-modules.html#%E5%A4%96%E9%83%A8%E3%82%AF%E3%83%AC%E3%83%BC%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88">クレートとモジュール (外部クレートのインポート)</a> 参照</li>
<li><code>else</code>: <code>if</code> と <code>if let</code> が形成するフォールバック。 <a href="if.html"><code>if</code></a> 、 <a href="if-let.html"><code>if let</code></a> 参照。</li>
<li><code>enum</code>: 列挙型の定義。 <a href="enums.html">列挙型</a> 参照。</li>
<li><code>extern</code>: 外部クレート、関数、変数のリンク。  <a href="crates-and-modules.html#%E5%A4%96%E9%83%A8%E3%82%AF%E3%83%AC%E3%83%BC%E3%83%88%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88">クレートとモジュール (外部クレートのインポート)</a>、 <a href="ffi.html">他言語関数インターフェイス</a> 参照。</li>
<li><code>false</code>: ブーリアン型の偽値のリテラル。 <a href="primitive-types.html#%E3%83%96%E3%83%BC%E3%83%AA%E3%82%A2%E3%83%B3%E5%9E%8B">プリミティブ型 (ブーリアン型)</a> 参照。</li>
<li><code>fn</code>: 関数定義及び関数ポインタ型。 <a href="functions.html">関数</a> 参照。</li>
<li><code>for</code>: イテレータループ、 トレイト <code>impl</code>  構文の一部、 あるいは 高階ライフタイム構文。  <a href="loops.html#for">ループ (<code>for</code>)</a> 、 <a href="method-syntax.html">メソッド構文</a> 参照。</li>
<li><code>if</code>: 条件分岐  <a href="if.html"><code>if</code></a> 、 <a href="if-let.html"><code>if let</code></a> 参照。</li>
<li><code>impl</code>: 固有及びトレイト実装のブロック。 <a href="method-syntax.html">メソッド構文</a> 参照。</li>
<li><code>in</code>: <code>for</code> ループ構文の一部。 <a href="loops.html#for">ループ (<code>for</code>)</a> 参照。</li>
<li><code>let</code>: 変数束縛。 <a href="variable-bindings.html">変数束縛</a> 参照。</li>
<li><code>loop</code>: 条件無しの無限ループ。 <a href="loops.html#loop">ループ (<code>loop</code>)</a> 参照。</li>
<li><code>match</code>: パターンマッチ。 <a href="match.html">マッチ</a> 参照。</li>
<li><code>mod</code>: モジュール宣言。   <a href="crates-and-modules.html#%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">クレートとモジュール (モジュールを定義する)</a> 参照。</li>
<li><code>move</code>: クロージャ構文の一部。 <a href="closures.html#move-%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3">クロージャ (<code>move</code> クロージャ)</a> 参照。</li>
<li><code>mut</code>: ポインタ型とパターン束縛におけるミュータビリティを表す。 <a href="mutability.html">ミュータビリティ</a> 参照。</li>
<li><code>pub</code>: <code>struct</code> のフィールド、 <code>impl</code> ブロック、 モジュールにおいて可視性を表す。 <a href="crates-and-modules.html#%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%81%AA%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9%E3%81%AE%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88">クレートとモジュール (パブリックなインターフェースのエクスポート)</a> 参照。</li>
<li><code>ref</code>: 参照束縛。 <a href="patterns.html#ref-%E3%81%A8-ref-mut">パターン (<code>ref</code> と <code>ref mut</code>)</a> 参照。</li>
<li><code>return</code>: 関数からのリターン。 <a href="functions.html#%E6%97%A9%E6%9C%9F%E3%83%AA%E3%82%BF%E3%83%BC%E3%83%B3">関数 (早期リターン)</a> 参照。</li>
<li><code>Self</code>: 実装者の型のエイリアス。 <a href="traits.html">トレイト</a> 参照。</li>
<li><code>self</code>: メソッドの主語。 <a href="method-syntax.html#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97">メソッド構文 (メソッド呼び出し)</a> 参照。</li>
<li><code>static</code>: グローバル変数。 <a href="const-and-static.html#static"><code>const</code> と <code>static</code> (<code>static</code>)</a> 参照。</li>
<li><code>struct</code>: 構造体定義。 <a href="structs.html">構造体</a> 参照。</li>
<li><code>trait</code>: トレイト定義。 <a href="traits.html">トレイト</a> 参照。</li>
<li><code>true</code>: ブーリアン型の真値のリテラル。 <a href="primitive-types.html#%E3%83%96%E3%83%BC%E3%83%AA%E3%82%A2%E3%83%B3%E5%9E%8B">プリミティブ型 (ブーリアン型)</a> 参照。</li>
<li><code>type</code>: 型エイリアス、または関連型定義。 <a href="type-aliases.html"><code>type</code> エイリアス</a> 、 <a href="associated-types.html">関連型</a> 参照。</li>
<li><code>unsafe</code>: アンセーフなコード、関数、トレイト、そして実装を表す。 <a href="unsafe.html">Unsafe</a> 参照。</li>
<li><code>use</code>: スコープにシンボルをインポートする。 <a href="crates-and-modules.html#use-%E3%81%A7%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B">クレートとモジュール (<code>use</code> でモジュールをインポートする)</a> 参照。</li>
<li><code>where</code>: 型制約節。 <a href="traits.html#where-%E7%AF%80">トレイト (<code>where</code> 節)</a> 参照。</li>
<li><code>while</code>: 条件付きループ。 <a href="loops.html#while">ループ (<code>while</code>)</a> 参照。</li>
</ul>

<!-- ## Operators and Symbols -->

<h2 id='演算子とシンボル' class='section-header'><a href='#演算子とシンボル'>演算子とシンボル</a></h2>
<!-- * `!` (`ident!(…)`, `ident!{…}`, `ident![…]`): denotes macro expansion.  See [Macros]. -->

<!-- * `!` (`!expr`): bitwise or logical complement.  Overloadable (`Not`). -->

<!-- * `%` (`expr % expr`): arithmetic remainder.  Overloadable (`Rem`). -->

<!-- * `%=` (`var %= expr`): arithmetic remainder & assignment. -->

<!-- * `&` (`expr & expr`): bitwise and.  Overloadable (`BitAnd`). -->

<!-- * `&` (`&expr`): borrow.  See [References and Borrowing]. -->

<!-- * `&` (`&type`, `&mut type`, `&'a type`, `&'a mut type`): borrowed pointer type.  See [References and Borrowing]. -->

<!-- * `&=` (`var &= expr`): bitwise and & assignment. -->

<!-- * `&&` (`expr && expr`): logical and. -->

<!-- * `*` (`expr * expr`): arithmetic multiplication.  Overloadable (`Mul`). -->

<!-- * `*` (`*expr`): dereference. -->

<!-- * `*` (`*const type`, `*mut type`): raw pointer.  See [Raw Pointers]. -->

<!-- * `*=` (`var *= expr`): arithmetic multiplication & assignment. -->

<!-- * `+` (`expr + expr`): arithmetic addition.  Overloadable (`Add`). -->

<!-- * `+` (`trait + trait`, `'a + trait`): compound type constraint.  See [Traits (Multiple Trait Bounds)]. -->

<!-- * `+=` (`var += expr`): arithmetic addition & assignment. -->

<!-- * `,`: argument and element separator.  See [Attributes], [Functions], [Structs], [Generics], [Match], [Closures], [Crates and Modules (Importing Modules with `use`)]. -->

<!-- * `-` (`expr - expr`): arithmetic subtraction.  Overloadable (`Sub`). -->

<!-- * `-` (`- expr`): arithmetic negation.  Overloadable (`Neg`). -->

<!-- * `-=` (`var -= expr`): arithmetic subtraction & assignment. -->

<!-- * `->` (`fn(…) -> type`, `|…| -> type`): function and closure return type.  See [Functions], [Closures]. -->

<!-- * `-> !` (`fn(…) -> !`, `|…| -> !`): diverging function or closure. See [Diverging Functions]. -->

<!-- * `.` (`expr.ident`): member access.  See [Structs], [Method Syntax]. -->

<!-- * `..` (`..`, `expr..`, `..expr`, `expr..expr`): right-exclusive range literal. -->

<!-- * `..` (`..expr`): struct literal update syntax.  See [Structs (Update syntax)]. -->

<!-- * `..` (`variant(x, ..)`, `struct_type { x, .. }`): "and the rest" pattern binding.  See [Patterns (Ignoring bindings)]. -->

<!-- * `...` (`expr ... expr`): inclusive range pattern.  See [Patterns (Ranges)]. -->

<!-- * `/` (`expr / expr`): arithmetic division.  Overloadable (`Div`). -->

<!-- * `/=` (`var /= expr`): arithmetic division & assignment. -->

<!-- * `:` (`pat: type`, `ident: type`): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits]. -->

<!-- * `:` (`ident: expr`): struct field initializer.  See [Structs]. -->

<!-- * `:` (`'a: loop {…}`): loop label.  See [Loops (Loops Labels)]. -->

<!-- * `;`: statement and item terminator. -->

<!-- * `;` (`[…; len]`): part of fixed-size array syntax.  See [Primitive Types (Arrays)]. -->

<!-- * `<<` (`expr << expr`): left-shift.  Overloadable (`Shl`). -->

<!-- * `<<=` (`var <<= expr`): left-shift & assignment. -->

<!-- * `<` (`expr < expr`): less-than comparison.  Overloadable (`Cmp`, `PartialCmp`). -->

<!-- * `<=` (`var <= expr`): less-than or equal-to comparison.  Overloadable (`Cmp`, `PartialCmp`). -->

<!-- * `=` (`var = expr`, `ident = type`): assignment/equivalence.  See [Variable Bindings], [`type` Aliases], generic parameter defaults. -->

<!-- * `==` (`var == expr`): comparison.  Overloadable (`Eq`, `PartialEq`). -->

<!-- * `=>` (`pat => expr`): part of match arm syntax.  See [Match]. -->

<!-- * `>` (`expr > expr`): greater-than comparison.  Overloadable (`Cmp`, `PartialCmp`). -->

<!-- * `>=` (`var >= expr`): greater-than or equal-to comparison.  Overloadable (`Cmp`, `PartialCmp`). -->

<!-- * `>>` (`expr >> expr`): right-shift.  Overloadable (`Shr`). -->

<!-- * `>>=` (`var >>= expr`): right-shift & assignment. -->

<!-- * `@` (`ident @ pat`): pattern binding.  See [Patterns (Bindings)]. -->

<!-- * `^` (`expr ^ expr`): bitwise exclusive or.  Overloadable (`BitXor`). -->

<!-- * `^=` (`var ^= expr`): bitwise exclusive or & assignment. -->

<!-- * `|` (`expr | expr`): bitwise or.  Overloadable (`BitOr`). -->

<!-- * `|` (`pat | pat`): pattern alternatives.  See [Patterns (Multiple patterns)]. -->

<!-- * `|` (`|…| expr`): closures.  See [Closures]. -->

<!-- * `|=` (`var |= expr`): bitwise or & assignment. -->

<!-- * `||` (`expr || expr`): logical or. -->

<!-- * `_`: "ignored" pattern binding.  See [Patterns (Ignoring bindings)]. -->

<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): マクロ展開を表す。 <a href="macros.html">マクロ</a>参照</li>
<li><code>!</code> (<code>!expr</code>): ビット毎、あるいは論理の補数。 オーバロード可能 (<code>Not</code>)。</li>
<li><code>%</code> (<code>expr % expr</code>): 算術剰余算。オーバーロード可能 (<code>Rem</code>)。</li>
<li><code>%=</code> (<code>var %= expr</code>): 算術剰余算をして代入。</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>):ビット毎の論理積。 オーバーロード可能 (<code>BitAnd</code>)。</li>
<li><code>&amp;</code> (<code>&amp;expr</code>): 借用。 <a href="references-and-borrowing.html">参照と借用</a> 参照</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;&#39;a type</code>, <code>&amp;&#39;a mut type</code>): 借用されたポインタの型。 <a href="references-and-borrowing.html">参照と借用</a>参照。</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): ビット毎の論理積をして代入。</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): 論理積。</li>
<li><code>*</code> (<code>expr * expr</code>): 算術乗算。 オーバーロード可能 (<code>Mul</code>)。</li>
<li><code>*</code> (<code>*expr</code>): 参照外し。</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): 生ポインタ。 <a href="raw-pointers.html">生ポインタ</a>参照。</li>
<li><code>*=</code> (<code>var *= expr</code>): 算術乗算をして代入。</li>
<li><code>+</code> (<code>expr + expr</code>): 算術加算。オーバーロード可能 (<code>Add</code>)。</li>
<li><code>+</code> (<code>trait + trait</code>, <code>&#39;a + trait</code>): 合成型制約。 <a href="traits.html#%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E5%A2%83%E7%95%8C">トレイト (複数のトレイト境界)</a>参照。</li>
<li><code>+=</code> (<code>var += expr</code>): 算術加算をして代入。</li>
<li><code>,</code>: 引数または要素の区切り。  <a href="attributes.html">アトリビュート</a>、 <a href="functions.html">関数</a> 、 <a href="structs.html">構造体</a> 、 <a href="generics.html">ジェネリクス</a> 、 <a href="match.html">マッチ</a> 、 <a href="closures.html">クロージャ</a> 、 <a href="crates-and-modules.html#use-%E3%81%A7%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B">クレートとモジュール (<code>use</code> でモジュールをインポートする)</a> 参照。</li>
<li><code>-</code> (<code>expr - expr</code>): 算術減算。オーバーロード可能 (<code>Sub</code>)。</li>
<li><code>-</code> (<code>- expr</code>): 算術負。オーバーロード可能 (<code>Neg</code>)。</li>
<li><code>-=</code> (<code>var -= expr</code>): 算術減算をして代入。</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): 関数とクロージャの返り型。 <a href="functions.html">関数</a>、<a href="closures.html">クロージャ</a>参照。</li>
<li><code>-&gt; !</code> (<code>fn(…) -&gt; !</code>, <code>|…| -&gt; !</code>): 発散する関数またはクロージャ。<a href="functions.html#%E7%99%BA%E6%95%A3%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0">発散する関数</a>参照。</li>
<li><code>.</code> (<code>expr.ident</code>): メンバへのアクセス。 <a href="structs.html">構造体</a>、 <a href="method-syntax.html">メソッド構文</a>参照。</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): 右に開な区間のリテラル。</li>
<li><code>..</code> (<code>..expr</code>): 構造体リテラルのアップデート構文。<a href="structs.html#%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88%E6%A7%8B%E6%96%87">構造体 (アップデート構文)</a>参照。</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): 「〜と残り」のパターン束縛。 <a href="patterns.html#%E6%9D%9F%E7%B8%9B%E3%81%AE%E7%84%A1%E8%A6%96">パターン (束縛の無視)</a> 参照。</li>
<li><code>...</code> (<code>expr ... expr</code>): 閉区間リテラル。 <a href="patterns.html#%E3%83%AC%E3%83%B3%E3%82%B8">パターン (レンジ)</a> 参照。</li>
<li><code>/</code> (<code>expr / expr</code>): 算術除算。オーバーロード可能 (<code>Div</code>)。</li>
<li><code>/=</code> (<code>var /= expr</code>): 算術除算と代入。</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): 制約。<a href="variable-bindings.html">変数束縛</a> 、 <a href="functions.html">関数</a> 、 <a href="structs.html">構造体</a> 、 <a href="traits.html">トレイト</a> 参照。</li>
<li><code>:</code> (<code>ident: expr</code>): 構造体のフィールドの初期化。 <a href="structs.html">構造体</a> 参照。</li>
<li><code>:</code> (<code>&#39;a: loop {…}</code>): ループラベル。 <a href="loops.html#%E3%83%AB%E3%83%BC%E3%83%97%E3%83%A9%E3%83%99%E3%83%AB">ループ (ループラベル)</a> 参照。</li>
<li><code>;</code>: 文またはアイテムの区切り。</li>
<li><code>;</code> (<code>[…; len]</code>): 固定長配列構文の一部。 <a href="primitive-types.html#%E9%85%8D%E5%88%97">プリミティブ型 (配列)</a> 参照。</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): 左シフト。オーバーロード可能 (<code>Shl</code>)。</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): 左シフトして代入。</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): 「より小さい」の比較。オーバーロード可能 (<code>Cmp</code>, <code>PartialCmp</code>)。</li>
<li><code>&lt;=</code> (<code>var &lt;= expr</code>): 「以下」の比較。オーバーロード可能 (<code>Cmp</code>, <code>PartialCmp</code>)。</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): 代入/等価比較。 <a href="variable-bindings.html">変数束縛</a> 、 <a href="type-aliases.html"><code>type</code> エイリアス</a>、 ジェネリックパラメータのデフォルトを参照。</li>
<li><code>==</code> (<code>var == expr</code>): 比較。オーバーロード可能 (<code>Eq</code>, <code>PartialEq</code>)。</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): マッチの腕の構文の一部。 <a href="match.html">マッチ</a> 参照。</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): 「より大きい」の比較。オーバーロード可能 (<code>Cmp</code>, <code>PartialCmp</code>)。</li>
<li><code>&gt;=</code> (<code>var &gt;= expr</code>): 「以上」の比較。オーバーロード可能 (<code>Cmp</code>, <code>PartialCmp</code>)。</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): 右シフト。オーバーロード可能 (<code>Shr</code>)。</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): 右シフトして代入。</li>
<li><code>@</code> (<code>ident @ pat</code>): パターン束縛。 <a href="patterns.html#%E6%9D%9F%E7%B8%9B">パターン (束縛)</a> 参照。</li>
<li><code>^</code> (<code>expr ^ expr</code>): ビット毎の排他的論理和。オーバーロード可能 (<code>BitXor</code>)。</li>
<li><code>^=</code> (<code>var ^= expr</code>): ビット毎の排他的論理和をして代入。</li>
<li><code>|</code> (<code>expr | expr</code>): ビット毎の論理和。 オーバーロード可能 (<code>BitOr</code>)。</li>
<li><code>|</code> (<code>pat | pat</code>): パターンの「または」。 <a href="patterns.html#%E8%A4%87%E5%BC%8F%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">パターン (複式パターン)</a> 参照</li>
<li><code>|</code> (<code>|…| expr</code>): クロージャ。<a href="closures.html">クロージャ</a> 参照。</li>
<li><code>|=</code> (<code>var |= expr</code>): ビット毎の論理和をして代入。</li>
<li><code>||</code> (<code>expr || expr</code>): 論理和。</li>
<li><code>_</code>: 「無視」するパターン束縛。 <a href="patterns.html#%E6%9D%9F%E7%B8%9B%E3%81%AE%E7%84%A1%E8%A6%96">パターン (束縛の無視)</a>。</li>
</ul>

<!-- ## Other Syntax -->

<h2 id='他の構文' class='section-header'><a href='#他の構文'>他の構文</a></h2>
<!-- Various bits of standalone stuff. -->

<!-- * `'ident`: named lifetime or loop label.  See [Lifetimes], [Loops (Loops Labels)]. -->

<!-- * `…u8`, `…i32`, `…f64`, `…usize`, …: numeric literal of specific type. -->

<!-- * `"…"`: string literal.  See [Strings]. -->

<!-- * `r"…"`, `r#"…"#`, `r##"…"##`, …: raw string literal, escape characters are not processed. See [Reference (Raw String Literals)]. -->

<!-- * `b"…"`: byte string literal, constructs a `[u8]` instead of a string. See [Reference (Byte String Literals)]. -->

<!-- * `br"…"`, `br#"…"#`, `br##"…"##`, …: raw byte string literal, combination of raw and byte string literal. See [Reference (Raw Byte String Literals)]. -->

<!-- * `'…'`: character literal.  See [Primitive Types (`char`)]. -->

<!-- * `b'…'`: ASCII byte literal. -->

<!-- * `|…| expr`: closure.  See [Closures]. -->

<ul>
<li><code>&#39;ident</code>: 名前付きライフタイムまたはループラベル。 <a href="lifetimes.html">ライフタイム</a> 、 <a href="loops.html#%E3%83%AB%E3%83%BC%E3%83%97%E3%83%A9%E3%83%99%E3%83%AB">ループ (ループラベル)</a> 参照。</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …: その型の数値リテラル。</li>
<li><code>&quot;…&quot;</code>: 文字列リテラル。 <a href="strings.html">文字列</a> 参照。</li>
<li><code>r&quot;…&quot;</code>, <code>r#&quot;…&quot;#</code>, <code>r##&quot;…&quot;##</code>, …: 生文字列リテラル、 エスケープ文字は処理されない。 <a href="../reference.html#raw-string-literals">リファレンス (生文字列リテラル)</a> 参照。</li>
<li><code>b&quot;…&quot;</code>: バイト列リテラル、文字列ではなく <code>[u8]</code> を作る。 <a href="../reference.html#byte-string-literals">リファレンス (バイト列リテラル)</a> 参照。</li>
<li><code>br&quot;…&quot;</code>, <code>br#&quot;…&quot;#</code>, <code>br##&quot;…&quot;##</code>, …: 生バイト列リテラル。生文字列とバイト列リテラルの組み合わせ。 <a href="../reference.html#raw-byte-string-literals">リファレンス (生バイト列リテラル)</a> 参照</li>
<li><code>&#39;…&#39;</code>: 文字リテラル。 <a href="primitive-types.html#char">プリミティブ型 (<code>char</code>)</a> 参照。</li>
<li><code>b&#39;…&#39;</code>: ASCIIバイトリテラル。</li>
<li><code>|…| expr</code>: クロージャ。 <a href="closures.html">クロージャ</a> 参照。</li>
</ul>

<!-- Path-related syntax -->

<!-- * `ident::ident`: path.  See [Crates and Modules (Defining Modules)]. -->

<!-- * `::path`: path relative to the crate root (*i.e.* an explicitly absolute path).  See [Crates and Modules (Re-exporting with `pub use`)]. -->

<!-- * `self::path`: path relative to the current module (*i.e.* an explicitly relative path).  See [Crates and Modules (Re-exporting with `pub use`)]. -->

<!-- * `super::path`: path relative to the parent of the current module.  See [Crates and Modules (Re-exporting with `pub use`)]. -->

<!-- * `type::ident`: associated constants, functions, and types.  See [Associated Types]. -->

<!-- * `<type>::…`: associated item for a type which cannot be directly named (*e.g.* `<&T>::…`, `<[T]>::…`, *etc.*).  See [Associated Types]. -->

<ul>
<li><code>ident::ident</code>: パス。<a href="crates-and-modules.html#%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">クレートとモジュール (モジュールを定義する)</a> 参照。</li>
<li><code>::path</code>: クレートのルートからの相対パス (<em>つまり</em> 明示的な絶対パス)。 <a href="crates-and-modules.html#pub-use-%E3%81%AB%E3%82%88%E3%82%8B%E5%86%8D%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88">クレートとモジュール (<code>pub use</code> による再エクスポート)</a> 参照。</li>
<li><code>self::path</code>: 現在のモジュールからの相対パス (<em>つまり</em> 明示的な相対パス)。 <a href="crates-and-modules.html#pub-use-%E3%81%AB%E3%82%88%E3%82%8B%E5%86%8D%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88">クレートとモジュール (<code>pub use</code> による再エクスポート)</a> 参照。</li>
<li><code>super::path</code>: 現在のモジュールの親からの相対パス。 <a href="crates-and-modules.html#pub-use-%E3%81%AB%E3%82%88%E3%82%8B%E5%86%8D%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88">クレートとモジュール (<code>pub use</code> による再エクスポート)</a> 参照。</li>
<li><code>type::ident</code>: 関連定数、関数、型。 <a href="associated-types.html">関連型</a> 参照。</li>
<li><code>&lt;type&gt;::…</code>: 直接名前付けられない型の関連アイテム (<em>例えば</em> <code>&lt;&amp;T&gt;::…</code> 、 <code>&lt;[T]&gt;::…</code> 、 <em>など</em>)。 <a href="associated-types.html">関連型</a> 参照。</li>
</ul>

<!-- Generics -->

<!-- * `path<…>` (*e.g.* `Vec<u8>`): specifies parameters to generic type *in a type*.  See [Generics]. -->

<!-- * `path::<…>`, `method::<…>` (*e.g.* `"42".parse::<i32>()`): specifies parameters to generic type, function, or method *in an expression*. -->

<!-- * `fn ident<…> …`: define generic function.  See [Generics]. -->

<!-- * `struct ident<…> …`: define generic structure.  See [Generics]. -->

<!-- * `enum ident<…> …`: define generic enumeration.  See [Generics]. -->

<!-- * `impl<…> …`: define generic implementation. -->

<!-- * `for<…> type`: higher-ranked lifetime bounds. -->

<!-- * `type<ident=type>` (*e.g.* `Iterator<Item=T>`): a generic type where one or more associated types have specific assignments.  See [Associated Types]. -->

<ul>
<li><code>path&lt;…&gt;</code> (<em>例えば</em> <code>Vec&lt;u8&gt;</code>): <em>型での</em> ジェネリック型のパラメータの指定。 <a href="generics.html">ジェネリクス</a> 。</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>例えば</em> <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>): <em>式での</em> ジェネリック型あるいは関数、メソッドの型の指定。</li>
<li><code>fn ident&lt;…&gt; …</code>: ジェネリック関数を定義。 <a href="generics.html">ジェネリクス</a> 参照。</li>
<li><code>struct ident&lt;…&gt; …</code>: ジェネリック構造体を定義。 <a href="generics.html">ジェネリクス</a> 参照。</li>
<li><code>enum ident&lt;…&gt; …</code>: ジェネリック列挙型を定義。 <a href="generics.html">ジェネリクス</a> 参照。</li>
<li><code>impl&lt;…&gt; …</code>: ジェネリック実装を定義。</li>
<li><code>for&lt;…&gt; type</code>: 高階ライフタイム境界。</li>
<li><code>type&lt;ident=type&gt;</code> (<em>例えば</em> <code>Iterator&lt;Item=T&gt;</code>): 1つ以上の関連型について指定のあるジェネリック型。 <a href="associated-types.html">関連型</a> 参照。</li>
</ul>

<!-- Constraints -->

<!-- * `T: U`: generic parameter `T` constrained to types that implement `U`.  See [Traits]. -->

<!-- * `T: 'a`: generic type `T` must outlive lifetime `'a`. -->

<!-- * `'b: 'a`: generic lifetime `'b` must outlive lifetime `'a`. -->

<!-- * `T: ?Sized`: allow generic type parameter to be a dynamically-sized type.  See [Unsized Types (`?Sized`)]. -->

<!-- * `'a + trait`, `trait + trait`: compound type constraint.  See [Traits (Multiple Trait Bounds)]. -->

<ul>
<li><code>T: U</code>: <code>U</code> を実装する型に制約されたジェネリックパラメータ <code>T</code> 。 <a href="traits.html">トレイト</a> 参照。</li>
<li><code>T: &#39;a</code>: ジェネリック型 <code>T</code> はライフタイム <code>&#39;a</code> より長生きしなければならない。</li>
<li><code>&#39;b: &#39;a</code>: ジェネリックライフタイム <code>&#39;b</code> はライフタイム <code>&#39;a</code> より長生きしなければならない。</li>
<li><code>T: ?Sized</code>: ジェネリック型パラメータが動的サイズ型になること許可する。 <a href="unsized-types.html#sized">サイズ不定型 (<code>?Sized</code>)</a> 参照。</li>
<li><code>&#39;a + trait</code>, <code>trait + trait</code>: 合成型制約。 <a href="traits.html#%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E5%A2%83%E7%95%8C">トレイト (複数のトレイト境界)</a> 参照。</li>
</ul>

<!-- Macros and attributes -->

<!-- * `#[meta]`: outer attribute.  See [Attributes]. -->

<!-- * `#![meta]`: inner attribute.  See [Attributes]. -->

<!-- * `$ident`: macro substitution.  See [Macros]. -->

<!-- * `$ident:kind`: macro capture.  See [Macros]. -->

<!-- * `$(…)…`: macro repetition.  See [Macros]. -->

<ul>
<li><code>#[meta]</code>: 外側のアトリビュート。  <a href="attributes.html">アトリビュート</a> 参照。</li>
<li><code>#![meta]</code>: 内側のアトリビュート。 <a href="attributes.html">アトリビュート</a> 参照。</li>
<li><code>$ident</code>: マクロでの置換。 <a href="macros.html">マクロ</a> 参照。</li>
<li><code>$ident:kind</code>: マクロでの捕捉。 <a href="macros.html">マクロ</a> 参照。</li>
<li><code>$(…)…</code>: マクロでの繰り返し。 <a href="macros.html">マクロ</a> 参照。</li>
</ul>

<!-- Comments -->

<!-- * `//`: line comment.  See [Comments]. -->

<!-- * `//!`: inner line doc comment.  See [Comments]. -->

<!-- * `///`: outer line doc comment.  See [Comments]. -->

<!-- * `/*…*/`: block comment.  See [Comments]. -->

<!-- * `/*!…*/`: inner block doc comment.  See [Comments]. -->

<!-- * `/**…*/`: outer block doc comment.  See [Comments]. -->

<ul>
<li><code>//</code>: ラインコメント。 <a href="comments.html">コメント</a> 参照。</li>
<li><code>//!</code>: 内側の行ドキュメントコメント。 <a href="comments.html">コメント</a> 参照。</li>
<li><code>///</code>: 外側の行ドキュメントコメント <a href="comments.html">コメント</a> 参照。</li>
<li><code>/*…*/</code>: ブロックコメント。 <a href="comments.html">コメント</a> 参照。</li>
<li><code>/*!…*/</code>: 内側のブロックドキュメントコメント。 <a href="comments.html">コメント</a> 参照。</li>
<li><code>/**…*/</code>: 外側のブロックドキュメントコメント。 <a href="comments.html">コメント</a> 参照。</li>
</ul>

<!-- Various things involving parens and tuples -->

<!-- * `()`: empty tuple (*a.k.a.* unit), both literal and type. -->

<!-- * `(expr)`: parenthesized expression. -->

<!-- * `(expr,)`: single-element tuple expression.  See [Primitive Types (Tuples)]. -->

<!-- * `(type,)`: single-element tuple type.  See [Primitive Types (Tuples)]. -->

<!-- * `(expr, …)`: tuple expression.  See [Primitive Types (Tuples)]. -->

<!-- * `(type, …)`: tuple type.  See [Primitive Types (Tuples)]. -->

<!-- * `expr(expr, …)`: function call expression.  Also used to initialize tuple `struct`s and tuple `enum` variants.  See [Functions]. -->

<!-- * `ident!(…)`, `ident!{…}`, `ident![…]`: macro invocation.  See [Macros]. -->

<!-- * `expr.0`, `expr.1`, …: tuple indexing.  See [Primitive Types (Tuple Indexing)]. -->

<ul>
<li><code>()</code>: 空タプル(<em>あるいは</em> ユニット)の、リテラルと型両方。</li>
<li><code>(expr)</code>: 括弧付きの式。</li>
<li><code>(expr,)</code>: 1要素タプルの式。 <a href="primitive-types.html#%E3%82%BF%E3%83%97%E3%83%AB">プリミティブ型 (タプル)</a> 参照。</li>
<li><code>(type,)</code>: 1要素タプルの型。 <a href="primitive-types.html#%E3%82%BF%E3%83%97%E3%83%AB">プリミティブ型 (タプル)</a> 参照。</li>
<li><code>(expr, …)</code>: タプル式。 <a href="primitive-types.html#%E3%82%BF%E3%83%97%E3%83%AB">プリミティブ型 (タプル)</a> 参照。</li>
<li><code>(type, …)</code>: タプル型。 <a href="primitive-types.html#%E3%82%BF%E3%83%97%E3%83%AB">プリミティブ型 (タプル)</a> 参照。</li>
<li><code>expr(expr, …)</code>: 関数呼び出し式。また、 タプル <code>struct</code> 、 タプル <code>enum</code> のヴァリアントを初期化するのにも使われる。 <a href="functions.html">関数</a> 参照。</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: マクロの起動。 <a href="macros.html">マクロ</a> 参照。</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: タプルのインデックス。 <a href="primitive-types.html#%E3%82%BF%E3%83%97%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9">プリミティブ型 (タプルのインデックス)</a> 参照。</li>
</ul>

<!-- Bracey things -->

<!-- * `{…}`: block expression. -->

<!-- * `Type {…}`: `struct` literal.  See [Structs]. -->

<ul>
<li><code>{…}</code>: ブロック式。</li>
<li><code>Type {…}</code>: <code>struct</code> リテラル。 <a href="structs.html">構造体</a> 参照。</li>
</ul>

<!-- Brackety things -->

<!-- * `[…]`: array literal.  See [Primitive Types (Arrays)]. -->

<!-- * `[expr; len]`: array literal containing `len` copies of `expr`.  See [Primitive Types (Arrays)]. -->

<!-- * `[type; len]`: array type containing `len` instances of `type`.  See [Primitive Types (Arrays)]. -->

<!-- * `expr[expr]`: collection indexing.  Overloadable (`Index`, `IndexMut`). -->

<!-- * `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]`: collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, `RangeFull` as the "index". -->

<ul>
<li><code>[…]</code>: 配列リテラル。 <a href="primitive-types.html#%E9%85%8D%E5%88%97">プリミティブ型 (配列)</a> 参照。</li>
<li><code>[expr; len]</code>: <code>len</code> 個の <code>expr</code> を要素に持つ配列リテラル。 <a href="primitive-types.html#%E9%85%8D%E5%88%97">プリミティブ型 (配列)</a> 参照。</li>
<li><code>[type; len]</code>: <code>len</code> 個の<code>type</code> のインスタンスを要素に持つ配列型。 <a href="primitive-types.html#%E9%85%8D%E5%88%97">プリミティブ型 (配列)</a> 参照。</li>
<li><code>expr[expr]</code>: コレクションのインデックス。 オーバーロード可能(<code>Index</code>, <code>IndexMut</code>)。</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: コレクションのスライスのようなコレクションのインデックス。 <code>Range</code> 、 <code>RangeFrom</code> 、 <code>RangeTo</code> 、 <code>RangeFull</code> を「インデックス」として使う。</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>