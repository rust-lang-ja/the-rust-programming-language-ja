<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Coercions</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ul class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ul>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ul class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ul>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ul class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ul>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ul class='section'>
<li><a class='active' href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ul>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ul class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ul>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ul class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ul>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ul class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ul>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ul class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ul>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ul class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ul>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Coercions</h1>
    <p>Types can implicitly be coerced to change in certain contexts. These changes are
generally just <em>weakening</em> of types, largely focused around pointers and
lifetimes. They mostly exist to make Rust &quot;just work&quot; in more cases, and are
largely harmless.</p>

<p>Here&#39;s all the kinds of coercion:</p>

<p>Coercion is allowed between the following types:</p>

<ul>
<li>Transitivity: <code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to
<code>T_3</code></li>
<li>Pointer Weakening:

<ul>
<li><code>&amp;mut T</code> to <code>&amp;T</code></li>
<li><code>*mut T</code> to <code>*const T</code></li>
<li><code>&amp;T</code> to <code>*const T</code></li>
<li><code>&amp;mut T</code> to <code>*mut T</code></li>
</ul></li>
<li>Unsizing: <code>T</code> to <code>U</code> if <code>T</code> implements <code>CoerceUnsized&lt;U&gt;</code></li>
</ul>

<p><code>CoerceUnsized&lt;Pointer&lt;U&gt;&gt; for Pointer&lt;T&gt; where T: Unsize&lt;U&gt;</code> is implemented
for all pointer types (including smart pointers like Box and Rc). Unsize is
only implemented automatically, and enables the following transformations:</p>

<ul>
<li><code>[T; n]</code> =&gt; <code>[T]</code></li>
<li><code>T</code> =&gt; <code>Trait</code> where <code>T: Trait</code></li>
<li><code>Foo&lt;..., T, ...&gt;</code> =&gt; <code>Foo&lt;..., U, ...&gt;</code> where:

<ul>
<li><code>T: Unsize&lt;U&gt;</code></li>
<li><code>Foo</code> is a struct</li>
<li>Only the last field of <code>Foo</code> has type <code>T</code></li>
<li><code>T</code> is not part of the type of any other fields</li>
</ul></li>
</ul>

<p>Coercions occur at a <em>coercion site</em>. Any location that is explicitly typed
will cause a coercion to its type. If inference is necessary, the coercion will
not be performed. Exhaustively, the coercion sites for an expression <code>e</code> to
type <code>U</code> are:</p>

<ul>
<li>let statements, statics, and consts: <code>let x: U = e</code></li>
<li>Arguments to functions: <code>takes_a_U(e)</code></li>
<li>Any expression that will be returned: <code>fn foo() -&gt; U { e }</code></li>
<li>Struct literals: <code>Foo { some_u: e }</code></li>
<li>Array literals: <code>let x: [U; 10] = [e, ..]</code></li>
<li>Tuple literals: <code>let x: (U, ..) = (e, ..)</code></li>
<li>The last expression in a block: <code>let x: U = { ..; e }</code></li>
</ul>

<p>Note that we do not perform coercions when matching traits (except for
receivers, see below). If there is an impl for some type <code>U</code> and <code>T</code> coerces to
<code>U</code>, that does not constitute an implementation for <code>T</code>. For example, the
following will not type check, even though it is OK to coerce <code>t</code> to <code>&amp;T</code> and
there is an impl for <code>&amp;T</code>:</p>

<span class='rusttest'>trait Trait {}

fn foo&lt;X: Trait&gt;(t: X) {}

impl&lt;&#39;a&gt; Trait for &amp;&#39;a i32 {}


fn main() {
    let t: &amp;mut i32 = &amp;mut 0;
    foo(t);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Trait</span> {}

<span class='kw'>fn</span> <span class='ident'>foo</span><span class='op'>&lt;</span><span class='ident'>X</span>: <span class='ident'>Trait</span><span class='op'>&gt;</span>(<span class='ident'>t</span>: <span class='ident'>X</span>) {}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Trait</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>i32</span> {}


<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>t</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='number'>0</span>;
    <span class='ident'>foo</span>(<span class='ident'>t</span>);
}</pre>

<pre><code class="language-text">&lt;anon&gt;:10:5: 10:8 error: the trait `Trait` is not implemented for the type `&amp;mut i32` [E0277]
&lt;anon&gt;:10     foo(t);
              ^~~
</code></pre>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>