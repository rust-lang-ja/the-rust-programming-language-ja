<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>repr(Rust)</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ul class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ul>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ul class='section'>
<li><a class='active' href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ul>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ul class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a  href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ul>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ul class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ul>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ul class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ul>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ul class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ul>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ul class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ul>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ul class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ul>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ul class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ul>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">repr(Rust)</h1>
    <p>First and foremost, all types have an alignment specified in bytes. The
alignment of a type specifies what addresses are valid to store the value at. A
value of alignment <code>n</code> must only be stored at an address that is a multiple of
<code>n</code>. So alignment 2 means you must be stored at an even address, and 1 means
that you can be stored anywhere. Alignment is at least 1, and always a power of
2. Most primitives are generally aligned to their size, although this is
platform-specific behavior. In particular, on x86 <code>u64</code> and <code>f64</code> may be only
aligned to 32 bits.</p>

<p>A type&#39;s size must always be a multiple of its alignment. This ensures that an
array of that type may always be indexed by offsetting by a multiple of its
size. Note that the size and alignment of a type may not be known
statically in the case of <a href="exotic-sizes.html#dynamically-sized-types-dsts">dynamically sized types</a>.</p>

<p>Rust gives you the following ways to lay out composite data:</p>

<ul>
<li>structs (named product types)</li>
<li>tuples (anonymous product types)</li>
<li>arrays (homogeneous product types)</li>
<li>enums (named sum types -- tagged unions)</li>
</ul>

<p>An enum is said to be <em>C-like</em> if none of its variants have associated data.</p>

<p>Composite structures will have an alignment equal to the maximum
of their fields&#39; alignment. Rust will consequently insert padding where
necessary to ensure that all fields are properly aligned and that the overall
type&#39;s size is a multiple of its alignment. For instance:</p>

<span class='rusttest'>fn main() {
    struct A {
    a: u8,
    b: u32,
    c: u16,
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>A</span> {
    <span class='ident'>a</span>: <span class='ident'>u8</span>,
    <span class='ident'>b</span>: <span class='ident'>u32</span>,
    <span class='ident'>c</span>: <span class='ident'>u16</span>,
}</pre>

<p>will be 32-bit aligned on an architecture that aligns these primitives to their
respective sizes. The whole struct will therefore have a size that is a multiple
of 32-bits. It will potentially become:</p>

<span class='rusttest'>fn main() {
    struct A {
    a: u8,
    _pad1: [u8; 3], // to align `b`
    b: u32,
    c: u16,
    _pad2: [u8; 2], // to make overall size multiple of 4
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>A</span> {
    <span class='ident'>a</span>: <span class='ident'>u8</span>,
    <span class='ident'>_pad1</span>: [<span class='ident'>u8</span>; <span class='number'>3</span>], <span class='comment'>// to align `b`</span>
    <span class='ident'>b</span>: <span class='ident'>u32</span>,
    <span class='ident'>c</span>: <span class='ident'>u16</span>,
    <span class='ident'>_pad2</span>: [<span class='ident'>u8</span>; <span class='number'>2</span>], <span class='comment'>// to make overall size multiple of 4</span>
}</pre>

<p>There is <em>no indirection</em> for these types; all data is stored within the struct,
as you would expect in C. However with the exception of arrays (which are
densely packed and in-order), the layout of data is not by default specified in
Rust. Given the two following struct definitions:</p>

<span class='rusttest'>fn main() {
    struct A {
    a: i32,
    b: u64,
}

struct B {
    a: i32,
    b: u64,
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>A</span> {
    <span class='ident'>a</span>: <span class='ident'>i32</span>,
    <span class='ident'>b</span>: <span class='ident'>u64</span>,
}

<span class='kw'>struct</span> <span class='ident'>B</span> {
    <span class='ident'>a</span>: <span class='ident'>i32</span>,
    <span class='ident'>b</span>: <span class='ident'>u64</span>,
}</pre>

<p>Rust <em>does</em> guarantee that two instances of A have their data laid out in
exactly the same way. However Rust <em>does not</em> currently guarantee that an
instance of A has the same field ordering or padding as an instance of B, though
in practice there&#39;s no reason why they wouldn&#39;t.</p>

<p>With A and B as written, this point would seem to be pedantic, but several other
features of Rust make it desirable for the language to play with data layout in
complex ways.</p>

<p>For instance, consider this struct:</p>

<span class='rusttest'>fn main() {
    struct Foo&lt;T, U&gt; {
    count: u16,
    data1: T,
    data2: U,
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='ident'>count</span>: <span class='ident'>u16</span>,
    <span class='ident'>data1</span>: <span class='ident'>T</span>,
    <span class='ident'>data2</span>: <span class='ident'>U</span>,
}</pre>

<p>Now consider the monomorphizations of <code>Foo&lt;u32, u16&gt;</code> and <code>Foo&lt;u16, u32&gt;</code>. If
Rust lays out the fields in the order specified, we expect it to pad the
values in the struct to satisfy their alignment requirements. So if Rust
didn&#39;t reorder fields, we would expect it to produce the following:</p>

<span class='rusttest'>fn main() {
    struct Foo&lt;u16, u32&gt; {
    count: u16,
    data1: u16,
    data2: u32,
}

struct Foo&lt;u32, u16&gt; {
    count: u16,
    _pad1: u16,
    data1: u32,
    data2: u16,
    _pad2: u16,
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>u16</span>, <span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='ident'>count</span>: <span class='ident'>u16</span>,
    <span class='ident'>data1</span>: <span class='ident'>u16</span>,
    <span class='ident'>data2</span>: <span class='ident'>u32</span>,
}

<span class='kw'>struct</span> <span class='ident'>Foo</span><span class='op'>&lt;</span><span class='ident'>u32</span>, <span class='ident'>u16</span><span class='op'>&gt;</span> {
    <span class='ident'>count</span>: <span class='ident'>u16</span>,
    <span class='ident'>_pad1</span>: <span class='ident'>u16</span>,
    <span class='ident'>data1</span>: <span class='ident'>u32</span>,
    <span class='ident'>data2</span>: <span class='ident'>u16</span>,
    <span class='ident'>_pad2</span>: <span class='ident'>u16</span>,
}</pre>

<p>The latter case quite simply wastes space. An optimal use of space therefore
requires different monomorphizations to have <em>different field orderings</em>.</p>

<p><strong>Note: this is a hypothetical optimization that is not yet implemented in Rust
1.0</strong></p>

<p>Enums make this consideration even more complicated. Naively, an enum such as:</p>

<span class='rusttest'>fn main() {
    enum Foo {
    A(u32),
    B(u64),
    C(u8),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='ident'>Foo</span> {
    <span class='ident'>A</span>(<span class='ident'>u32</span>),
    <span class='ident'>B</span>(<span class='ident'>u64</span>),
    <span class='ident'>C</span>(<span class='ident'>u8</span>),
}</pre>

<p>would be laid out as:</p>

<span class='rusttest'>fn main() {
    struct FooRepr {
    data: u64, // this is either a u64, u32, or u8 based on `tag`
    tag: u8,   // 0 = A, 1 = B, 2 = C
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>FooRepr</span> {
    <span class='ident'>data</span>: <span class='ident'>u64</span>, <span class='comment'>// this is either a u64, u32, or u8 based on `tag`</span>
    <span class='ident'>tag</span>: <span class='ident'>u8</span>,   <span class='comment'>// 0 = A, 1 = B, 2 = C</span>
}</pre>

<p>And indeed this is approximately how it would be laid out in general (modulo the
size and position of <code>tag</code>).</p>

<p>However there are several cases where such a representation is inefficient. The
classic case of this is Rust&#39;s &quot;null pointer optimization&quot;: an enum consisting
of a single outer unit variant (e.g. <code>None</code>) and a (potentially nested) non-
nullable pointer variant (e.g. <code>&amp;T</code>) makes the tag unnecessary, because a null
pointer value can safely be interpreted to mean that the unit variant is chosen
instead. The net result is that, for example, <code>size_of::&lt;Option&lt;&amp;T&gt;&gt;() == size_of::&lt;&amp;T&gt;()</code>.</p>

<p>There are many types in Rust that are, or contain, non-nullable pointers such as
<code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, <code>String</code>, <code>&amp;T</code>, and <code>&amp;mut T</code>. Similarly, one can imagine
nested enums pooling their tags into a single discriminant, as they are by
definition known to have a limited range of valid values. In principle enums could
use fairly elaborate algorithms to cache bits throughout nested types with
special constrained representations. As such it is <em>especially</em> desirable that
we leave enum layout unspecified today.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>