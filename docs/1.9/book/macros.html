<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>マクロ</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル：数当てゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> ベクタ</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.14.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> メソッド構文</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a class='active' href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">マクロ</h1>
    <!-- % Macros -->

<!-- By now you’ve learned about many of the tools Rust provides for abstracting and -->

<!-- reusing code. These units of code reuse have a rich semantic structure. For -->

<!-- example, functions have a type signature, type parameters have trait bounds, -->

<!-- and overloaded functions must belong to a particular trait. -->

<p>Rustが提供している多くのコードの再利用や抽象化に利用できるツールを学びました。
それらのコードの再利用のユニットは豊富な意味論的構造を持っています。
例えば、関数は型シグネチャ、型パラメータはトレイト境界、オーバーロードされた関数はトレイトに所属していなければならない等です。</p>

<!-- This structure means that Rust’s core abstractions have powerful compile-time -->

<!-- correctness checking. But this comes at the price of reduced flexibility. If -->

<!-- you visually identify a pattern of repeated code, you may find it’s difficult -->

<!-- or cumbersome to express that pattern as a generic function, a trait, or -->

<!-- anything else within Rust’s semantics. -->

<p>このような構造はRustのコアの抽象化が強力なコンパイル時の正確性のチェックを持っているという事を意味しています。
しかし、それは柔軟性の減少というコストを払っています。
もし、視覚的に繰り返しているコードのパターンを発見した時に、
それらをジェネリックな関数やトレイトや、他のRustのセマンティクスとして表現することが困難であると気がつくかもしれません。</p>

<!-- Macros allow us to abstract at a syntactic level. A macro invocation is -->

<!-- shorthand for an "expanded" syntactic form. This expansion happens early in -->

<!-- compilation, before any static checking. As a result, macros can capture many -->

<!-- patterns of code reuse that Rust’s core abstractions cannot. -->

<p>マクロは構文レベルでの抽象化をすることを可能にします。
マクロ呼出は「展開された」構文への短縮表現です。
展開はコンパイルの初期段階、すべての静的なチェックが実行される前に行われます。
その結果として、マクロはRustのコアの抽象化では不可能な多くのパターンのコードの再利用を可能としています。</p>

<!-- The drawback is that macro-based code can be harder to understand, because -->

<!-- fewer of the built-in rules apply. Like an ordinary function, a well-behaved -->

<!-- macro can be used without understanding its implementation. However, it can be -->

<!-- difficult to design a well-behaved macro!  Additionally, compiler errors in -->

<!-- macro code are harder to interpret, because they describe problems in the -->

<!-- expanded code, not the source-level form that developers use. -->

<p>マクロベースのコードの欠点は、組み込みルールの少なさに由来するそのコードの理解のしづらさです。
普通の関数と同じように、良いマクロはその実装について理解しなくても使うことができます。
しかしながら、そのような良いマクロを設計するのは困難です！
加えて、マクロコード中のコンパイルエラーは開発者が書いたソースレベルではなく、
展開した結果のコードの中の問題について書かれているために、とても理解しづらいです。</p>

<!-- These drawbacks make macros something of a "feature of last resort". That’s not -->

<!-- to say that macros are bad; they are part of Rust because sometimes they’re -->

<!-- needed for truly concise, well-abstracted code. Just keep this tradeoff in -->

<!-- mind. -->

<p>これらの欠点はマクロを「最終手段となる機能」にしています。
これは、マクロが良くないものだと言っているわけではありません、マクロはRustの一部です、
なぜならばマクロを使うことで簡潔になったり、適切な抽象化が可能になる場面がしばしば存在するからです。
ただ、このトレードオフを頭に入れておいて欲しいのです。</p>

<!-- # Defining a macro -->

<h1 id='マクロを定義する' class='section-header'><a href='#マクロを定義する'>マクロを定義する</a></h1>
<!-- You may have seen the `vec!` macro, used to initialize a [vector][vector] with -->

<!-- any number of elements. -->

<p><code>vec!</code> マクロを見たことがあるでしょう、 <a href="vectors.html">ベクタ</a> を任意の要素で初期化するために使われていました。</p>

<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = vec![1, 2, 3];
assert_eq!(x, [1, 2, 3]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];</pre>

<!-- This can’t be an ordinary function, because it takes any number of arguments. -->

<!-- But we can imagine it as syntactic shorthand for -->

<p><code>vec!</code> は通常の関数として定義することはできません、なぜなら <code>vec!</code> は任意の個数の引数を取るためです。
しかし、 <code>vec!</code> を以下のコードの構文上の短縮形であると考えることができます:</p>

<span class='rusttest'>fn main() {
    let x: Vec&lt;u32&gt; = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
assert_eq!(x, [1, 2, 3]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> <span class='op'>=</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>1</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>2</span>);
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='number'>3</span>);
    <span class='ident'>temp_vec</span>
};</pre>

<!-- We can implement this shorthand, using a macro: [^actual] -->

<p>このような短縮形をマクロ: <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> を用いることで実装することができます</p>

<!-- [^actual]: The actual definition of `vec!` in libcollections differs from the -->

<!--           one presented here, for reasons of efficiency and reusability. -->

<span class='rusttest'>macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
fn main() {
    assert_eq!(vec![1,2,3], [1, 2, 3]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> {
    ( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> {
        {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>temp_vec</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
            $(
                <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
            )<span class='op'>*</span>
            <span class='ident'>temp_vec</span>
        }
    };
}</pre>

<!-- Whoa, that’s a lot of new syntax! Let’s break it down. -->

<p>ワオ！たくさんの新しい構文が現れました！細かく見ていきましょう。</p>

<span class='rusttest'>fn main() {
    macro_rules! vec { ... }
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>vec</span> { ... }</pre>

<!-- This says we’re defining a macro named `vec`, much as `fn vec` would define a -->

<!-- function named `vec`. In prose, we informally write a macro’s name with an -->

<!-- exclamation point, e.g. `vec!`. The exclamation point is part of the invocation -->

<!-- syntax and serves to distinguish a macro from an ordinary function. -->

<p>これは、新しいマクロ <code>vec</code> を定義していることを意味しています、<code>vec</code> という関数を定義するときに <code>fn vec</code> と書くのと同じです。
非公式ですが、実際には、マクロ名をエクスクラメーションマーク(!) と共に記述します、例えば: <code>vec!</code> のように示します。
エクスクラメーションマークはマクロ呼び出しの構文の一部で、マクロと通常の関数の区別をつけるためのものです。</p>

<!-- ## Matching -->

<h2 id='マッチング' class='section-header'><a href='#マッチング'>マッチング</a></h2>
<!-- The macro is defined through a series of rules, which are pattern-matching -->

<!-- cases. Above, we had -->

<p>マクロは、幾つかのパターンマッチのケースを利用したルールに従って定義されています、
上のコード中では、以下の様なパターンが見られました:</p>

<span class='rusttest'>fn main() {
    ( $( $x:expr ),* ) =&gt; { ... };
}</span><pre class='rust rust-example-rendered'>
( $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ) <span class='op'>=&gt;</span> { ... };</pre>

<!-- This is like a `match` expression arm, but the matching happens on Rust syntax -->

<!-- trees, at compile time. The semicolon is optional on the last (here, only) -->

<!-- case. The "pattern" on the left-hand side of `=>` is known as a ‘matcher’. -->

<!-- These have [their own little grammar] within the language. -->

<p>これは <code>match</code> 式の腕に似ていますが、Rustの構文木に対してコンパイル時にマッチします。
セミコロンはケースの末尾でだけ使うことのでき、省略可能です。
<code>=&gt;</code> の左辺にある「パターン」は「マッチャ」として知られています。
マッチャは <a href="../reference.html#macros">小さなマッチャ独自の構文</a> を持っています。</p>

<!-- The matcher `$x:expr` will match any Rust expression, binding that syntax tree -->

<!-- to the ‘metavariable’ `$x`. The identifier `expr` is a ‘fragment specifier’; -->

<!-- the full possibilities are enumerated later in this chapter. -->

<!-- Surrounding the matcher with `$(...),*` will match zero or more expressions, -->

<!-- separated by commas. -->

<p>マッチャ <code>$x:expr</code> は任意のRustの式にマッチし、マッチした構文木を「メタ変数」 <code>$x</code> に束縛します。
識別子 <code>expr</code> は「フラグメント指定子」です。全てのフラグメント指定子の一覧はこの章で後ほど紹介します。
マッチャを <code>$(...),*</code> で囲むと0個以上のコンマで句切られた式にマッチします。</p>

<!-- Aside from the special matcher syntax, any Rust tokens that appear in a matcher -->

<!-- must match exactly. For example, -->

<p>特別なマッチャ構文は別にして、マッチャ中に登場するその他の任意のトークンはそれ自身に正確にマッチする必要があります。
例えば:</p>

<span class='rusttest'>macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='ident'>x</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode X: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
    (<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mode Y: {}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);
}</pre>

<!-- will print -->

<p>上のコードは以下の様な出力をします</p>

<pre><code class="language-text">mode Y: 3
</code></pre>

<!-- With -->

<p>また、以下のようなコードでは</p>

<span class='rusttest'>fn main() {
    foo!(z =&gt; 3);
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>z</span> <span class='op'>=&gt;</span> <span class='number'>3</span>);</pre>

<!-- we get the compiler error -->

<p>以下の様なコンパイルエラーが発生します</p>

<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>

<!-- ## Expansion -->

<h2 id='展開' class='section-header'><a href='#展開'>展開</a></h2>
<!-- The right-hand side of a macro rule is ordinary Rust syntax, for the most part. -->

<!-- But we can splice in bits of syntax captured by the matcher. From the original -->

<!-- example: -->

<p>マクロルールの右辺は大部分が通常のRustの構文です。
しかし、マッチャによってキャプチャされた構文を繋げる事ができます。
最初に示した <code>vec!</code> の例を見てみましょう:</p>

<span class='rusttest'>fn main() {
    $(
    temp_vec.push($x);
)*
}</span><pre class='rust rust-example-rendered'>
$(
    <span class='ident'>temp_vec</span>.<span class='ident'>push</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
)<span class='op'>*</span></pre>

<!-- Each matched expression `$x` will produce a single `push` statement in the -->

<!-- macro expansion. The repetition in the expansion proceeds in "lockstep" with -->

<!-- repetition in the matcher (more on this in a moment). -->

<p><code>$x</code> にマッチしたそれぞれの式はマクロ展開中に <code>push</code> 文を生成します。
マクロ展開中の繰り返しはマッチャ中の繰り返しと足並みを揃えて実行されます(これについてはもう少し説明します)。</p>

<!-- Because `$x` was already declared as matching an expression, we don’t repeat -->

<!-- `:expr` on the right-hand side. Also, we don’t include a separating comma as -->

<!-- part of the repetition operator. Instead, we have a terminating semicolon -->

<!-- within the repeated block. -->

<p><code>$x</code> が既に式にマッチすると宣言されているために、<code>=&gt;</code> の右辺では <code>:expr</code> を繰り返しません。
また、区切りのコンマは繰り返し演算子の一部には含めません。
そのかわり、繰り返しブロックをセミコロンを用いて閉じます。</p>

<!-- Another detail: the `vec!` macro has *two* pairs of braces on the right-hand -->

<!-- side. They are often combined like so: -->

<p>そのほかの詳細としては: <code>vec!</code> マクロは <em>2つ</em> の括弧のペアを右辺に含みます。
それらの括弧はよく以下のように合せられます:</p>

<span class='rusttest'>fn main() {
    macro_rules! foo {
    () =&gt; {{
        ...
    }}
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> {{
        ...
    }}
}</pre>

<!-- The outer braces are part of the syntax of `macro_rules!`. In fact, you can use -->

<!-- `()` or `[]` instead. They simply delimit the right-hand side as a whole. -->

<p>外側の括弧は <code>macro_rules!</code> 構文の一部です。事実、<code>()</code> や <code>[]</code> をかわりに使うことができます。
括弧は単純に右辺を区切るために利用されています。</p>

<!--  The inner braces are part of the expanded syntax. Remember, the `vec!` macro is -->

<!--  used in an expression context. To write an expression with multiple statements, -->

<!--  including `let`-bindings, we use a block. If your macro expands to a single -->

<!--  expression, you don’t need this extra layer of braces. -->

<p>内側の括弧は展開結果の一部です。
<code>vec!</code> マクロは式を必要としているコンテキストで利用されていることを思いだしてください。
複数の文や、 <code>let</code> 束縛を含む式を書きたいときにはブロックを利用します。
もし、マクロが単一の式に展開されるときは、追加の括弧は必要ありません。</p>

<!-- Note that we never *declared* that the macro produces an expression. In fact, -->

<!-- this is not determined until we use the macro as an expression. With care, you -->

<!-- can write a macro whose expansion works in several contexts. For example, -->

<!-- shorthand for a data type could be valid as either an expression or a pattern. -->

<p>マクロが式を生成すると <em>宣言</em> した事はないという点に注意してください。
事実、それはマクロを式として利用するまでは決定されません。
注意深くすれば、複数のコンテキストで適切に展開されるマクロを書く事ができます。
例えば、データ型の短縮形は、式としてもパターンとしても正しく動作します。</p>

<!-- ## Repetition -->

<h2 id='繰り返し' class='section-header'><a href='#繰り返し'>繰り返し</a></h2>
<!-- The repetition operator follows two principal rules: -->

<p>繰り返し演算子は以下の2つの重要なルールに従います:</p>

<!-- 1. `$(...)*` walks through one "layer" of repetitions, for all of the `$name`s -->

<!--    it contains, in lockstep, and -->

<!-- 2. each `$name` must be under at least as many `$(...)*`s as it was matched -->

<!--    against. If it is under more, it’ll be duplicated, as appropriate. -->

<ol>
<li><code>$(...)*</code> は繰り返しの一つの「レイヤ」上で動作し、 レイヤが含んでいる <code>$name</code> について足並みを揃えて動作します。</li>
<li>それぞれの <code>$name</code> はマッチしたときと同じ個数の <code>$(...)*</code> の内側になければなりません。
もし更に多くの <code>$(...)*</code> の中に表われた際には適切に複製されます。</li>
</ol>

<!-- This baroque macro illustrates the duplication of variables from outer -->

<!-- repetition levels. -->

<p>以下の複雑なマクロは一つ外の繰り返しのレベルから値を複製している例です:</p>

<span class='rusttest'>macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>o_O</span> {
    (
        $(
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>; [ $( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span>:<span class='ident'>expr</span> ),<span class='op'>*</span> ]
        );<span class='op'>*</span>
    ) <span class='op'>=&gt;</span> {
        <span class='kw-2'>&amp;</span>[ $($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span> <span class='op'>+</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>y</span> ),<span class='op'>*</span>),<span class='op'>*</span> ]
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>i32</span>]
        <span class='op'>=</span> <span class='macro'>o_O</span><span class='macro'>!</span>(<span class='number'>10</span>; [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
               <span class='number'>20</span>; [<span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>a</span>, [<span class='number'>11</span>, <span class='number'>12</span>, <span class='number'>13</span>, <span class='number'>24</span>, <span class='number'>25</span>, <span class='number'>26</span>]);
}</pre>

<!-- That’s most of the matcher syntax. These examples use `$(...)*`, which is a -->

<!-- "zero or more" match. Alternatively you can write `$(...)+` for a "one or -->

<!-- more" match. Both forms optionally include a separator, which can be any token -->

<!-- except `+` or `*`. -->

<p>上のコードはほとんどのマッチャの構文を利用しています。
この例では0個以上にマッチする <code>$(...)*</code> を利用しています、
1つ以上にマッチさせたい場合は <code>$(...)+</code> を代わりに利用する事ができます。
また、どちらも補助的に区切りを指定する事ができます。区切りには、 <code>+</code> と <code>*</code> 以外の任意のトークンを指定することが可能です。</p>

<!-- This system is based on -->

<!-- "[Macro-by-Example](https://www.cs.indiana.edu/ftp/techreports/TR206.pdf)" -->

<!-- (PDF link). -->

<p>このシステムは:
&quot;<a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>&quot;
(PDFリンク) に基づいています。</p>

<!-- # Hygiene -->

<h1 id='健全性' class='section-header'><a href='#健全性'>健全性</a></h1>
<!-- Some languages implement macros using simple text substitution, which leads to -->

<!-- various problems. For example, this C program prints `13` instead of the -->

<!-- expected `25`. -->

<p>いくつかの言語に組込まれているマクロは単純なテキストの置換を用いています、しかしこれは多くの問題を発生させます。
例えば、以下のC言語のプログラムは期待している <code>25</code> の代わりに <code>13</code> と出力します:</p>

<pre><code class="language-text">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>

<!-- After expansion we have `5 * 2 + 3`, and multiplication has greater precedence -->

<!-- than addition. If you’ve used C macros a lot, you probably know the standard -->

<!-- idioms for avoiding this problem, as well as five or six others. In Rust, we -->

<!-- don’t have to worry about it. -->

<p>展開した結果は <code>5 * 2 + 3</code> となり、乗算は加算よりも優先度が高くなります。
もしC言語のマクロを頻繁に利用しているなら、この問題を避けるためのイディオムを5、6個は知っているでしょう。
Rustではこのような問題を恐れる必要はありません。</p>

<span class='rusttest'>macro_rules! five_times {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>five_times</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='number'>5</span> <span class='op'>*</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>25</span>, <span class='macro'>five_times</span><span class='macro'>!</span>(<span class='number'>2</span> <span class='op'>+</span> <span class='number'>3</span>));
}</pre>

<!-- The metavariable `$x` is parsed as a single expression node, and keeps its -->

<!-- place in the syntax tree even after substitution. -->

<p>メタ変数 <code>$x</code> は一つの式の頂点としてパースされ、構文木上の位置は置換されたあとも保存されます。</p>

<!-- Another common problem in macro systems is ‘variable capture’. Here’s a C -->

<!-- macro, using [a GNU C extension] to emulate Rust’s expression blocks. -->

<p>他のマクロシステムで良くみられる問題は、「変数のキャプチャ」です。
以下のC言語のマクロは <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">GNU C拡張</a> をRustの式のブロックをエミュレートするために利用しています。</p>

<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>

<!-- Here’s a simple use case that goes terribly wrong: -->

<p>以下はこのマクロを利用したときにひどい事になる単純な利用例です:</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>

<!-- This expands to -->

<p>このコードは以下のように展開されます</p>

<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
{
    int state = get_log_state();
    if (state &gt; 0) {
        printf(&quot;log(%d): %s\n&quot;, state, state);
    }
 }
</code></pre>

<!-- The second variable named `state` shadows the first one.  This is a problem -->

<!-- because the print statement should refer to both of them. -->

<p>2番目の変数 <code>state</code> は1つめの <code>state</code> を隠してしまいます。
この問題は、print文が両方の変数を参照する必要があるために起こります。</p>

<!-- The equivalent Rust macro has the desired behavior. -->

<p>Rustにおける同様のマクロは期待する通りの動作をします。</p>

<span class='rusttest'>fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulating splines&quot;;
    log!(state);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>log</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> {{
        <span class='kw'>let</span> <span class='ident'>state</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>get_log_state</span>();
        <span class='kw'>if</span> <span class='ident'>state</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;log({}): {}&quot;</span>, <span class='ident'>state</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>msg</span>);
        }
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>state</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='string'>&quot;reticulating splines&quot;</span>;
    <span class='macro'>log</span><span class='macro'>!</span>(<span class='ident'>state</span>);
}</pre>

<!-- This works because Rust has a [hygienic macro system]. Each macro expansion -->

<!-- happens in a distinct ‘syntax context’, and each variable is tagged with the -->

<!-- syntax context where it was introduced. It’s as though the variable `state` -->

<!-- inside `main` is painted a different "color" from the variable `state` inside -->

<!-- the macro, and therefore they don’t conflict. -->

<p>このマクロはRustが <a href="https://en.wikipedia.org/wiki/Hygienic_macro">健全なマクロシステム</a> を持っているためです。
それぞれのマクロ展開は分離された「構文コンテキスト」で行なわれ、
それぞれの変数はその変数が導入された構文コンテキストでタグ付けされます。
これは、 <code>main</code> 中の <code>state</code> がマクロの中の <code>state</code> とは異なる「色」で塗られているためにコンフリクトしないという風に考える事ができます。</p>

<!-- This also restricts the ability of macros to introduce new bindings at the -->

<!-- invocation site. Code such as the following will not work: -->

<p>この健全性のシステムはマクロが新しい束縛を呼出時に導入する事を制限します。
以下のようなコードは動作しません:</p>

<span class='rusttest'>macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<!-- Instead you need to pass the variable name into the invocation, so that it’s -->

<!-- tagged with the right syntax context. -->

<p>呼出時に渡す事で正しい構文コンテキストでタグ付けされるように、代わりに変数名を呼出時に渡す必要があります。</p>

<span class='rusttest'>macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> (<span class='kw'>let</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>v</span> <span class='op'>=</span> <span class='number'>3</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>(<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<!-- This holds for `let` bindings and loop labels, but not for [items][items]. -->

<!-- So the following code does compile: -->

<p>このルールは <code>let</code> 束縛やループについても同様ですが、 <a href="../reference.html#items">アイテム</a> については適用されません。
そのため、以下のコードはコンパイルが通ります:</p>

<span class='rusttest'>macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>foo</span> {
    () <span class='op'>=&gt;</span> (<span class='kw'>fn</span> <span class='ident'>x</span>() { });
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>foo</span><span class='macro'>!</span>();
    <span class='ident'>x</span>();
}</pre>

<!-- # Recursive macros -->

<h1 id='再帰的マクロ' class='section-header'><a href='#再帰的マクロ'>再帰的マクロ</a></h1>
<!-- A macro’s expansion can include more macro invocations, including invocations -->

<!-- of the very same macro being expanded.  These recursive macros are useful for -->

<!-- processing tree-structured input, as illustrated by this (simplistic) HTML -->

<!-- shorthand: -->

<p>マクロの展開は、展開中のマクロ自身も含めたその他のマクロ呼出しを含んでいることが可能です。
そのような再帰的なマクロは、以下の(単純化した)HTMLの短縮形のような、木構造を持つ入力の処理に便利です:</p>

<span class='rusttest'>#![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
  // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>write_html</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, ) <span class='op'>=&gt;</span> (());

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>tt</span>) <span class='op'>=&gt;</span> (<span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;{}&quot;</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>));

    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>:<span class='ident'>expr</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>:<span class='ident'>ident</span> [ $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>:<span class='ident'>tt</span>)<span class='op'>*</span> ] $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>:<span class='ident'>tt</span>)<span class='op'>*</span>) <span class='op'>=&gt;</span> {{
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>inner</span>)<span class='op'>*</span>);
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, <span class='string'>&quot;&lt;/{}&gt;&quot;</span>, <span class='macro'>stringify</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>tag</span>));
        <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>w</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>rest</span>)<span class='op'>*</span>);
    }};
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Write</span>;
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>out</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();

    <span class='macro'>write_html</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>out</span>,
        <span class='ident'>html</span>[
            <span class='ident'>head</span>[<span class='ident'>title</span>[<span class='string'>&quot;Macros guide&quot;</span>]]
            <span class='ident'>body</span>[<span class='ident'>h1</span>[<span class='string'>&quot;Macros are the best!&quot;</span>]]
        ]);

    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>out</span>,
        <span class='string'>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
}</pre>

<!-- # Debugging macro code -->

<h1 id='マクロをデバッグする' class='section-header'><a href='#マクロをデバッグする'>マクロをデバッグする</a></h1>
<!-- To see the results of expanding macros, run `rustc --pretty expanded`. The -->

<!-- output represents a whole crate, so you can also feed it back in to `rustc`, -->

<!-- which will sometimes produce better error messages than the original -->

<!-- compilation. Note that the `--pretty expanded` output may have a different -->

<!-- meaning if multiple variables of the same name (but different syntax contexts) -->

<!-- are in play in the same scope. In this case `--pretty expanded,hygiene` will -->

<!-- tell you about the syntax contexts. -->

<p>マクロの展開結果を見るには、 <code>rustc --pretty expanded</code> を実行して下さい。
出力結果はクレートの全体を表しています、そのため出力結果を再び <code>rustc</code> に与えることができます、
そのようにすると時々、直接コンパイルした場合よりもより良いエラーメッセージを得ることができます。
しかし、 <code>--pretty expanded</code>  は同じ名前の変数(構文コンテキストは異なる)が同じスコープに複数存在する場合、
出力結果のコード自体は、元のコードと意味が変わってくる場合があります。
そのようになってしまう場合、 <code>--pretty expanded,hygiene</code> のようにすることで、構文コンテキストについて知ることができます。</p>

<!-- `rustc` provides two syntax extensions that help with macro debugging. For now, -->

<!-- they are unstable and require feature gates. -->

<p><code>rustc</code> はマクロのデバッグを補助する２つの構文拡張を提供しています。
今のところは、それらの構文は不安定であり、フィーチャーゲートを必要としています。</p>

<!-- * `log_syntax!(...)` will print its arguments to standard output, at compile -->

<!--   time, and "expand" to nothing. -->

<ul>
<li><code>log_syntax!(...)</code> は与えられた引数をコンパイル時に標準入力に出力し、展開結果は何も生じません。</li>
</ul>

<!-- * `trace_macros!(true)` will enable a compiler message every time a macro is -->

<!--   expanded. Use `trace_macros!(false)` later in expansion to turn it off. -->

<ul>
<li><code>trace_macros!(true)</code> はマクロが展開されるたびにコンパイラがメッセージを出力するように設定できます、
<code>trace_macros!(false)</code> を展開の終わりごろに用いることで、メッセージの出力をオフにできます。</li>
</ul>

<!-- # Syntactic requirements -->

<h1 id='構文的な要求' class='section-header'><a href='#構文的な要求'>構文的な要求</a></h1>
<!-- Even when Rust code contains un-expanded macros, it can be parsed as a full -->

<!-- [syntax tree][ast]. This property can be very useful for editors and other -->

<!-- tools that process code. It also has a few consequences for the design of -->

<!-- Rust’s macro system. -->

<p>Rustのコードに展開されていないマクロが含まれていても、 <a href="glossary.html#abstract-syntax-tree">構文木</a> としてパースすることができます。
このような特性はテキストエディタや、その他のコードを処理するツールにとって非常に便利です。
また、このような特性はRustのマクロシステムの設計にも影響を及ぼしています。</p>

<!-- One consequence is that Rust must determine, when it parses a macro invocation, -->

<!-- whether the macro stands in for -->

<p>一つの影響としては、マクロ呼出をパースした時、マクロが以下のどれを意味しているかを判定する必要があります:</p>

<!-- * zero or more items, -->

<!-- * zero or more methods, -->

<!-- * an expression, -->

<!-- * a statement, or -->

<!-- * a pattern. -->

<ul>
<li>0個以上のアイテム</li>
<li>0個以上のメソッド</li>
<li>式</li>
<li>文</li>
<li>パターン</li>
</ul>

<!-- A macro invocation within a block could stand for some items, or for an -->

<!-- expression / statement. Rust uses a simple rule to resolve this ambiguity. A -->

<!-- macro invocation that stands for items must be either -->

<p>ブロック中でのマクロ呼出は、幾つかのアイテムや、一つの式 / 文 に対応します。
Rustはこの曖昧性を判定するために単純なルールを利用します。
アイテムに対応しているマクロ呼出は以下のどちらかでなければなりません</p>

<!-- * delimited by curly braces, e.g. `foo! { ... }`, or -->

<!-- * terminated by a semicolon, e.g. `foo!(...);` -->

<ul>
<li>波括弧で区切られている 例: <code>foo! { ... }</code></li>
<li>セミコロンで終了している 例: <code>foo!(...);</code></li>
</ul>

<!-- Another consequence of pre-expansion parsing is that the macro invocation must -->

<!-- consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces -->

<!-- must be balanced within a macro invocation. For example, `foo!([)` is -->

<!-- forbidden. This allows Rust to know where the macro invocation ends. -->

<p>その他の展開前にパース可能である事による制約はマクロ呼出は正しいRustトークンで構成されている必要があるというものです。
そのうえ、括弧や、角カッコ、波括弧はマクロ呼出し中でバランスしてなければなりません。
例えば: <code>foo!([)</code> は禁止されています。
これによってRustはマクロ呼出しがどこで終わっているかを知ることができます。</p>

<!-- More formally, the macro invocation body must be a sequence of ‘token trees’. -->

<!-- A token tree is defined recursively as either -->

<p>もっと厳密に言うと、マクロ呼出しの本体は「トークンの木」のシーケンスである必要があります。
トークンの木は以下のいずれかの条件により再帰的に定義されています</p>

<!-- * a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or -->

<!-- * any other single token. -->

<ul>
<li>マッチャ、 <code>()</code> 、 <code>[]</code> または <code>{}</code> で囲まれたトークンの木、あるいは、</li>
<li>その他の単一のトークン</li>
</ul>

<!-- Within a matcher, each metavariable has a ‘fragment specifier’, identifying -->

<!-- which syntactic form it matches. -->

<p>マッチャ内部ではそれぞれのメタ変数はマッチする構文を指定する「フラグメント指定子」を持っています。</p>

<!-- * `ident`: an identifier. Examples: `x`; `foo`. -->

<!-- * `path`: a qualified name. Example: `T::SpecialA`. -->

<!-- * `expr`: an expression. Examples: `2 + 2`; `if true { 1 } else { 2 }`; `f(42)`. -->

<!-- * `ty`: a type. Examples: `i32`; `Vec<(char, String)>`; `&T`. -->

<!-- * `pat`: a pattern. Examples: `Some(t)`; `(17, 'a')`; `_`. -->

<!-- * `stmt`: a single statement. Example: `let x = 3`. -->

<!-- * `block`: a brace-delimited sequence of statements and optionally an expression. Example: -->

<!--   `{ log(error, "hi"); return 12; }`. -->

<!-- * `item`: an [item][item]. Examples: `fn foo() { }`; `struct Bar;`. -->

<!-- * `meta`: a "meta item", as found in attributes. Example: `cfg(target_os = "windows")`. -->

<!-- * `tt`: a single token tree. -->

<ul>
<li><code>ident</code>: 識別子。 例: <code>x</code>; <code>foo</code></li>
<li><code>path</code>: 修飾された名前。例: <code>T::SpecialA</code></li>
<li><code>expr</code>: 式。 例: <code>2 + 2</code>; <code>if true { 1 } else { 2 }</code>; <code>f(42)</code></li>
<li><code>ty</code>: 型。 例: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code></li>
<li><code>pat</code>: パターン。 例: <code>Some(t)</code>; <code>(17, &#39;a&#39;)</code>; <code>_</code></li>
<li><code>stmt</code>: 単一の文。 例: <code>let x = 3</code></li>
<li><code>block</code>: 波括弧で区切られた文のシーケンスと場合によっては式も付く。 例: <code>{ log(error, &quot;hi&quot;); return 12 }</code></li>
<li><code>item</code>: <a href="../reference.html#items">アイテム</a>。 例: <code>fn foo() { }</code>; <code>struct Bar;</code></li>
<li><code>meta</code>: アトリビュートで見られるような「メタアイテム」。 例: <code>cfg(target_os = &quot;windows&quot;)</code></li>
<li><code>tt</code>: 単一のトークンの木</li>
</ul>

<!-- There are additional rules regarding the next token after a metavariable: -->

<p>またメタ変数の次のトークンについて以下のルールが存在します:</p>

<!-- * `expr` and `stmt` variables may only be followed by one of: `=> , ;` -->

<!-- * `ty` and `path` variables may only be followed by one of: `=> , = | ; : > [ { as where` -->

<!-- * `pat` variables may only be followed by one of: `=> , = | if in` -->

<!-- * Other variables may be followed by any token. -->

<ul>
<li><code>expr</code> 変数と <code>stmt</code> 変数は <code>=&gt; , ;</code> のどれか一つのみが次に現れます</li>
<li><code>ty</code> と <code>path</code> 変数は <code>=&gt; , = | ; : &gt; [ { as where</code> のどれか一つのみが次に現れます</li>
<li><code>pat</code> 変数は <code>=&gt; , = | if in</code> のどれか一つのみが次に現れます</li>
<li>その他の変数は任意のトークンが次に現れます</li>
</ul>

<!-- These rules provide some flexibility for Rust’s syntax to evolve without -->

<!-- breaking existing macros. -->

<p>これらのルールは既存のマクロを破壊すること無くRustの構文を拡張するための自由度を与えます。</p>

<!-- The macro system does not deal with parse ambiguity at all. For example, the -->

<!-- grammar `$($i:ident)* $e:expr` will always fail to parse, because the parser would -->

<!-- be forced to choose between parsing `$i` and parsing `$e`. Changing the -->

<!-- invocation syntax to put a distinctive token in front can solve the problem. In -->

<!-- this case, you can write `$(I $i:ident)* E $e:expr`. -->

<p>マクロシステムはパースの曖昧さについては何も対処しません。
例えば、 <code>$($i:ident)* $e:expr</code> は常にパースが失敗します、
なぜならパーサーは <code>$i</code> をパースするか、 <code>$e</code> をパースするかを選ぶことを強制されるためです。
呼出構文を変更して識別可能なトークンを先頭につけることでこの問題は回避することができます。
そのようにする場合、例えば <code>$(I $i:ident)* E $e:expr</code> のように書くことができます。</p>

<!-- # Scoping and macro import/export -->

<h1 id='スコープとマクロのインポートエクスポート' class='section-header'><a href='#スコープとマクロのインポートエクスポート'>スコープとマクロのインポート/エクスポート</a></h1>
<!-- Macros are expanded at an early stage in compilation, before name resolution. -->

<!-- One downside is that scoping works differently for macros, compared to other -->

<!-- constructs in the language. -->

<p>マクロはコンパイルの早い段階、名前解決が行われる前に展開されます。
一つの悪い側面としては、言語中のその他の構造とは異なり、マクロではスコープが少し違って動作するということです。</p>

<!-- Definition and expansion of macros both happen in a single depth-first, -->

<!-- lexical-order traversal of a crate’s source. So a macro defined at module scope -->

<!-- is visible to any subsequent code in the same module, which includes the body -->

<!-- of any subsequent child `mod` items. -->

<p>マクロの定義と展開はクレートの字面上の順序どおりに単一の深さ優先探索で行われます。
そのため、モジュールスコープで定義されたマクロは、
後続する子供の <code>mod</code> アイテムも含む、同じモジュール中のコードから見えます。</p>

<!-- A macro defined within the body of a single `fn`, or anywhere else not at -->

<!-- module scope, is visible only within that item. -->

<p><code>fn</code> の本体の中やその他のモジュールのスコープでない箇所で定義されたマクロはそのアイテム中でしか見えません。</p>

<!-- If a module has the `macro_use` attribute, its macros are also visible in its -->

<!-- parent module after the child’s `mod` item. If the parent also has `macro_use` -->

<!-- then the macros will be visible in the grandparent after the parent’s `mod` -->

<!-- item, and so forth. -->

<p>もし、モジュールが <code>macro_use</code> アトリビュートを持っていた場合、
それらのマクロは子供の <code>mod</code> アイテムの後で、親モジュールからも見えます。
もし親モジュールが同様に <code>macro_use</code> アトリビュートを持っていた場合、 親の親モジュールから親の <code>mod</code> アイテムが終わった後に見えます。
その後についても同様です。</p>

<!-- The `macro_use` attribute can also appear on `extern crate`. In this context -->

<!-- it controls which macros are loaded from the external crate, e.g. -->

<p>また、 <code>macro_use</code> アトリビュートは <code>extern crate</code> の上でも利用することができます。
そのようにした場合、 <code>macro_use</code> アトリビュートは外部のクレートからどのマクロをロードするのかを指定します。
以下がその例です:</p>

<span class='rusttest'>fn main() {
    #[macro_use(foo, bar)]
extern crate baz;
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>(<span class='ident'>foo</span>, <span class='ident'>bar</span>)]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>baz</span>;</pre>

<!-- If the attribute is given simply as `#[macro_use]`, all macros are loaded. If -->

<!-- there is no `#[macro_use]` attribute then no macros are loaded. Only macros -->

<!-- defined with the `#[macro_export]` attribute may be loaded. -->

<p>もしアトリビュートが単純に <code>#[macro_use]</code> という形で指定されていた場合、全てのマクロがロードされます。
もし、 <code>#[macro_use]</code> が指定されていなかった場合、 <code>#[macro_export]</code> アトリビュートとともに定義されているマクロ以外は、
どのマクロもロードされません。</p>

<!-- To load a crate’s macros without linking it into the output, use `#[no_link]` -->

<!-- as well. -->

<p>クレートのマクロを出力にリンクさせずにロードするには、 <code>#[no_link]</code> を利用して下さい。</p>

<!-- An example: -->

<p>一例としては:</p>

<span class='rusttest'>macro_rules! m1 { () =&gt; (()) }

// // visible here: m1
// ここで見えるのは: m1

mod foo {
//    // visible here: m1
    // ここで見えるのは: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

//    // visible here: m1, m2
    // ここで見えるのは: m1、m2
}

// // visible here: m1
// ここで見えるのは: m1

macro_rules! m3 { () =&gt; (()) }

// // visible here: m1, m3
// ここで見えるのは: m1、m3

#[macro_use]
mod bar {
//    // visible here: m1, m3
    // ここで見えるのは: m1、m3

    macro_rules! m4 { () =&gt; (()) }

//    // visible here: m1, m3, m4
    // ここで見えるのは: m1、m3、m4
}

// // visible here: m1, m3, m4
// ここで見えるのは: m1、m3、m4
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m1</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// ここで見えるのは: m1</span>

<span class='kw'>mod</span> <span class='ident'>foo</span> {
    <span class='comment'>// ここで見えるのは: m1</span>

    <span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m2</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// ここで見えるのは: m1、m2</span>
}

<span class='comment'>// ここで見えるのは: m1</span>

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m3</span> { () <span class='op'>=&gt;</span> (()) }

<span class='comment'>// ここで見えるのは: m1、m3</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>mod</span> <span class='ident'>bar</span> {
    <span class='comment'>// ここで見えるのは: m1、m3</span>

    <span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>m4</span> { () <span class='op'>=&gt;</span> (()) }

    <span class='comment'>// ここで見えるのは: m1、m3、m4</span>
}

<span class='comment'>// ここで見えるのは: m1、m3、m4</span></pre>

<!-- When this library is loaded with `#[macro_use] extern crate`, only `m2` will -->

<!-- be imported. -->

<p>ライブラリが <code>#[macro_use]</code> と共に外部のクレートをロードした場合、 <code>m2</code> だけがインポートされます。</p>

<!-- The Rust Reference has a [listing of macro-related -->

<!-- attributes](../reference.html#macro-related-attributes). -->

<p>Rustのリファレンスは <a href="../reference.html#macro-related-attributes">マクロに関連するアトリビュートの一覧</a> を掲載しています。</p>

<!-- # The variable `$crate` -->

<h1 id='crate-変数' class='section-header'><a href='#crate-変数'><code>$crate</code> 変数</a></h1>
<!-- A further difficulty occurs when a macro is used in multiple crates. Say that -->

<!-- `mylib` defines -->

<p>さらなる困難はマクロが複数のクレートで利用された時に発生します。
<code>mylib</code> が以下のように定義されているとしましょう</p>

<span class='rusttest'>pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>increment</span>(<span class='ident'>x</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_a</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}

<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc_b</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( ::<span class='ident'>mylib</span>::<span class='ident'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}</pre>

<!-- `inc_a` only works within `mylib`, while `inc_b` only works outside the -->

<!-- library. Furthermore, `inc_b` will break if the user imports `mylib` under -->

<!-- another name. -->

<p><code>inc_a</code> は <code>mylib</code> の中でだけ動作します、かたや <code>inc_b</code> は <code>mylib</code> の外部でだけ動作します。
さらにいえば、 <code>inc_b</code> はユーザーが <code>mylib</code> を異なる名前でインポートした際には動作しません。</p>

<!-- Rust does not (yet) have a hygiene system for crate references, but it does -->

<!-- provide a simple workaround for this problem. Within a macro imported from a -->

<!-- crate named `foo`, the special macro variable `$crate` will expand to `::foo`. -->

<!-- By contrast, when a macro is defined and then used in the same crate, `$crate` -->

<!-- will expand to nothing. This means we can write -->

<p>Rustは(まだ)健全なクレートの参照の仕組みを持っていません、
しかし、この問題に対する簡単な対処方法を提供しています。
<code>foo</code>というクレートからインポートされたマクロ中において、
特別なマクロ変数 <code>$crate</code> は <code>::foo</code> に展開されます。
対照的に、マクロが同じクレートの中で定義され利用された場合、
<code>$crate</code> は何にも展開されません。これはつまり以下のように書けることを意味しています:</p>

<span class='rusttest'>#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
fn main() { }
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_export</span>]</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>inc</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> ( <span class='macro-nonterminal'>$</span><span class='kw'>crate</span>::<span class='macro-nonterminal'>increment</span>(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>x</span>) )
}</pre>

<!-- to define a single macro that works both inside and outside our library. The -->

<!-- function name will expand to either `::increment` or `::mylib::increment`. -->

<p>これは、ライブラリの中でも外でも動作するマクロを定義しています。
関数の名前は <code>::increment</code> または <code>::mylib::increment</code> に展開されます。</p>

<!-- To keep this system simple and correct, `#[macro_use] extern crate ...` may -->

<!-- only appear at the root of your crate, not inside `mod`. -->

<p>このシステムを簡潔で正しく保つために、 <code>#[macro_use] extern crate ...</code> はクレートのルートにしか登場せず、
<code>mod</code> の中には現れません。</p>

<!-- # The deep end -->

<h1 id='最難関部' class='section-header'><a href='#最難関部'>最難関部</a></h1>
<!-- The introductory chapter mentioned recursive macros, but it did not give the -->

<!-- full story. Recursive macros are useful for another reason: Each recursive -->

<!-- invocation gives you another opportunity to pattern-match the macro’s -->

<!-- arguments. -->

<p>入門のチャプタで再帰的なマクロについて言及しました、しかしそのチャプタでは詳細について話していませんでした。
再帰的なマクロが便利な他の理由は、それぞれの再帰的な呼出はマクロに与えられた引数にたいしてパターンマッチを行える可能性を与えてくれることです。</p>

<!-- As an extreme example, it is possible, though hardly advisable, to implement -->

<!-- the [Bitwise Cyclic Tag](https://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton -->

<!-- within Rust’s macro system. -->

<p>極端な例としては、 望ましくはありませんが、 <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> のオートマトンをRustのマクロで実装する事が可能です。</p>

<span class='rusttest'>fn main() {
    macro_rules! bct {
    // cmd 0:  d ... =&gt; ...
    (0, $($ps:tt),* ; $_d:tt)
        =&gt; (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... =&gt; 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... =&gt; 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));

//    // halt on empty data string
    // 空のデータ文字列で停止します
    ( $($ps:tt),* ; )
        =&gt; (());
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>bct</span> {
    <span class='comment'>// cmd 0:  d ... =&gt; ...</span>
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; ));
    (<span class='number'>0</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>_d</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>0</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// cmd 1p:  1 ... =&gt; 1 ... p</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; <span class='number'>1</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>));

    <span class='comment'>// cmd 1p:  0 ... =&gt; 0 ...</span>
    (<span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span>:<span class='ident'>tt</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>:<span class='ident'>tt</span>),<span class='op'>*</span>)
        <span class='op'>=&gt;</span> (<span class='macro'>bct</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>),<span class='op'>*</span>, <span class='number'>1</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>p</span> ; $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ds</span>),<span class='op'>*</span>));

    <span class='comment'>// 空のデータ文字列で停止します</span>
    ( $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ps</span>:<span class='ident'>tt</span>),<span class='op'>*</span> ; )
        <span class='op'>=&gt;</span> (());
}</pre>

<!-- Exercise: use macros to reduce duplication in the above definition of the -->

<!-- `bct!` macro. -->

<p>演習: マクロを使って上の <code>bct!</code> マクロの定義の重複している部分を減らしてみましょう。</p>

<!-- # Common macros -->

<h1 id='よく見られるマクロ' class='section-header'><a href='#よく見られるマクロ'>よく見られるマクロ</a></h1>
<!-- Here are some common macros you’ll see in Rust code. -->

<p>以下は、Rustコード中でよく見られるマクロたちです。</p>

<h2 id='panic' class='section-header'><a href='#panic'>panic!</a></h2>
<!-- This macro causes the current thread to panic. You can give it a message -->

<!-- to panic with: -->

<p>このマクロは現在のスレッドをパニック状態にします。
パニック時のメッセージを指定することができます。</p>

<span class='rusttest'>fn main() {
    panic!(&quot;oh no!&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;oh no!&quot;</span>);</pre>

<h2 id='vec' class='section-header'><a href='#vec'>vec!</a></h2>
<!-- The `vec!` macro is used throughout the book, so you’ve probably seen it -->

<!-- already. It creates `Vec<T>`s with ease: -->

<p><code>vec!</code> マクロはこの本のなかで使われてきましたので、 すでに見たことがあるでしょう。
<code>vec!</code> マクロは <code>Vec&lt;T&gt;</code> を簡単に作成できます:</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3, 4, 5];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>];</pre>

<!-- It also lets you make vectors with repeating values. For example, a hundred -->

<!-- zeroes: -->

<p>また、値の繰り返しのベクタを作成することも可能です。
たとえば、以下は100個の0を含むベクタの例です:</p>

<span class='rusttest'>fn main() {
    let v = vec![0; 100];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0</span>; <span class='number'>100</span>];</pre>

<!-- ## assert! and assert_eq! -->

<h2 id='assert-と-assert_eq' class='section-header'><a href='#assert-と-assert_eq'>assert! と assert_eq!</a></h2>
<!-- These two macros are used in tests. `assert!` takes a boolean. `assert_eq!` -->

<!-- takes two values and checks them for equality. `true` passes, `false` `panic!`s. -->

<!-- Like this: -->

<p>この２つのマクロはテスト時に利用されています。
<code>assert!</code> は真偽値を引数に取ります。
<code>assert_eq!</code> は２つの等価性をチェックする値を引数に取ります。
<code>true</code> ならばパスし、 <code>false</code> だった場合 <code>panic!</code> を起こします:</p>

<span class='rusttest'>fn main() {
    // // A-ok!
// Okです！

assert!(true);
assert_eq!(5, 3 + 2);

// // nope :(
// 駄目だぁ :(

assert!(5 &lt; 3);
assert_eq!(5, 3);
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// Okです！</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='boolvalue'>true</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span> <span class='op'>+</span> <span class='number'>2</span>);

<span class='comment'>// 駄目だぁ :(</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>5</span> <span class='op'>&lt;</span> <span class='number'>3</span>);
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='number'>5</span>, <span class='number'>3</span>);</pre>

<h2 id='try' class='section-header'><a href='#try'>try!</a></h2>
<!-- `try!` is used for error handling. It takes something that can return a -->

<!-- `Result<T, E>`, and gives `T` if it’s a `Ok<T>`, and `return`s with the -->

<!-- `Err(E)` if it’s that. Like this: -->

<p><code>try!</code> はエラーハンドリングのために利用されています。
<code>try!</code> は <code>Result&lt;T, E&gt;</code> を返す何らかの物を引数に取り、もし <code>Result&lt;T, E&gt;</code> が <code>Ok&lt;T&gt;</code> だった場合 <code>T</code> を返し、
そうでなく <code>Err(E)</code> だった場合はそれを <code>return</code> します。
例えば以下のように利用します:</p>

<span class='rusttest'>fn main() {
    use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = try!(File::create(&quot;foo.txt&quot;));

    Ok(())
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>));

    <span class='prelude-val'>Ok</span>(())
}</pre>

<!-- This is cleaner than doing this: -->

<p>このコードは以下のコードよりも綺麗です:</p>

<span class='rusttest'>fn main() {
    use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = File::create(&quot;foo.txt&quot;);

    let f = match f {
        Ok(t) =&gt; t,
        Err(e) =&gt; return Err(e),
    };

    Ok(())
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='string'>&quot;foo.txt&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>f</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='ident'>t</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>e</span>),
    };

    <span class='prelude-val'>Ok</span>(())
}</pre>

<h2 id='unreachable' class='section-header'><a href='#unreachable'>unreachable!</a></h2>
<!-- This macro is used when you think some code should never execute: -->

<p>このマクロはあるコードが絶対に実行されるべきでないと考えている時に利用します。</p>

<span class='rusttest'>fn main() {
    if false {
    unreachable!();
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>if</span> <span class='boolvalue'>false</span> {
    <span class='macro'>unreachable</span><span class='macro'>!</span>();
}</pre>

<!-- Sometimes, the compiler may make you have a different branch that you know -->

<!-- will never, ever run. In these cases, use this macro, so that if you end -->

<!-- up wrong, you’ll get a `panic!` about it. -->

<p>時々、コンパイラによって絶対に呼び出されるはずがないと考えているブランチを作成することになる時があります。
そういった時には、このマクロを利用しましょう、そうすることでもし何か誤ってしまった時に、 <code>panic!</code> で知ることができます。</p>

<span class='rusttest'>fn main() {
    let x: Option&lt;i32&gt; = None;

match x {
    Some(_) =&gt; unreachable!(),
    None =&gt; println!(&quot;I know x is None!&quot;),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;

<span class='kw'>match</span> <span class='ident'>x</span> {
    <span class='prelude-val'>Some</span>(_) <span class='op'>=&gt;</span> <span class='macro'>unreachable</span><span class='macro'>!</span>(),
    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I know x is None!&quot;</span>),
}</pre>

<h2 id='unimplemented' class='section-header'><a href='#unimplemented'>unimplemented!</a></h2>
<!-- The `unimplemented!` macro can be used when you’re trying to get your functions -->

<!-- to typecheck, and don’t want to worry about writing out the body of the -->

<!-- function. One example of this situation is implementing a trait with multiple -->

<!-- required methods, where you want to tackle one at a time. Define the others -->

<!-- as `unimplemented!` until you’re ready to write them. -->

<p><code>unimplemented!</code> マクロはもし関数の本体の実装はしていないが、型チェックだけは行いたいという時に利用します。
このような状況の一つの例としては複数のメソッドを必要としているトレイトのメソッドの一つを実装しようと試みている時などです。
残りのメソッドたちの実装に取り掛かれるようになるまで <code>unimplemented!</code> として定義しましょう。</p>

<!-- # Procedural macros -->

<h1 id='手続きマクロ' class='section-header'><a href='#手続きマクロ'>手続きマクロ</a></h1>
<!-- If Rust’s macro system can’t do what you need, you may want to write a -->

<!-- [compiler plugin](compiler-plugins.html) instead. Compared to `macro_rules!` -->

<!-- macros, this is significantly more work, the interfaces are much less stable, -->

<!-- and bugs can be much harder to track down. In exchange you get the -->

<!-- flexibility of running arbitrary Rust code within the compiler. Syntax -->

<!-- extension plugins are sometimes called ‘procedural macros’ for this reason. -->

<p>もしRustのマクロシステムでは必要としていることができない場合、
<a href="compiler-plugins.html">コンパイラプラグイン</a> を代わりに書きたくなるでしょう。
コンパイラプラグインは <code>macro_rules!</code> マクロとくらべて、更に多くの作業が必要になり、
インタフェースはかなり不安定であり、バグはさらに追跡が困難になります。
引き換えに、任意のコードをコンパイラ中で実行できるという自由度を得ることができます。
構文拡張プラグインがしばしば「手続きマクロ」と呼ばれるのはこのためです。</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p><code>vec!</code> のlibcollectionsにおける実際の実装と、ここで示したコードは効率性や再利用性のために異なります。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>