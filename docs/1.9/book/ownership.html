<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>所有権</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル：数当てゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> ベクタ</a>
</li>
<li><a class='active' href='ownership.html'><b>4.8.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.14.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> メソッド構文</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book-ja/">最新版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。リンク先のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">所有権</h1>
    <!-- % Ownership -->

<!-- This guide is one of three presenting Rust’s ownership system. This is one of -->

<!-- Rust’s most unique and compelling features, with which Rust developers should -->

<!-- become quite acquainted. Ownership is how Rust achieves its largest goal, -->

<!-- memory safety. There are a few distinct concepts, each with its own -->

<!-- chapter: -->

<p>このガイドはRustの所有権システムの3つの解説の1つ目です。
これはRustの最も独特で注目されている機能です。そして、Rust開発者はそれについて高度に精通しておくべきです。
所有権こそはRustがその最大の目標、メモリ安全性を得るための方法です。
そこにはいくつかの別個の概念があり、各概念が独自の章を持ちます。</p>

<!-- * ownership, which you’re reading now -->

<!-- * [borrowing][borrowing], and their associated feature ‘references’ -->

<!-- * [lifetimes][lifetimes], an advanced concept of borrowing -->

<ul>
<li>「所有権」（このページ）</li>
<li>「<a href="references-and-borrowing.html">借用</a>」と、それに関連する機能である「参照」</li>
<li>借用のもう一歩進んだ概念である 「<a href="lifetimes.html">ライフタイム</a>」</li>
</ul>

<!-- These three chapters are related, and in order. You’ll need all three to fully -->

<!-- understand the ownership system. -->

<p>それらの3つの章は関連していて、それらは順番に並んでいます。
所有権システムを完全に理解するためには、3つ全てを必要とするでしょう。</p>

<!-- # Meta -->

<h1 id='概論' class='section-header'><a href='#概論'>概論</a></h1>
<!-- Before we get to the details, two important notes about the ownership system. -->

<p>詳細に入る前に、所有権システムについての2つの重要な注意があります。</p>

<!-- Rust has a focus on safety and speed. It accomplishes these goals through many -->

<!-- ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little -->

<!-- as possible in order to make them work. The ownership system is a prime example -->

<!-- of a zero-cost abstraction. All of the analysis we’ll talk about in this guide -->

<!-- is _done at compile time_. You do not pay any run-time cost for any of these -->

<!-- features. -->

<p>Rustは安全性とスピードに焦点を合わせます。
Rustはそれらの目標を、様々な「ゼロコスト抽象化」を通じて成し遂げます。
それは、Rustでは抽象化を機能させるためのコストをできる限り小さくすることを意味します。
所有権システムはゼロコスト抽象化の主な例です。
このガイドの中で話すであろう解析の全ては <em>コンパイル時に行われます</em> 。
それらのどの機能に対しても実行時のコストは全く掛かりません。</p>

<!-- However, this system does have a certain cost: learning curve. Many new users -->

<!-- to Rust experience something we like to call ‘fighting with the borrow -->

<!-- checker’, where the Rust compiler refuses to compile a program that the author -->

<!-- thinks is valid. This often happens because the programmer’s mental model of -->

<!-- how ownership should work doesn’t match the actual rules that Rust implements. -->

<!-- You probably will experience similar things at first. There is good news, -->

<!-- however: more experienced Rust developers report that once they work with the -->

<!-- rules of the ownership system for a period of time, they fight the borrow -->

<!-- checker less and less. -->

<p>しかし、このシステムはあるコストを持ちます。それは学習曲線です。
多くのRust入門者は、私たちが「借用チェッカとの戦い」と呼ぶものを経験します。
そこではRustコンパイラが、開発者が正しいと考えるプログラムをコンパイルすることを拒絶します。
所有権がどのように機能するのかについてのプログラマのメンタルモデルがRustの実装する実際のルールにマッチしないため、これはしばしば起きます。
しかし、よいニュースがあります。より経験豊富なRustの開発者は次のことを報告します。
それは、所有権システムのルールと共にしばらく仕事をすれば、借用チェッカと戦うことは次第に少なくなっていく、というものです。</p>

<!-- With that in mind, let’s learn about ownership. -->

<p>それを念頭に置いて、所有権について学びましょう。</p>

<!-- # Ownership -->

<h1 id='所有権' class='section-header'><a href='#所有権'>所有権</a></h1>
<!-- [Variable bindings][bindings] have a property in Rust: they ‘have ownership’ -->

<!-- of what they’re bound to. This means that when a binding goes out of scope, -->

<!-- Rust will free the bound resources. For example: -->

<p>Rustでは <a href="variable-bindings.html">変数束縛</a> はある特性を持ちます。それは、束縛されているものの「所有権を持つ」ということです。
これは束縛がスコープから外れるとき、Rustは束縛されているリソースを解放するだろうということを意味します。
例えばこうです。</p>

<span class='rusttest'>fn main() {
    fn foo() {
    let v = vec![1, 2, 3];
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
    <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
}</pre>

<!-- When `v` comes into scope, a new [vector][vectors] is created on [the stack][stack], -->

<!-- and it allocates space on [the heap][heap] for its elements. When `v` goes out -->

<!-- of scope at the end of `foo()`, Rust will clean up everything related to the -->

<!-- vector, even the heap-allocated memory. This happens deterministically, at the -->

<!-- end of the scope. -->

<p><code>v</code> がスコープに入るとき、新しい <a href="vectors.html">ベクタ</a> が <a href="the-stack-and-the-heap.html#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF">スタック</a> 上に作られ、要素を格納するために <a href="the-stack-and-the-heap.html#%E3%83%92%E3%83%BC%E3%83%97">ヒープ</a> に空間を割り当てます。
<code>foo()</code> の最後で <code>v</code> がスコープから外れるとき、Rustはベクタに関連するもの全てを取り除くでしょう。
それがヒープ割り当てのメモリであってもです。
これはスコープの最後で決定的に起こります。</p>

<!-- We'll cover [vectors] in detail later in this chapter; we only use them -->

<!-- here as an example of a type that allocates space on the heap at runtime. They -->

<!-- behave like [arrays], except their size may change by `push()`ing more -->

<!-- elements onto them. -->

<!-- 訳注："We'll cover [vectors] in detail later..." となっていますが、 -->

<!-- ベクタはこのセクションより前に説明されていますので、それに合わせて訳を変更しました。 -->

<p><a href="vectors.html">ベクタ</a> については、前のセクションで説明済みですが、簡単に復習しましょう。
ここではベクタを、実行時にヒープに空間を割り当てる型の例として用いています。
ベクタは <a href="primitive-types.html#%E9%85%8D%E5%88%97">配列</a> のように振る舞いますが、追加の要素を <code>push()</code> するとサイズが変わるところは違います。</p>

<!-- Vectors have a [generic type][generics] `Vec<T>`, so in this example `v` will have type -->

<!-- `Vec<i32>`. We'll cover generics in detail later in this chapter. -->

<p>ベクタは <a href="generics.html">ジェネリクス型</a> <code>Vec&lt;T&gt;</code> を持ちますので、この例における <code>v</code> は <code>Vec&lt;i32&gt;</code> 型になるでしょう。
ジェネリクスについては、この章の後の方で詳しく説明します。</p>

<!-- 訳注：原文では[heap]のリンク先が単に the-stack-and-the-heap.html となっていますが、 -->

<!-- [stack]に合わせて、#ヒープ を追加しました -->

<!-- # Move semantics -->

<h1 id='ムーブセマンティクス' class='section-header'><a href='#ムーブセマンティクス'>ムーブセマンティクス</a></h1>
<!-- There’s some more subtlety here, though: Rust ensures that there is _exactly -->

<!-- one_ binding to any given resource. For example, if we have a vector, we can -->

<!-- assign it to another binding: -->

<p>しかし、ここではもっと些細に見えることがあります。それは、Rustは与えられたリソースに対する束縛が <em>1つだけ</em> あることを保証するというものです。
例えば、もしベクタがあれば、それを別の束縛に割り当てることはできます。</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];

let v2 = v;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;</pre>

<!-- But, if we try to use `v` afterwards, we get an error: -->

<p>しかし、もし後で <code>v</code> を使おうとすると、エラーが出ます。</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];

let v2 = v;

println!(&quot;v[0] is: {}&quot;, v[0]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v[0] is: {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>0</span>]);</pre>

<!-- It looks like this: -->

<p>こんな感じのエラーです。</p>

<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] is: {}&quot;, v[0]);
                        ^
</code></pre>

<!-- A similar thing happens if we define a function which takes ownership, and -->

<!-- try to use something after we’ve passed it as an argument: -->

<p>もし所有権を受け取る関数を定義して、引数として何かを渡した後でそれを使おうとするならば、同じようなことが起きます。</p>

<span class='rusttest'>fn main() {
    fn take(v: Vec&lt;i32&gt;) {
  // what happens here isn’t important.
    // ここで何が起きるかは重要ではない
}

let v = vec![1, 2, 3];

take(v);

println!(&quot;v[0] is: {}&quot;, v[0]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>take</span>(<span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='comment'>// ここで何が起きるかは重要ではない</span>
}

<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='ident'>take</span>(<span class='ident'>v</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v[0] is: {}&quot;</span>, <span class='ident'>v</span>[<span class='number'>0</span>]);</pre>

<!-- Same error: ‘use of moved value’. When we transfer ownership to something else, -->

<!-- we say that we’ve ‘moved’ the thing we refer to. You don’t need some sort of -->

<!-- special annotation here, it’s the default thing that Rust does. -->

<p>「use of moved value」という同じエラーです。
所有権を何か別のものに転送するとき、参照するものを「ムーブした」と言います。
これは特別な種類の注釈なしに行われます。
つまりRustのデフォルトの動作です。</p>

<!-- ## The details -->

<h2 id='詳細' class='section-header'><a href='#詳細'>詳細</a></h2>
<!-- The reason that we cannot use a binding after we’ve moved it is subtle, but -->

<!-- important. -->

<p>束縛をムーブした後で、それを使うことができないと言いました。
その理由は、ごく詳細かもしれませんが、とても重要です。</p>

<!-- When we write code like this: -->

<p>このようなコードを書いた時、</p>

<span class='rusttest'>fn main() {
    let x = 10;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;</pre>

<!-- Rust allocates memory for an integer [i32] on the [stack][sh], copies the bit -->

<!-- pattern representing the value of 10 to the allocated memory and binds the -->

<!-- variable name x to this memory region for future reference. -->

<p>Rustは <a href="the-stack-and-the-heap.html">スタック</a> 上に整数 <a href="primitive-types.html#%E6%95%B0%E5%80%A4%E5%9E%8B">i32</a> のためのメモリを割り当て、そこに、10という値を表すビットパターンをコピーします。
そして後から参照できるよう、変数名xをこのメモリ領域に束縛します。</p>

<!-- 訳注：原文ではi32へのリンクが抜けているので、ここに追加しました -->

<!-- Now consider the following code fragment: -->

<p>今度は、こんなコード片について考えてみましょう。</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];

let mut v2 = v;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;</pre>

<!-- The first line allocates memory for the vector object `v` on the stack like -->

<!-- it does for `x` above. But in addition to that it also allocates some memory -->

<!-- on the [heap][sh] for the actual data (`[1, 2, 3]`). Rust copies the address -->

<!-- of this heap allocation to an internal pointer, which is part of the vector -->

<!-- object placed on the stack (let's call it the data pointer). -->

<!-- 訳注：ここで "data pointer" という言葉を導入してますが、後で使っていないので、訳は省きました。-->

<!-- 訳注：allocation ですが、「割り当て」だと不自然な所は、「領域(region)」と訳しました。 -->

<p>最初の行では、先ほどの <code>x</code> と同様に、ベクタオブジェクト <code>v</code> のために、スタック上にメモリを割り当てます。
しかし、これに加えて、実際のデータ（ <code>[1, 2, 3]</code> ）のために、 <a href="the-stack-and-the-heap.html">ヒープ</a> 上にもメモリを割り当てます。
スタック上のベクタオブジェクトの中にはポインタがあり、Rustはいま割り当てたヒープのアドレスをそこへコピーします。</p>

<!-- It is worth pointing out (even at the risk of stating the obvious) that the -->

<!-- vector object and its data live in separate memory regions instead of being a -->

<!-- single contiguous memory allocation (due to reasons we will not go into at -->

<!-- this point of time). These two parts of the vector (the one on the stack and -->

<!-- one on the heap) must agree with each other at all times with regards to -->

<!-- things like the length, capacity etc. -->

<p>すでに分かりきっているかもしれませんが、念のためここで確認しておきたいのは、ベクタオブジェクトとそのデータは、それぞれが別のメモリ領域に格納されていることです。
決してそれらは、1つの連続したメモリ領域に置かれているわけではありません（その理由についての詳細は、いまは省きます）。
そして、ベクタにおけるこれら2つの部分（スタック上のものと、ヒープ上のもの）は、要素数やキャパシティ（容量）などについて、常にお互いの間で一貫性が保たれている必要があります。</p>

<!-- When we move `v` to `v2`, Rust actually does a bitwise copy of the vector -->

<!-- object `v` into the stack allocation represented by `v2`. This shallow copy -->

<!-- does not create a copy of the heap allocation containing the actual data. -->

<!-- Which means that there would be two pointers to the contents of the vector -->

<!-- both pointing to the same memory allocation on the heap. It would violate -->

<!-- Rust’s safety guarantees by introducing a data race if one could access both -->

<!-- `v` and `v2` at the same time. -->

<p><code>v</code> を <code>v2</code> にムーブするときRustが実際に行うのは、ビット単位のコピーを使って、ベクタオブジェクト <code>v</code> が示すスタック領域の情報を、 <code>v2</code> が示すスタック領域へコピーすることです。
この浅いコピーでは、実際のデータを格納しているヒープ領域はコピーしません。
これは、ベクタの内容として、同一のヒープメモリ領域を指すポインタが2つあることを意味します。
もし誰かが <code>v</code> と <code>v2</code> に同時にアクセスできるとしたら？
これはデータ競合を持ち込むことになり、Rustの安全性保証に違反するでしょう。</p>

<!-- For example if we truncated the vector to just two elements through `v2`: -->

<p>例えば <code>v2</code> を通して、ベクタを2要素分、切り詰めたとしましょう。</p>

<span class='rusttest'>fn main() {
    let v = vec![1, 2, 3];
let mut v2 = v;
v2.truncate(2);
}</span><pre class='rust rust-example-rendered'>
<span class='ident'>v2</span>.<span class='ident'>truncate</span>(<span class='number'>2</span>);</pre>

<!-- and `v1` were still accessible we'd end up with an invalid vector since `v1` -->

<!-- would not know that the heap data has been truncated. Now, the part of the -->

<!-- vector `v1` on the stack does not agree with the corresponding part on the -->

<!-- heap. `v1` still thinks there are three elements in the vector and will -->

<!-- happily let us access the non existent element `v1[2]` but as you might -->

<!-- already know this is a recipe for disaster. Especially because it might lead -->

<!-- to a segmentation fault or worse allow an unauthorized user to read from -->

<!-- memory to which they don't have access. -->

<p>もしまだ <code>v1</code> にアクセスできたとしたら、<code>v1</code> はヒープデータが切り詰められたことを知らないので、不正なベクタを提供することになってしまいます。
ここでスタック上の <code>v1</code> は、ヒープ上で対応する相手と一貫性が取れていません。
<code>v1</code> はベクタにまだ3つの要素があると思っているので、もし私たちが存在しない要素 <code>v1[2]</code> にアクセスしようとしたら、喜んでそうさせるでしょう。
しかし、すでにお気づきの通り、特に次のような理由から大惨事に繋がるかもしれません。
これはセグメンテーション違反を起こすかもしれませんし、最悪の場合、権限を持たないユーザーが、本来アクセスできないはずのメモリを読めてしまうかもしれないのです。</p>

<!-- This is why Rust forbids using `v` after we’ve done the move. -->

<p>このような理由から、Rustはムーブを終えた後の <code>v</code> の使用を禁止するのです。</p>

<!-- It’s also important to note that optimizations may remove the actual copy of -->

<!-- the bytes on the stack, depending on circumstances. So it may not be as -->

<!-- inefficient as it initially seems. -->

<p>また知っておいてほしいのは、状況によっては最適化により、スタック上のバイトを実際にコピーする処理が省かれる可能性があることです。
そのため、ムーブは最初に思ったほど非効率ではないかもしれません。</p>

<!-- ## `Copy` types -->

<h2 id='copy-型' class='section-header'><a href='#copy-型'><code>Copy</code> 型</a></h2>
<!-- We’ve established that when ownership is transferred to another binding, you -->

<!-- cannot use the original binding. However, there’s a [trait][traits] that changes this -->

<!-- behavior, and it’s called `Copy`. We haven’t discussed traits yet, but for now, -->

<!-- you can think of them as an annotation to a particular type that adds extra -->

<!-- behavior. For example: -->

<p>所有権が他の束縛に転送されるとき、元の束縛を使うことができないということを証明しました。
しかし、この挙動を変更する <a href="traits.html">トレイト</a> があります。それは <code>Copy</code> と呼ばれます。
トレイトについてはまだ議論していませんが、とりあえずそれらを、ある型に対してある挙動を追加するための、注釈のようなものとして考えて構いません。
例えばこうです。</p>

<span class='rusttest'>fn main() {
    let v = 1;

let v2 = v;

println!(&quot;v is: {}&quot;, v);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='number'>1</span>;

<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='ident'>v</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;v is: {}&quot;</span>, <span class='ident'>v</span>);</pre>

<!-- In this case, `v` is an `i32`, which implements the `Copy` trait. This means -->

<!-- that, just like a move, when we assign `v` to `v2`, a copy of the data is made. -->

<!-- But, unlike a move, we can still use `v` afterward. This is because an `i32` -->

<!-- has no pointers to data somewhere else, copying it is a full copy. -->

<p>この場合、 <code>v</code> は <code>i32</code> で、それは <code>Copy</code> トレイトを実装します。
これはちょうどムーブと同じように、 <code>v</code> を <code>v2</code> に代入するとき、データのコピーが作られることを意味します。
しかし、ムーブと違って、後でまだ <code>v</code> を使うことができます。
これは <code>i32</code> がどこか別の場所へのポインタを持たず、コピーが完全コピーだからです。</p>

<!-- All primitive types implement the `Copy` trait and their ownership is -->

<!-- therefore not moved like one would assume, following the ´ownership rules´. -->

<!-- To give an example, the two following snippets of code only compile because the -->

<!-- `i32` and `bool` types implement the `Copy` trait. -->

<p>全てのプリミティブ型は <code>Copy</code> トレイトを実装しているので、推測どおりそれらの所有権は「所有権ルール」に従ってはムーブしません。
例として、次の2つのコードスニペットはコンパイルが通ります。なぜなら、 <code>i32</code> 型と <code>bool</code> 型は <code>Copy</code> トレイトを実装するからです。</p>

<span class='rusttest'>fn main() {
    let a = 5;

    let _y = double(a);
    println!(&quot;{}&quot;, a);
}

fn double(x: i32) -&gt; i32 {
    x * 2
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>_y</span> <span class='op'>=</span> <span class='ident'>double</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>double</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>
}</pre>

<span class='rusttest'>fn main() {
    let a = true;

    let _y = change_truth(a);
    println!(&quot;{}&quot;, a);
}

fn change_truth(x: bool) -&gt; bool {
    !x
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='boolvalue'>true</span>;

    <span class='kw'>let</span> <span class='ident'>_y</span> <span class='op'>=</span> <span class='ident'>change_truth</span>(<span class='ident'>a</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>);
}

<span class='kw'>fn</span> <span class='ident'>change_truth</span>(<span class='ident'>x</span>: <span class='ident'>bool</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='op'>!</span><span class='ident'>x</span>
}</pre>

<!-- If we had used types that do not implement the `Copy` trait, -->

<!-- we would have gotten a compile error because we tried to use a moved value. -->

<p>もし <code>Copy</code> トレイトを実装していない型を使っていたならば、ムーブした値を使おうとしたため、コンパイルエラーが出ていたでしょう。</p>

<pre><code class="language-text">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</code></pre>

<!-- We will discuss how to make your own types `Copy` in the [traits][traits] -->

<!-- section. -->

<p>独自の <code>Copy</code> 型を作る方法は <a href="traits.html">トレイト</a> セクションで議論するでしょう。</p>

<!-- # More than ownership -->

<h1 id='所有権を越えて' class='section-header'><a href='#所有権を越えて'>所有権を越えて</a></h1>
<!-- Of course, if we had to hand ownership back with every function we wrote: -->

<p>もちろん、もし書いた全ての関数で所有権を返さなければならないのであれば、こうなります。</p>

<span class='rusttest'>fn main() {
    fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
  // do stuff with v
    // vについての作業を行う

  // hand back ownership
    // 所有権を返す
    v
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='comment'>// vについての作業を行う</span>

    <span class='comment'>// 所有権を返す</span>
    <span class='ident'>v</span>
}</pre>

<!-- This would get very tedious. It gets worse the more things we want to take ownership of: -->

<p>これは非常に退屈になるでしょう。
もっとたくさんのものの所有権を受け取ろうとすると、状況はさらに悪化します。</p>

<span class='rusttest'>fn main() {
    fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
  // do stuff with v1 and v2
    // v1とv2についての作業を行う

  // hand back ownership, and the result of our function
    // 所有権と関数の結果を返す
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>v2</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> (<span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>, <span class='ident'>i32</span>) {
    <span class='comment'>// v1とv2についての作業を行う</span>

    <span class='comment'>// 所有権と関数の結果を返す</span>
    (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='number'>42</span>)
}

<span class='kw'>let</span> <span class='ident'>v1</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>v2</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='kw'>let</span> (<span class='ident'>v1</span>, <span class='ident'>v2</span>, <span class='ident'>answer</span>) <span class='op'>=</span> <span class='ident'>foo</span>(<span class='ident'>v1</span>, <span class='ident'>v2</span>);</pre>

<!-- Ugh! The return type, return line, and calling the function gets way more -->

<!-- complicated. -->

<p>うわあ！
戻り値の型、リターン行、関数呼出しがもっと複雑になります。</p>

<!-- Luckily, Rust offers a feature, borrowing, which helps us solve this problem. -->

<!-- It’s the topic of the next section! -->

<p>幸運なことに、Rustは借用という機能を提供します。それはこの問題を解決するために手助けしてくれます。
それが次のセクションの話題です。</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>