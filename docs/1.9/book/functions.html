<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>関数</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル：数当てゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a class='active' href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> ベクタ</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.14.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> メソッド構文</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">関数</h1>
    <!-- % Functions -->

<!-- Every Rust program has at least one function, the `main` function: -->

<p>Rustにおける全てのプログラムには、少なくとも1つの関数、 <code>main</code> 関数があります。</p>

<span class='rusttest'>fn main() {
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
}</pre>

<!-- This is the simplest possible function declaration. As we mentioned before, -->

<!-- `fn` says ‘this is a function’, followed by the name, some parentheses because -->

<!-- this function takes no arguments, and then some curly braces to indicate the -->

<!-- body. Here’s a function named `foo`: -->

<p>これは評価可能な関数定義の最も単純なものです。
前に言ったように、 <code>fn</code> は「これは関数です」ということを示します。この関数には引数がないので、名前と丸括弧が続きます。そして、その本文を表す波括弧が続きます。
これが <code>foo</code> という名前の関数です。</p>

<span class='rusttest'>fn main() {
    fn foo() {
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>() {
}</pre>

<!-- So, what about taking arguments? Here’s a function that prints a number: -->

<p>それでは、引数を取る場合はどうでしょうか。
これが数値を表示する関数です。</p>

<span class='rusttest'>fn main() {
    fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<!-- Here’s a complete program that uses `print_number`: -->

<p>これが <code>print_number</code> を使う完全なプログラムです。</p>

<span class='rusttest'>fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print_number</span>(<span class='number'>5</span>);
}

<span class='kw'>fn</span> <span class='ident'>print_number</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is: {}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<!-- As you can see, function arguments work very similar to `let` declarations: -->

<!-- you add a type to the argument name, after a colon. -->

<p>見てのとおり、関数の引数は <code>let</code> 宣言と非常によく似た動きをします。
引数の名前にコロンに続けて型を追加します。</p>

<!-- Here’s a complete program that adds two numbers together and prints them: -->

<p>これが2つの数値を足して結果を表示する完全なプログラムです。</p>

<span class='rusttest'>fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>print_sum</span>(<span class='number'>5</span>, <span class='number'>6</span>);
}

<span class='kw'>fn</span> <span class='ident'>print_sum</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;sum is: {}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
}</pre>

<!-- You separate arguments with a comma, both when you call the function, as well -->

<!-- as when you declare it. -->

<p>関数を呼び出すときも、それを宣言したときと同様に、引数をコンマで区切ります。</p>

<!-- Unlike `let`, you _must_ declare the types of function arguments. This does -->

<!-- not work: -->

<p><code>let</code> と異なり、あなたは関数の引数の型を宣言 <em>しなければなりません</em> 。
これは動きません。</p>

<span class='rusttest'>fn main() {
    fn print_sum(x, y) {
    println!(&quot;sum is: {}&quot;, x + y);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_sum</span>(<span class='ident'>x</span>, <span class='ident'>y</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;sum is: {}&quot;</span>, <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>y</span>);
}</pre>

<!-- You get this error: -->

<p>このエラーが発生します。</p>

<pre><code class="language-text">expected one of `!`, `:`, or `@`, found `)`
fn print_sum(x, y) {
</code></pre>

<!-- This is a deliberate design decision. While full-program inference is possible, -->

<!-- languages which have it, like Haskell, often suggest that documenting your -->

<!-- types explicitly is a best-practice. We agree that forcing functions to declare -->

<!-- types while allowing for inference inside of function bodies is a wonderful -->

<!-- sweet spot between full inference and no inference. -->

<p>これはよく考えられた設計上の決断です。
プログラムのすべての箇所で型推論をするという設計も可能ですが、一方で、そのように型推論を行なうHaskellのような言語でも、ドキュメント目的で型を明示するのはよい習慣だと言われています。
私たちの意見は、関数の型を明示することは強制しつつ、関数本体では型を推論するようにすることが、すべての箇所で型推論をするのとまったく型推論をしないことの間のすばらしいスイートスポットである、というところで一致しています。</p>

<!-- What about returning a value? Here’s a function that adds one to an integer: -->

<p>戻り値についてはどうでしょうか。
これが整数に1を加える関数です。</p>

<span class='rusttest'>fn main() {
    fn add_one(x: i32) -&gt; i32 {
    x + 1
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}</pre>

<!-- Rust functions return exactly one value, and you declare the type after an -->

<!-- ‘arrow’, which is a dash (`-`) followed by a greater-than sign (`>`). The last -->

<!-- line of a function determines what it returns. You’ll note the lack of a -->

<!-- semicolon here. If we added it in: -->

<p>Rustの関数は値を1つだけ返します。そして、ダッシュ（ <code>-</code> ）の後ろに大なりの記号（ <code>&gt;</code> ）を続けた「矢印」の後にその型を宣言します。
関数の最後の行が何を返すのかを決定します。
ここにセミコロンがないことに気が付くでしょう。
もしそれを追加すると、こうなります。</p>

<span class='rusttest'>fn main() {
    fn add_one(x: i32) -&gt; i32 {
    x + 1;
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;
}</pre>

<!-- We would get an error: -->

<p>エラーが発生するでしょう。</p>

<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>

<!-- This reveals two interesting things about Rust: it is an expression-based -->

<!-- language, and semicolons are different from semicolons in other ‘curly brace -->

<!-- and semicolon’-based languages. These two things are related. -->

<p>これはRustについて2つの興味深いことを明らかにします。それが式ベースの言語であること、そしてセミコロンが他の「波括弧とセミコロン」ベースの言語でのセミコロンとは違っているということです。
これら2つのことは関連します。</p>

<!-- ## Expressions vs. Statements -->

<h2 id='式と文' class='section-header'><a href='#式と文'>式と文</a></h2>
<!-- Rust is primarily an expression-based language. There are only two kinds of -->

<!-- statements, and everything else is an expression. -->

<p>Rustは主として式ベースの言語です。
文には2種類しかなく、その他の全ては式です。</p>

<!-- So what's the difference? Expressions return a value, and statements do not. -->

<!-- That’s why we end up with ‘not all control paths return a value’ here: the -->

<!-- statement `x + 1;` doesn’t return a value. There are two kinds of statements in -->

<!-- Rust: ‘declaration statements’ and ‘expression statements’. Everything else is -->

<!-- an expression. Let’s talk about declaration statements first. -->

<p>ではその違いは何でしょうか。
式は値を返しますが、文は返しません。
それが「not all control paths return a value」で終わった理由です。文 <code>x + 1;</code> は値を返さないからです。
Rustには2種類の文があります。「宣言文」と「式文」です。
その他の全ては式です。
まずは宣言文について話しましょう。</p>

<!-- In some languages, variable bindings can be written as expressions, not -->

<!-- statements. Like Ruby: -->

<p>いくつかの言語では、変数束縛を文としてだけではなく、式としても書けます。
Rubyではこうなります。</p>

<pre><code class="language-ruby">x = y = 5
</code></pre>

<!-- In Rust, however, using `let` to introduce a binding is _not_ an expression. The -->

<!-- following will produce a compile-time error: -->

<p>しかし、Rustでは束縛を導入するための <code>let</code> の使用は式では <em>ありません</em> 。
次の例はコンパイルエラーを起こします。</p>

<span class='rusttest'>fn main() {
    // let x = (let y = 5); // expected identifier, found keyword `let`
let x = (let y = 5); // 識別子を期待していましたが、キーワード `let` が見つかりました
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5</span>); <span class='comment'>// 識別子を期待していましたが、キーワード `let` が見つかりました</span></pre>

<!-- The compiler is telling us here that it was expecting to see the beginning of -->

<!-- an expression, and a `let` can only begin a statement, not an expression. -->

<p>ここでコンパイラが言っているのは、式の先頭が来ることを期待していましたが、 <code>let</code> は式ではなく、文の先頭にしかなれませんよ、ということです。</p>

<!-- Note that assigning to an already-bound variable (e.g. `y = 5`) is still an -->

<!-- expression, although its value is not particularly useful. Unlike other -->

<!-- languages where an assignment evaluates to the assigned value (e.g. `5` in the -->

<!-- previous example), in Rust the value of an assignment is an empty tuple `()` -->

<!-- because the assigned value can have [only one owner](ownership.html), and any -->

<!-- other returned value would be too surprising: -->

<p>次のことに注意しましょう。
既に束縛されている変数への代入（例えば <code>y = 5</code> ）は、その値が特に役に立つものではありませんが、やはり式です。
他の言語の中には、代入式を評価すると、代入された値（例えば、前の例では <code>5</code> ）が返されるものもあります。
しかし、Rustの代入式はそれと異なり、評価すると空のタプル <code>()</code> が返されます。
なぜなら、代入された値には <a href="ownership.html">単一の所有者</a> しかおらず、他のどんな値を返したとしても予想外の出来事になってしまうからです。</p>

<span class='rusttest'>fn main() {
    let mut y = 5;

// let x = (y = 6);  // x has the value `()`, not `6`
let x = (y = 6);  // xは値 `()` を持っており、 `6` ではありません
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='ident'>y</span> <span class='op'>=</span> <span class='number'>6</span>);  <span class='comment'>// xは値 `()` を持っており、 `6` ではありません</span></pre>

<!-- The second kind of statement in Rust is the *expression statement*. Its -->

<!-- purpose is to turn any expression into a statement. In practical terms, Rust's -->

<!-- grammar expects statements to follow other statements. This means that you use -->

<!-- semicolons to separate expressions from each other. This means that Rust -->

<!-- looks a lot like most other languages that require you to use semicolons -->

<!-- at the end of every line, and you will see semicolons at the end of almost -->

<!-- every line of Rust code you see. -->

<p>Rustでの2種類目の文は <em>式文</em> です。
これの目的は式を文に変換することです。
実際にはRustの文法は文の後には他の文が続くことが期待されています。
これはそれぞれの式を区切るためにセミコロンを使うということを意味します。
これはRustが全ての行末にセミコロンを使うことを要求する他の言語のほとんどとよく似ていること、そして見られるRustのコードのほとんど全ての行末で、セミコロンが見られるということを意味します。</p>

<!-- What is this exception that makes us say "almost"? You saw it already, in this -->

<!-- code: -->

<p>「ほとんど」と言ったところの例外は何でしょうか。
この例で既に見ています。</p>

<span class='rusttest'>fn main() {
    fn add_one(x: i32) -&gt; i32 {
    x + 1
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>add_one</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}</pre>

<!-- Our function claims to return an `i32`, but with a semicolon, it would return -->

<!-- `()` instead. Rust realizes this probably isn’t what we want, and suggests -->

<!-- removing the semicolon in the error we saw before. -->

<p>この関数は <code>i32</code> を返そうとしていますが、セミコロンを付ければ、それは代わりに <code>()</code> を返します。
Rustはこの挙動がおそらく求めているものではないということを理解するので、前に見たエラーの中で、セミコロンを削除することを提案するのです。</p>

<!-- ## Early returns -->

<h2 id='早期リターン' class='section-header'><a href='#早期リターン'>早期リターン</a></h2>
<!-- But what about early returns? Rust does have a keyword for that, `return`: -->

<p>しかし、早期リターンについてはどうでしょうか。
Rustはそのためのキーワード <code>return</code> を持っています。</p>

<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 {
    return x;

   // we never run this code!
    // このコードは走りません!
    x + 1
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>return</span> <span class='ident'>x</span>;

    <span class='comment'>// このコードは走りません!</span>
    <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>
}</pre>

<!-- Using a `return` as the last line of a function works, but is considered poor -->

<!-- style: -->

<p><code>return</code> を関数の最後の行で使っても動きますが、それはよろしくないスタイルだと考えられています。</p>

<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 {
    return x + 1;
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>return</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>;
}</pre>

<!-- The previous definition without `return` may look a bit strange if you haven’t -->

<!-- worked in an expression-based language before, but it becomes intuitive over -->

<!-- time. -->

<p>あなたがこれまで式ベースの言語を使ったことがなければ、 <code>return</code> のない前の定義の方がちょっと変に見えるかもしれません。しかし、それは時間とともに直観的に感じられるようになります。</p>

<!-- ## Diverging functions -->

<h2 id='発散する関数' class='section-header'><a href='#発散する関数'>発散する関数</a></h2>
<!-- Rust has some special syntax for ‘diverging functions’, which are functions that -->

<!-- do not return: -->

<p>Rustには「発散する関数」、すなわち値を返さない関数のための特別な構文がいくつかあります。</p>

<span class='rusttest'>fn main() {
    fn diverges() -&gt; ! {
    panic!(&quot;This function never returns!&quot;);
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>diverges</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;This function never returns!&quot;</span>);
}</pre>

<!-- `panic!` is a macro, similar to `println!()` that we’ve already seen. Unlike -->

<!-- `println!()`, `panic!()` causes the current thread of execution to crash with -->

<!-- the given message. Because this function will cause a crash, it will never -->

<!-- return, and so it has the type ‘`!`’, which is read ‘diverges’. -->

<p><code>panic!</code> は既に見てきた <code>println!</code> と同様にマクロです。
<code>println!</code> とは違って、 <code>panic!</code> は実行中の現在のスレッドを与えられたメッセージとともにクラッシュさせます。
この関数はクラッシュを引き起こすので、決して値を返しません。そのため、この関数は「 <code>!</code> 」型を持つのです。「 <code>!</code> 」は「発散する（diverges）」と読みます。</p>

<!-- If you add a main function that calls `diverges()` and run it, you’ll get -->

<!-- some output that looks like this: -->

<p>もし <code>diverges()</code> を呼び出すメイン関数を追加してそれを実行するならば、次のようなものが出力されるでしょう。</p>

<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2
</code></pre>

<!-- If you want more information, you can get a backtrace by setting the -->

<!-- `RUST_BACKTRACE` environment variable: -->

<p>もしもっと情報を得たいと思うのであれば、 <code>RUST_BACKTRACE</code> 環境変数をセットすることでバックトレースが得られます。</p>

<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread &#39;&lt;main&gt;&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>

<!-- If you need to override an already set `RUST_BACKTRACE`, -->

<!-- in cases when you cannot just unset the variable, -->

<!-- then set it to `0` to avoid getting a backtrace. -->

<!-- Any other value(even no value at all) turns on backtrace. -->

<p>もしすでに <code>RUST_BACKTRACE</code> 変数がセットされており、それをアンセットできないなどの理由により値を上書きするのなら、 <code>0</code> にセットすればバックトレースが取得されなくなります。
それ以外の全ての値では（環境変数はあるが値がない場合も含め）バックトレースがオンになります。</p>

<pre><code class="language-text">$ export RUST_BACKTRACE=1
...
$ RUST_BACKTRACE=0 ./diverges
thread &#39;&lt;main&gt;&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>

<!-- `RUST_BACKTRACE` also works with Cargo’s `run` command: -->

<p><code>RUST_BACKTRACE</code> はCargoの <code>run</code> コマンドでも使えます。</p>

<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread &#39;&lt;main&gt;&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>

<!-- A diverging function can be used as any type: -->

<p>発散する関数は任意の型としても使えます。</p>

<span class='rusttest'>fn main() {
    fn diverges() -&gt; ! {
   panic!(&quot;This function never returns!&quot;);
}
let x: i32 = diverges();
let x: String = diverges();
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>diverges</span>();
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>diverges</span>();</pre>

<!-- ## Function pointers -->

<h2 id='関数ポインタ' class='section-header'><a href='#関数ポインタ'>関数ポインタ</a></h2>
<!-- We can also create variable bindings which point to functions: -->

<p>関数を指す（ポイントする）変数束縛も作れます。</p>

<span class='rusttest'>fn main() {
    let f: fn(i32) -&gt; i32;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>f</span>: <span class='kw'>fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span>;</pre>

<!-- `f` is a variable binding which points to a function that takes an `i32` as -->

<!-- an argument and returns an `i32`. For example: -->

<p><code>f</code> という変数束縛は、 <code>i32</code> を引数として受け取り、 <code>i32</code> を返す関数へのポインタになります。
例えばこうです。</p>

<span class='rusttest'>fn main() {
    fn plus_one(i: i32) -&gt; i32 {
    i + 1
}

// without type inference
// 型推論なし
let f: fn(i32) -&gt; i32 = plus_one;

// with type inference
// 型推論あり
let f = plus_one;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>plus_one</span>(<span class='ident'>i</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='ident'>i</span> <span class='op'>+</span> <span class='number'>1</span>
}

<span class='comment'>// 型推論なし</span>
<span class='kw'>let</span> <span class='ident'>f</span>: <span class='kw'>fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>plus_one</span>;

<span class='comment'>// 型推論あり</span>
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>plus_one</span>;</pre>

<!-- We can then use `f` to call the function: -->

<p>そして <code>f</code> を使って関数を呼び出せます。</p>

<span class='rusttest'>fn main() {
    fn plus_one(i: i32) -&gt; i32 { i + 1 }
let f = plus_one;
let six = f(5);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>six</span> <span class='op'>=</span> <span class='ident'>f</span>(<span class='number'>5</span>);</pre>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>