<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>エラーハンドリング</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル：数当てゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> ベクタ</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.14.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> メソッド構文</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a class='active' href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">エラーハンドリング</h1>
    <!-- % Error Handling -->

<!-- Like most programming languages, Rust encourages the programmer to handle -->

<!-- errors in a particular way. Generally speaking, error handling is divided into -->

<!-- two broad categories: exceptions and return values. Rust opts for return -->

<!-- values. -->

<p>他のほとんどのプログラミング言語と同様、Rustはプログラマに、ある決まった作法でエラーを扱うことを促します。
一般的にエラーハンドリングは、例外、もしくは、戻り値を使ったものの、大きく2つに分類されます。
Rustでは戻り値を使います。</p>

<!-- In this section, we intend to provide a comprehensive treatment of how to deal -->

<!-- with errors in Rust. More than that, we will attempt to introduce error handling -->

<!-- one piece at a time so that you'll come away with a solid working knowledge of -->

<!-- how everything fits together. -->

<p>このセクションでは、Rustでのエラーハンドリングに関わる包括的な扱い方を提示しようと思います。
単にそれだけではなく、エラーハンドリングのやり方を、ひとつひとつ、順番に積み上げていきます。
こうすることで、全体がどう組み合わさっているのかの理解が進み、より実用的な知識が身につくでしょう。</p>

<!-- When done naïvely, error handling in Rust can be verbose and annoying. This -->

<!-- section will explore those stumbling blocks and demonstrate how to use the -->

<!-- standard library to make error handling concise and ergonomic. -->

<p>もし素朴なやり方を用いたなら、Rustにおけるエラーハンドリングは、冗長で面倒なものになり得ます。
このセクションでは、エラーを処理する上でどのような課題があるかを吟味し、標準ライブラリを使うと、それがいかにシンプルでエルゴノミック（人間にとって扱いやすいもの）に変わるのかを紹介します。</p>

<!-- # Table of Contents -->

<h1 id='目次' class='section-header'><a href='#目次'>目次</a></h1>
<!-- This section is very long, mostly because we start at the very beginning with -->

<!-- sum types and combinators, and try to motivate the way Rust does error handling -->

<!-- incrementally. As such, programmers with experience in other expressive type -->

<!-- systems may want to jump around. -->

<p>このセクションはとても長くなります。
というのは、直和型(sum type) とコンビネータから始めることで、Rustにおけるエラーハンドリングを徐々に改善していくための動機を与えるからです。
このような構成ですので、もしすでに他の表現力豊かな型システムの経験があるプログラマでしたら、あちこち拾い読みしたくなるかもしれません。</p>

<!-- * [The Basics](#the-basics) -->

<!--     * [Unwrapping explained](#unwrapping-explained) -->

<!--     * [The `Option` type](#the-option-type) -->

<!--         * [Composing `Option<T>` values](#composing-optiont-values) -->

<!--     * [The `Result` type](#the-result-type) -->

<!--         * [Parsing integers](#parsing-integers) -->

<!--         * [The `Result` type alias idiom](#the-result-type-alias-idiom) -->

<!--     * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isnt-evil) -->

<!-- * [Working with multiple error types](#working-with-multiple-error-types) -->

<!--     * [Composing `Option` and `Result`](#composing-option-and-result) -->

<!--     * [The limits of combinators](#the-limits-of-combinators) -->

<!--     * [Early returns](#early-returns) -->

<!--     * [The `try!` macro](#the-try-macro) -->

<!--     * [Defining your own error type](#defining-your-own-error-type) -->

<!-- * [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling) -->

<!--     * [The `Error` trait](#the-error-trait) -->

<!--     * [The `From` trait](#the-from-trait) -->

<!--     * [The real `try!` macro](#the-real-try-macro) -->

<!--     * [Composing custom error types](#composing-custom-error-types) -->

<!--     * [Advice for library writers](#advice-for-library-writers) -->

<!-- * [Case study: A program to read population data](#case-study-a-program-to-read-population-data) -->

<!--     * [Initial setup](#initial-setup) -->

<!--     * [Argument parsing](#argument-parsing) -->

<!--     * [Writing the logic](#writing-the-logic) -->

<!--     * [Error handling with `Box<Error>`](#error-handling-with-boxerror) -->

<!--     * [Reading from stdin](#reading-from-stdin) -->

<!--     * [Error handling with a custom type](#error-handling-with-a-custom-type) -->

<!--     * [Adding functionality](#adding-functionality) -->

<!--  [The short story](#the-short-story) -->

<ul>
<li><a href="#%E5%9F%BA%E7%A4%8E">基礎</a>

<ul>
<li><a href="#%E3%82%A2%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97unwrap-%E3%81%A8%E3%81%AF">アンラップ(unwrap) とは</a></li>
<li><a href="#option-%E5%9E%8B"><code>Option</code> 型</a>

<ul>
<li><a href="#optiont-%E5%80%A4%E3%82%92%E5%90%88%E6%88%90%E3%81%99%E3%82%8B"><code>Option&lt;T&gt;</code> 値を合成する</a></li>
</ul></li>
<li><a href="#result-%E5%9E%8B"><code>Result</code> 型</a>

<ul>
<li><a href="#%E6%95%B4%E6%95%B0%E3%82%92%E3%83%91%E3%83%BC%E3%82%B9%E3%81%99%E3%82%8B">整数をパースする</a></li>
<li><a href="#result-%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0"><code>Result</code> 型エイリアスを用いたイディオム</a></li>
</ul></li>
<li><a href="#%E5%B0%8F%E4%BC%91%E6%AD%A2%E3%82%A2%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97%E3%81%AF%E6%82%AA%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84">小休止：アンラップは悪ではない</a></li>
</ul></li>
<li><a href="#%E8%A4%87%E6%95%B0%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E5%9E%8B%E3%82%92%E6%89%B1%E3%81%86">複数のエラー型を扱う</a>

<ul>
<li><a href="#option-%E3%81%A8-result-%E3%82%92%E5%90%88%E6%88%90%E3%81%99%E3%82%8B"><code>Option</code> と <code>Result</code> を合成する</a></li>
<li><a href="#%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%AE%E9%99%90%E7%95%8C">コンビネータの限界</a></li>
<li><a href="#%E6%97%A9%E6%9C%9F%E3%83%AA%E3%82%BF%E3%83%BC%E3%83%B3">早期リターン</a></li>
<li><a href="#try-%E3%83%9E%E3%82%AF%E3%83%AD"><code>try!</code> マクロ</a></li>
<li><a href="#%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">独自のエラー型を定義する</a></li>
</ul></li>
<li><a href="#%E6%A8%99%E6%BA%96%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AB%E3%82%88%E3%82%8B%E3%82%A8%E3%83%A9%E3%83%BC%E5%87%A6%E7%90%86">標準ライブラリのトレイトによるエラー処理</a>

<ul>
<li><a href="#error-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88"><code>Error</code> トレイト</a></li>
<li><a href="#from-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88"><code>From</code> トレイト</a></li>
<li><a href="#%E6%9C%AC%E5%BD%93%E3%81%AE-try-%E3%83%9E%E3%82%AF%E3%83%AD">本当の <code>try!</code> マクロ</a></li>
<li><a href="#%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E5%9E%8B%E3%82%92%E5%90%88%E6%88%90%E3%81%99%E3%82%8B">独自のエラー型を合成する</a></li>
<li><a href="#%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E4%BD%9C%E8%80%85%E3%81%9F%E3%81%A1%E3%81%B8%E3%81%AE%E3%82%A2%E3%83%89%E3%83%90%E3%82%A4%E3%82%B9">ライブラリ作者たちへのアドバイス</a></li>
</ul></li>
<li><a href="#%E3%82%B1%E3%83%BC%E3%82%B9%E3%82%B9%E3%82%BF%E3%83%87%E3%82%A3%EF%BC%9A%E4%BA%BA%E5%8F%A3%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0">ケーススタディ：人口データを読み込むプログラム</a>

<ul>
<li><a href="#%E6%9C%80%E5%88%9D%E3%81%AE%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97">最初のセットアップ</a></li>
<li><a href="#%E5%BC%95%E6%95%B0%E3%81%AE%E3%83%91%E3%83%BC%E3%82%B9">引数のパース</a></li>
<li><a href="#%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8F">ロジックを書く</a></li>
<li><a href="#boxerror-%E3%81%AB%E3%82%88%E3%82%8B%E3%82%A8%E3%83%A9%E3%83%BC%E5%87%A6%E7%90%86"><code>Box&lt;Error&gt;</code> によるエラー処理</a></li>
<li><a href="#%E6%A8%99%E6%BA%96%E5%85%A5%E5%8A%9B%E3%81%8B%E3%82%89%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%80">標準入力から読み込む</a></li>
<li><a href="#%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E5%9E%8B%E3%81%AB%E3%82%88%E3%82%8B%E3%82%A8%E3%83%A9%E3%83%BC%E5%87%A6%E7%90%86">独自のエラー型によるエラー処理</a></li>
<li><a href="#%E6%A9%9F%E8%83%BD%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B">機能を追加する</a></li>
</ul></li>
<li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li>
</ul>

<!-- # The Basics -->

<h1 id='基礎' class='section-header'><a href='#基礎'>基礎</a></h1>
<!-- You can think of error handling as using *case analysis* to determine whether -->

<!-- a computation was successful or not. As you will see, the key to ergonomic error -->

<!-- handling is reducing the amount of explicit case analysis the programmer has to -->

<!-- do while keeping code composable. -->

<p>エラーハンドリングとは、ある処理が成功したかどうかを <em>場合分け(case analysis)</em> に基づいて判断するものだと考えられます。
これから見ていくように、エラーハンドリングをエルゴノミックにするために重要なのは、プログラマがコードを合成可能(composable) に保ったまま、明示的な場合分けの回数を、いかに減らしていくかということです。</p>

<!-- Keeping code composable is important, because without that requirement, we -->

<!-- could [`panic`](../std/macro.panic!.html) whenever we -->

<!-- come across something unexpected. (`panic` causes the current task to unwind, -->

<!-- and in most cases, the entire program aborts.) Here's an example: -->

<p>コードを合成可能に保つのは重要です。
なぜなら、もしこの要求がなかったら、想定外のことが起こる度に <a href="../std/macro.panic!.html"><code>panic</code></a> することを選ぶかもしれないからです。
（<code>panic</code> は現タスクを巻き戻し(unwind) して、ほとんどの場合、プログラム全体をアボートします。）</p>

<span class='rusttest'>// Guess a number between 1 and 10.
// If it matches the number we had in mind, return true. Else, return false.
// 1から10までの数字を予想します。
// もし予想した数字に一致したらtrueを返し、そうでなければfalseを返します。
fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!(&quot;Invalid number: {}&quot;, n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 1から10までの数字を予想します。</span>
<span class='comment'>// もし予想した数字に一致したらtrueを返し、そうでなければfalseを返します。</span>
<span class='kw'>fn</span> <span class='ident'>guess</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='kw'>if</span> <span class='ident'>n</span> <span class='op'>&lt;</span> <span class='number'>1</span> <span class='op'>||</span> <span class='ident'>n</span> <span class='op'>&gt;</span> <span class='number'>10</span> {
        <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Invalid number: {}&quot;</span>, <span class='ident'>n</span>);
    }
    <span class='ident'>n</span> <span class='op'>==</span> <span class='number'>5</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>guess</span>(<span class='number'>11</span>);
}</pre>

<blockquote>
<p>訳注：文言の意味は</p>

<ul>
<li>Invalid number: {}：無効な数字です: {}</li>
</ul>

<p>ですが、エディタの設定などによっては、ソースコード中の
コメント以外の場所に日本語を使うとコンパイルできないことがあるので、
英文のままにしてあります。</p>
</blockquote>

<!-- If you try running this code, the program will crash with a message like this: -->

<p>このコードを実行すると、プログラムがクラッシュして、以下のようなメッセージが表示されます。</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;Invalid number: 11&#39;, src/bin/panic-simple.rs:5
</code></pre>

<!-- Here's another example that is slightly less contrived. A program that accepts -->

<!-- an integer as an argument, doubles it and prints it. -->

<p>次は、もう少し自然な例です。
このプログラムは引数として整数を受け取り、2倍した後に表示します。</p>

<p><span id="code-unwrap-double"></span></p>

<span class='rusttest'>use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // エラー1
    let n: i32 = arg.parse().unwrap(); // エラー2
    println!(&quot;{}&quot;, 2 * n);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>argv</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>();
    <span class='kw'>let</span> <span class='ident'>arg</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>argv</span>.<span class='ident'>nth</span>(<span class='number'>1</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// エラー1</span>
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>parse</span>().<span class='ident'>unwrap</span>(); <span class='comment'>// エラー2</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>);
}</pre>

<!-- If you give this program zero arguments (error 1) or if the first argument -->

<!-- isn't an integer (error 2), the program will panic just like in the first -->

<!-- example. -->

<p>もし、このプログラムに引数を与えなかったら（エラー1）、あるいは、最初の引数が整数でなかったら（エラー2）、このプログラムは、最初の例と同じようにパニックするでしょう。</p>

<!-- You can think of this style of error handling as similar to a bull running -->

<!-- through a china shop. The bull will get to where it wants to go, but it will -->

<!-- trample everything in the process. -->

<p>このようなスタイルのエラーハンドリングは、まるで、陶器店の中を駆け抜ける雄牛のようなものです。
雄牛は自分の行きたいところへたどり着くでしょう。
でも彼は、途中にある、あらゆるものを蹴散らしてしまいます。</p>

<!-- ## Unwrapping explained -->

<h2 id='アンラップunwrap-とは' class='section-header'><a href='#アンラップunwrap-とは'>アンラップ(unwrap) とは</a></h2>
<!-- In the previous example, we claimed -->

<!-- that the program would simply panic if it reached one of the two error -->

<!-- conditions, yet, the program does not include an explicit call to `panic` like -->

<!-- the first example. This is because the -->

<!-- panic is embedded in the calls to `unwrap`. -->

<p>先ほどの例で、プログラムが2つのエラー条件のいずれかを満たしたときに、パニックすると言いました。
でもこのプログラムは、最初の例とは違って明示的に <code>panic</code> を呼び出してはいません。
実はパニックは <code>unwrap</code> の呼び出しの中に埋め込まれているのです。</p>

<!-- To “unwrap” something in Rust is to say, “Give me the result of the -->

<!-- computation, and if there was an error, panic and stop the program.” -->

<!-- It would be better if we showed the code for unwrapping because it is so -->

<!-- simple, but to do that, we will first need to explore the `Option` and `Result` -->

<!-- types. Both of these types have a method called `unwrap` defined on them. -->

<p>Rustでなにかを「アンラップする」とき、こう言っているのと同じです。
「計算結果を取り出しなさい。もしエラーになっていたのなら、パニックを起こしてプログラムを終了させなさい。」
アンラップのコードはとてもシンプルなので、多分、それを見せたほうが早いでしょう。
でもそのためには、まず <code>Option</code> と <code>Result</code> 型について調べる必要があります。
どちらの型にも <code>unwrap</code> という名前のメソッドが定義されています。</p>

<!-- ### The `Option` type -->

<h3 id='option-型' class='section-header'><a href='#option-型'><code>Option</code> 型</a></h3>
<!-- The `Option` type is [defined in the standard library][5]: -->

<p><code>Option</code> 型は <a href="../std/option/enum.Option.html">標準ライブラリで定義されています</a>：</p>

<span class='rusttest'>fn main() {
    enum Option&lt;T&gt; {
    None,
    Some(T),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>None</span>,
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>),
}</pre>

<!-- The `Option` type is a way to use Rust's type system to express the -->

<!-- *possibility of absence*. Encoding the possibility of absence into the type -->

<!-- system is an important concept because it will cause the compiler to force the -->

<!-- programmer to handle that absence. Let's take a look at an example that tries -->

<!-- to find a character in a string: -->

<p><code>Option</code> 型は、Rustの型システムを使って <em>不在の可能性</em> を示すためのものです。
不在の可能性を型システムにエンコードすることは、重要なコンセプトです。
なぜなら、その不在に対処することを、コンパイラがプログラマに強制させるからです。
では、文字列から文字を検索する例を見てみましょう。</p>

<p><span id="code-option-ex-string-find"></span></p>

<span class='rusttest'>fn main() {
    // Searches `haystack` for the Unicode character `needle`. If one is found, the
// byte offset of the character is returned. Otherwise, `None` is returned.
// `haystack`（干し草の山）からUnicode文字 `needle`（縫い針）を検索します。
// もし見つかったら、文字のバイトオフセットを返します。見つからなければ、`None` を
// 返します。
fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// `haystack`（干し草の山）からUnicode文字 `needle`（縫い針）を検索します。</span>
<span class='comment'>// もし見つかったら、文字のバイトオフセットを返します。見つからなければ、`None` を</span>
<span class='comment'>// 返します。</span>
<span class='kw'>fn</span> <span class='ident'>find</span>(<span class='ident'>haystack</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>needle</span>: <span class='ident'>char</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
    <span class='kw'>for</span> (<span class='ident'>offset</span>, <span class='ident'>c</span>) <span class='kw'>in</span> <span class='ident'>haystack</span>.<span class='ident'>char_indices</span>() {
        <span class='kw'>if</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='ident'>needle</span> {
            <span class='kw'>return</span> <span class='prelude-val'>Some</span>(<span class='ident'>offset</span>);
        }
    }
    <span class='prelude-val'>None</span>
}</pre>

<!-- Notice that when this function finds a matching character, it doesn't only -->

<!-- return the `offset`. Instead, it returns `Some(offset)`. `Some` is a variant or -->

<!-- a *value constructor* for the `Option` type. You can think of it as a function -->

<!-- with the type `fn<T>(value: T) -> Option<T>`. Correspondingly, `None` is also a -->

<!-- value constructor, except it has no arguments. You can think of `None` as a -->

<!-- function with the type `fn<T>() -> Option<T>`. -->

<p>この関数がマッチする文字を見つけたとき、単に <code>offset</code> を返すだけではないことに注目してください。
その代わりに <code>Some(offset)</code> を返します。
<code>Some</code> は <code>Option</code> 型のヴァリアントの一つ、つまり <em>値コンストラクタ</em> です。
これは <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code> という型の関数だと考えることもできます。
これに対応して <code>None</code> もまた値コンストラクタですが、こちらには引数がありません。
<code>None</code> は <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code> という型の関数だと考えることもできます。</p>

<!-- This might seem like much ado about nothing, but this is only half of the -->

<!-- story. The other half is *using* the `find` function we've written. Let's try -->

<!-- to use it to find the extension in a file name. -->

<p>何もないことを表すのに、ずいぶん大げさだと感じるかもしれません。
でもこれはまだ、話の半分に過ぎません。
残りの半分は、いま書いた <code>find</code> 関数を <em>使う</em> 場面です。
これを使って、ファイル名から拡張子を見つけてみましょう。</p>

<span class='rusttest'>fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
fn main() {
    let file_name = &quot;foobar.rs&quot;;
    match find(file_name, &#39;.&#39;) {
        None =&gt; println!(&quot;No file extension found.&quot;),
        Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>file_name</span> <span class='op'>=</span> <span class='string'>&quot;foobar.rs&quot;</span>;
    <span class='kw'>match</span> <span class='ident'>find</span>(<span class='ident'>file_name</span>, <span class='string'>&#39;.&#39;</span>) {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;No file extension found.&quot;</span>),
        <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;File extension: {}&quot;</span>, <span class='kw-2'>&amp;</span><span class='ident'>file_name</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..]),
    }
}</pre>

<blockquote>
<p>訳注：</p>

<ul>
<li>No file extension found：ファイル拡張子は見つかりませんでした</li>
<li>File extension: {}：ファイル拡張子：{}</li>
</ul>
</blockquote>

<!-- This code uses [pattern matching][1] to do *case -->

<!-- analysis* on the `Option<usize>` returned by the `find` function. In fact, case -->

<!-- analysis is the only way to get at the value stored inside an `Option<T>`. This -->

<!-- means that you, as the programmer, must handle the case when an `Option<T>` is -->

<!-- `None` instead of `Some(t)`. -->

<p>このコードは <code>find</code> 関数が返した <code>Option&lt;usize&gt;</code> の <em>場合分け</em> に、 <a href="../book/patterns.html">パターンマッチ</a> を使っています。
実のところ、場合分けが、<code>Option&lt;T&gt;</code> に格納された値を取り出すための唯一の方法なのです。
これは、<code>Option&lt;T&gt;</code> が <code>Some(t)</code> ではなく <code>None</code> だったとき、プログラマであるあなたが、このケースに対処しなければならないことを意味します。</p>

<!-- But wait, what about `unwrap`, which we used [previously](#code-unwrap-double)? -->

<!-- There was no case analysis there! Instead, the case analysis was put inside the -->

<!-- `unwrap` method for you. You could define it yourself if you want: -->

<p>でも、ちょっと待ってください。 <a href="#code-unwrap-double">さっき</a> 使った <code>unwrap</code> はどうだったでしょうか？
場合分けはどこにもありませんでした！
実は場合分けは <code>unwrap</code> メソッドの中に埋め込まれていたのです。
もし望むなら、このように自分で定義することもできます：</p>

<p><span id="code-option-def-unwrap"></span></p>

<span class='rusttest'>fn main() {
    enum Option&lt;T&gt; {
    None,
    Some(T),
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Option::Some(val) =&gt; val,
            Option::None =&gt;
              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>None</span>,
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>),
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='kw'>match</span> <span class='self'>self</span> {
            <span class='prelude-ty'>Option</span>::<span class='prelude-val'>Some</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
            <span class='prelude-ty'>Option</span>::<span class='prelude-val'>None</span> <span class='op'>=&gt;</span>
              <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;called `Option::unwrap()` on a `None` value&quot;</span>),
        }
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>called <code>Option::unwrap()</code> on a <code>None</code> value：<br/>
<code>None</code> な値に対して <code>Option:unwrap()</code> が呼ばれました</p>
</blockquote>

<!-- The `unwrap` method *abstracts away the case analysis*. This is precisely the thing -->

<!-- that makes `unwrap` ergonomic to use. Unfortunately, that `panic!` means that -->

<!-- `unwrap` is not composable: it is the bull in the china shop. -->

<p><code>unwrap</code> メソッドは <em>場合分けを抽象化します</em> 。このことは確かに <code>unwrap</code> をエルゴノミックにしています。
しかし残念なことに、そこにある <code>panic!</code> が意味するものは、<code>unwrap</code> が合成可能ではない、つまり、陶器店の中の雄牛だということです。</p>

<!--- ### Composing `Option<T>` values -->

<h3 id='optiont-値を合成する' class='section-header'><a href='#optiont-値を合成する'><code>Option&lt;T&gt;</code> 値を合成する</a></h3>
<!-- In an [example from before](#code-option-ex-string-find), -->

<!-- we saw how to use `find` to discover the extension in a file name. Of course, -->

<!-- not all file names have a `.` in them, so it's possible that the file name has -->

<!-- no extension. This *possibility of absence* is encoded into the types using -->

<!-- `Option<T>`. In other words, the compiler will force us to address the -->

<!-- possibility that an extension does not exist. In our case, we only print out a -->

<!-- message saying as such. -->

<p><a href="#code-option-ex-string-find">先ほどの例</a> では、ファイル名から拡張子を見つけるために <code>find</code> をどのように使うかを見ました。
当然ながら全てのファイル名に <code>.</code> があるわけではなく、拡張子のないファイル名もあり得ます。
このような <em>不在の可能性</em> は <code>Option&lt;T&gt;</code> を使うことによって、型の中にエンコードされています。
すなわち、コンパイラは、拡張子が存在しない可能性に対処することを、私たちに強制してくるわけです。
今回は単に、そうなったことを告げるメッセージを表示するようにしました。</p>

<!-- Getting the extension of a file name is a pretty common operation, so it makes -->

<!-- sense to put it into a function: -->

<p>ファイル名から拡張子を取り出すことは一般的な操作ですので、それを関数にすることは理にかなっています。</p>

<span class='rusttest'>fn main() {
    fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
// 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の
// `.` に続く、全ての文字である。
// もし `file_name` に `.` がなければ、`None` が返される。
fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match find(file_name, &#39;.&#39;) {
        None =&gt; None,
        Some(i) =&gt; Some(&amp;file_name[i+1..]),
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の</span>
<span class='comment'>// `.` に続く、全ての文字である。</span>
<span class='comment'>// もし `file_name` に `.` がなければ、`None` が返される。</span>
<span class='kw'>fn</span> <span class='ident'>extension_explicit</span>(<span class='ident'>file_name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>find</span>(<span class='ident'>file_name</span>, <span class='string'>&#39;.&#39;</span>) {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='ident'>file_name</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..]),
    }
}</pre>

<!-- (pro-tip: don't use this code. Use the -->

<!-- [`extension`](../std/path/struct.Path.html#method.extension) -->

<!-- method in the standard library instead.) -->

<p>（プロ向けのヒント：このコードは使わず、代わりに標準ライブラリの
<a href="../std/path/struct.Path.html#method.extension"><code>extension</code></a>
メソッドを使ってください）</p>

<!-- The code stays simple, but the important thing to notice is that the type of -->

<!-- `find` forces us to consider the possibility of absence. This is a good thing -->

<!-- because it means the compiler won't let us accidentally forget about the case -->

<!-- where a file name doesn't have an extension. On the other hand, doing explicit -->

<!-- case analysis like we've done in `extension_explicit` every time can get a bit -->

<!-- tiresome. -->

<p>このコードはいたってシンプルですが、ひとつだけ注目して欲しいのは、<code>find</code> の型が不在の可能性について考慮することを強制していることです。
これは良いことです。なぜなら、コンパイラが私たちに、ファイル名が拡張子を持たないケースを、うっかり忘れないようにしてくれるからです。
しかし一方で、 <code>extension_explicit</code> でしたような明示的な場合分けを毎回続けるのは、なかなか面倒です。</p>

<!-- In fact, the case analysis in `extension_explicit` follows a very common -->

<!-- pattern: *map* a function on to the value inside of an `Option<T>`, unless the -->

<!-- option is `None`, in which case, return `None`. -->

<p>実は <code>extension_explicit</code> での場合分けは、ごく一般的なパターンである、<code>Option&lt;T&gt;</code> への <em>map</em> の適用に当てはめられます。
これは、もしオプションが <code>None</code> なら <code>None</code> を返し、そうでなけれは、オプションの中の値に関数を適用する、というパターンです。</p>

<!-- Rust has parametric polymorphism, so it is very easy to define a combinator -->

<!-- that abstracts this pattern: -->

<p>Rustはパラメトリック多相をサポートしていますので、このパターンを抽象化するためのコンビネータが簡単に定義できます：</p>

<p><span id="code-option-map"></span></p>

<span class='rusttest'>fn main() {
    fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
    match option {
        None =&gt; None,
        Some(value) =&gt; Some(f(value)),
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>map</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>T</span>, <span class='ident'>A</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>A</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>value</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>f</span>(<span class='ident'>value</span>)),
    }
}</pre>

<!-- Indeed, `map` is [defined as a method][2] on `Option<T>` in the standard library. -->

<!-- As a method, it has a slightly different signature: methods take `self`, `&self`, -->

<!-- or `&mut self` as their first argument. -->

<p>もちろん <code>map</code> は、標準のライブラリの <code>Option&lt;T&gt;</code> で <a href="../std/option/enum.Option.html#method.map">メソッドとして定義されています</a>。
メソッドなので、少し違うシグネチャを持っています。
メソッドは第一引数に <code>self</code> 、 <code>&amp;self</code> あるいは <code>&amp;mut self</code> を取ります。</p>

<!-- Armed with our new combinator, we can rewrite our `extension_explicit` method -->

<!-- to get rid of the case analysis: -->

<p>新しいコンビネータを手に入れましたので、 <code>extension_explicit</code> メソッドを書き直して、場合分けを省きましょう：</p>

<span class='rusttest'>fn main() {
    fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
// 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の
// `.` に続く、全ての文字である。
// もし `file_name` に `.` がなければ、`None` が返される。
fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, &#39;.&#39;).map(|i| &amp;file_name[i+1..])
}
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の</span>
<span class='comment'>// `.` に続く、全ての文字である。</span>
<span class='comment'>// もし `file_name` に `.` がなければ、`None` が返される。</span>
<span class='kw'>fn</span> <span class='ident'>extension</span>(<span class='ident'>file_name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='ident'>find</span>(<span class='ident'>file_name</span>, <span class='string'>&#39;.&#39;</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='ident'>file_name</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..])
}</pre>

<!-- One other pattern we commonly find is assigning a default value to the case -->

<!-- when an `Option` value is `None`. For example, maybe your program assumes that -->

<!-- the extension of a file is `rs` even if none is present. As you might imagine, -->

<!-- the case analysis for this is not specific to file extensions - it can work -->

<!-- with any `Option<T>`: -->

<p>もう一つの共通のパターンは、<code>Option</code> の値が <code>None</code> だったときのデフォルト値を与えることです。
例えばファイルの拡張子がないときは、それを <code>rs</code> とみなすようなプログラムを書きたくなるかもしれません。
ご想像の通り、このような場合分けはファイルの拡張子に特有のものではありません。
どんな <code>Option&lt;T&gt;</code> でも使えるでしょう：</p>

<span class='rusttest'>fn main() {
    fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    match option {
        None =&gt; default,
        Some(value) =&gt; value,
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>unwrap_or</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>default</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='ident'>default</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>value</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span>,
    }
}</pre>

<!-- Like with `map` above, the standard library implementation is a method instead -->

<!-- of a free function. -->

<p>上記の <code>map</code> と同じように、標準ライブラリの実装はただの関数ではなくメソッドになっています。</p>

<!-- The trick here is that the default value must have the same type as the value -->

<!-- that might be inside the `Option<T>`. Using it is dead simple in our case: -->

<p>ここでの仕掛けは、<code>Option&lt;T&gt;</code> に入れる値と同じ型になるよう、デフォルト値の型を制限していることです。
これを使うのは、すごく簡単です：</p>

<span class='rusttest'>fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}

fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, &#39;.&#39;).map(|i| &amp;file_name[i+1..])
}
fn main() {
    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);
    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>extension</span>(<span class='string'>&quot;foobar.csv&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;rs&quot;</span>), <span class='string'>&quot;csv&quot;</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>extension</span>(<span class='string'>&quot;foobar&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;rs&quot;</span>), <span class='string'>&quot;rs&quot;</span>);
}</pre>

<!-- (Note that `unwrap_or` is [defined as a method][3] on `Option<T>` in the -->

<!-- standard library, so we use that here instead of the free-standing function we -->

<!-- defined above. Don't forget to check out the more general [`unwrap_or_else`][4] -->

<!-- method.) -->

<p>（<code>unwrap_or</code> は、標準のライブラリの <code>Option&lt;T&gt;</code> で、 <a href="../std/option/enum.Option.html#method.unwrap_or">メソッドとして定義されています</a> ので、いま定義したフリースタンディングな関数の代わりに、そちらを使いましょう。）</p>

<!-- There is one more combinator that we think is worth paying special attention to: -->

<!-- `and_then`. It makes it easy to compose distinct computations that admit the -->

<!-- *possibility of absence*. For example, much of the code in this section is -->

<!-- about finding an extension given a file name. In order to do this, you first -->

<!-- need the file name which is typically extracted from a file *path*. While most -->

<!-- file paths have a file name, not *all* of them do. For example, `.`, `..` or -->

<!-- `/`. -->

<p>もうひとつ特筆すべきコンビネータがあります。それは <code>and_then</code> です。これを使うと <em>不在の可能性</em> を考慮しながら、別々の処理を簡単に組み合わせることができます。
例えば、この節のほとんどのコードは、与えられたファイル名について拡張子を見つけだします。
そのためには、まずファイル <em>パス</em> から取り出したファイル名が必要です。
大抵のパスにはファイル名がありますが、 <em>全て</em> がというわけではありません。
例えば <code>.</code>, <code>..</code>, <code>/</code> などは例外です。</p>

<!-- So, we are tasked with the challenge of finding an extension given a file -->

<!-- *path*. Let's start with explicit case analysis: -->

<p>つまり、与えられたファイル <em>パス</em> から拡張子を見つけ出せるか、トライしなければなりません。
まず明示的な場合分けから始めましょう：</p>

<span class='rusttest'>fn main() {
    fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match file_name(file_path) {
        None =&gt; None,
        Some(name) =&gt; match extension(name) {
            None =&gt; None,
            Some(ext) =&gt; Some(ext),
        }
    }
}

fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
 // implementation elided
  // 実装は省略
  unimplemented!()
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>file_path_ext_explicit</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>file_name</span>(<span class='ident'>file_path</span>) {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>name</span>) <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='ident'>extension</span>(<span class='ident'>name</span>) {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
            <span class='prelude-val'>Some</span>(<span class='ident'>ext</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>ext</span>),
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>file_name</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
  <span class='comment'>// 実装は省略</span>
  <span class='macro'>unimplemented</span><span class='macro'>!</span>()
}</pre>

<!-- You might think that we could use the `map` combinator to reduce the case -->

<!-- analysis, but its type doesn't quite fit... -->

<p>場合分けを減らすために単に <code>map</code> コンビネータを使えばいいと思うかもしれませんが、型にうまく適合しません。</p>

<span class='rusttest'>fn main() {
    fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).map(|x| extension(x)) //Compilation error
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>file_path_ext</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='ident'>file_name</span>(<span class='ident'>file_path</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>extension</span>(<span class='ident'>x</span>)) <span class='comment'>//Compilation error</span>
}</pre>

<!-- The `map` function here wraps the value returned by the `extension` function -->

<!-- inside an `Option<_>` and since the `extension` function itself returns an -->

<!-- `Option<&str>` the expression `file_name(file_path).map(|x| extension(x))` -->

<!-- actually returns an `Option<Option<&str>>`. -->

<p>ここの <code>map</code> 関数は <code>Option&lt;_&gt;</code> 内で <code>extension</code> 関数が返した値をラップしていますが <code>extension</code> 関数自身が <code>Option&lt;&amp;str&gt;</code> を返すので、式 <code>file_name(file_path).map(|x| extension(x))</code> は実際は <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code> を返すのです。</p>

<!-- But since `file_path_ext` just returns `Option<&str>` (and not -->

<!-- `Option<Option<&str>>`) we get a compilation error. -->

<p>しかしながら <code>file_path_ext</code> は（<code>Option&lt;Option&lt;&amp;str&gt;&gt;</code> ではなく）ただの <code>Option&lt;&amp;str&gt;</code> を返すのでコンパイルエラーとなるのです。</p>

<!-- The result of the function taken by map as input is *always* [rewrapped with -->

<!-- `Some`](#code-option-map). Instead, we need something like `map`, but which -->

<!-- allows the caller to return a `Option<_>` directly without wrapping it in -->

<!-- another `Option<_>`. -->

<p>そして関数が返した値は <em>必ず</em> <a href="#code-option-map"><code>Some</code> でラップされ直します</a> 。
つまりこの代わりに、 <code>map</code> に似た、しかし新たに <code>Option&lt;_&gt;</code> で包まずに直接呼び出し元に常に <code>Option&lt;_&gt;</code> を返すものが必要です。</p>

<!-- Its generic implementation is even simpler than `map`: -->

<p>これの汎用的な実装は <code>map</code> よりもシンプルです：</p>

<span class='rusttest'>fn main() {
    fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        where F: FnOnce(T) -&gt; Option&lt;A&gt; {
    match option {
        None =&gt; None,
        Some(value) =&gt; f(value),
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>and_then</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>T</span>, <span class='ident'>A</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span>
        <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>value</span>) <span class='op'>=&gt;</span> <span class='ident'>f</span>(<span class='ident'>value</span>),
    }
}</pre>

<!-- Now we can rewrite our `file_path_ext` function without explicit case analysis: -->

<p>では、明示的な場合分けを省くように、 <code>file_path_ext</code> を書き直しましょう：</p>

<span class='rusttest'>fn main() {
    fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).and_then(extension)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>file_path_ext</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='ident'>file_name</span>(<span class='ident'>file_path</span>).<span class='ident'>and_then</span>(<span class='ident'>extension</span>)
}</pre>

<!-- Side note: Since `and_then` essentially works like `map` but returns an -->

<!-- `Option<_>` instead of an `Option<Option<_>>` it is known as `flatmap` in some -->

<!-- other languages. -->

<p>補足: <code>and_then</code> は基本的に <code>map</code> のように振舞いますが <code>Option&lt;Option_&gt;&gt;</code> の代わりに <code>Option&lt;_&gt;</code> を返すので <code>flatmap</code> と呼ぶ言語もあります。</p>

<!-- The `Option` type has many other combinators [defined in the standardy
<!-- library][5]. It is a good idea to skim this list and familiarize -->

<!-- yourself with what's available—they can often reduce case analysis -->

<!-- for you. Familiarizing yourself with these combinators will pay -->

<!-- dividends because many of them are also defined (with similar -->

<!-- semantics) for `Result`, which we will talk about next. -->

<p><code>Option</code> 型には、他にもたくさんのコンビネータが <a href="../std/option/enum.Option.html">標準ライブラリで定義されています</a> 。
それらの一覧をざっと眺めて、なにがあるか知っておくといいでしょう。
大抵の場合、場合分けを減らすのに役立ちます。
それらのコンビネータに慣れるための努力は、すぐに報われるでしょう。
なぜなら、そのほとんどは次に話す <code>Result</code> 型でも、（よく似たセマンティクスで）定義されているからです。</p>

<!-- Combinators make using types like `Option` ergonomic because they reduce -->

<!-- explicit case analysis. They are also composable because they permit the caller -->

<!-- to handle the possibility of absence in their own way. Methods like `unwrap` -->

<!-- remove choices because they will panic if `Option<T>` is `None`. -->

<p>コンビネータは明示的な場合分けを減らしてくれるので、 <code>Option</code> のような型をエルゴノミックにします。
またこれらは <em>不在の可能性</em> を、呼び出し元がそれに合った方法で扱えるようにするので、合成可能だといえます。
<code>unwrap</code> のようなメソッドは、 <code>Option&lt;T&gt;</code> が <code>None</code> のときにパニックを起こすので、このような選択の機会を与えません。</p>

<!-- ## The `Result` type -->

<h2 id='result-型' class='section-header'><a href='#result-型'><code>Result</code> 型</a></h2>
<!-- The `Result` type is also -->

<!-- [defined in the standard library][6]: -->

<p><code>Result</code> 型も <a href="../std/result/">標準ライブラリで定義されています</a> 。</p>

<p><span id="code-result-def"></span></p>

<span class='rusttest'>fn main() {
    enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>T</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>E</span>),
}</pre>

<!-- The `Result` type is a richer version of `Option`. Instead of expressing the -->

<!-- possibility of *absence* like `Option` does, `Result` expresses the possibility -->

<!-- of *error*. Usually, the *error* is used to explain why the execution of some -->

<!-- computation failed. This is a strictly more general form of `Option`. Consider -->

<!-- the following type alias, which is semantically equivalent to the real -->

<!-- `Option<T>` in every way: -->

<p><code>Result</code> 型は <code>Option</code> 型の豪華版です。
<code>Option</code> のように <em>不在</em> の可能性を示す代わりに、<code>Result</code> は <em>エラー</em> になる可能性を示します。
通常 <em>エラー</em> は、なぜ処理が実行に失敗したのかを説明するために用いられます。
これは厳密には <code>Option</code> をさらに一般化した形式だといえます。
以下のような型エイリアスがあるとしましょう。
これは全てにおいて、本物の <code>Option&lt;T&gt;</code> と等しいセマンティクスを持ちます。</p>

<span class='rusttest'>fn main() {
    type Option&lt;T&gt; = Result&lt;T, ()&gt;;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, ()<span class='op'>&gt;</span>;</pre>

<!-- This fixes the second type parameter of `Result` to always be `()` (pronounced -->

<!-- “unit” or “empty tuple”). Exactly one value inhabits the `()` type: `()`. (Yup, -->

<!-- the type and value level terms have the same notation!) -->

<p>これは <code>Result</code> の2番目の型パラメータを <code>()</code> （「ユニット」または「空タプル」と発音します）に固定したものです。
<code>()</code> 型のただ一つの値は <code>()</code> です。
（そうなんです。型レベルと値レベルの項が、全く同じ表記法を持ちます!）</p>

<!-- The `Result` type is a way of representing one of two possible outcomes in a -->

<!-- computation. By convention, one outcome is meant to be expected or “`Ok`” while -->

<!-- the other outcome is meant to be unexpected or “`Err`”. -->

<p><code>Result</code> 型は、処理の結果がとりうる2つの可能性のうち、1つを表すための方法です。
慣例に従い、一方が期待されている結果、つまり「<code>Ok</code>」となり、もう一方が予想外の結果、つまり「<code>Err</code>」になります。</p>

<!-- Just like `Option`, the `Result` type also has an -->

<!-- [`unwrap` method -->

<!-- defined][7] -->

<!-- in the standard library. Let's define it: -->

<p><code>Option</code> と全く同じように、<code>Result</code> 型も標準ライブラリで <a href="../std/result/enum.Result.html#method.unwrap"><code>unwrap</code> メソッドが定義されています</a> 。
定義してみましょう：</p>

<span class='rusttest'>fn main() {
    enum Result&lt;T, E&gt; { Ok(T), Err(E) }
impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Result::Ok(val) =&gt; val,
            Result::Err(err) =&gt;
              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),
        }
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span>: ::<span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span><span class='op'>&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='kw'>match</span> <span class='self'>self</span> {
            <span class='prelude-ty'>Result</span>::<span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
            <span class='prelude-ty'>Result</span>::<span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span>
              <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;</span>, <span class='ident'>err</span>),
        }
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>called <code>Result::unwrap()</code> on an <code>Err</code> value: {:?}&quot;：<br/>
<code>Err</code> 値 {:?} に対して <code>Result::unwrap()</code> が呼ばれました</p>
</blockquote>

<!-- This is effectively the same as our [definition for -->

<!-- `Option::unwrap`](#code-option-def-unwrap), except it includes the -->

<!-- error value in the `panic!` message. This makes debugging easier, but -->

<!-- it also requires us to add a [`Debug`][8] constraint on the `E` type -->

<!-- parameter (which represents our error type). Since the vast majority -->

<!-- of types should satisfy the `Debug` constraint, this tends to work out -->

<!-- in practice. (`Debug` on a type simply means that there's a reasonable -->

<!-- way to print a human readable description of values with that type.) -->

<p>これは実質的には私たちの <a href="#code-option-def-unwrap"><code>Option::unwrap</code> の定義</a> と同じですが、 <code>panic!</code> メッセージにエラーの値が含まれているところが異なります。
これはデバッグをより簡単にしますが、一方で、（エラーの型を表す）型パラメータ <code>E</code> に <a href="../std/fmt/trait.Debug.html"><code>Debug</code></a> 制約を付けることが求められます。
大半の型は <code>Debug</code> 制約を満たしているので、実際のところ、うまくいく傾向にあります。
（<code>Debug</code> が型に付くということは、単にその型の値が、人間が読める形式で表示できることを意味しています。）</p>

<!-- OK, let's move on to an example. -->

<p>では、例を見ていきましょう。</p>

<!-- ### Parsing integers -->

<h3 id='整数をパースする' class='section-header'><a href='#整数をパースする'>整数をパースする</a></h3>
<!-- The Rust standard library makes converting strings to integers dead simple. -->

<!-- It's so easy in fact, that it is very tempting to write something like the -->

<!-- following: -->

<p>Rustの標準ライブラリを使うと、文字列を整数に変換することが、すごく簡単にできます。
あまりにも簡単なので、実際のところ、以下のように書きたいという誘惑に負けることがあります：</p>

<span class='rusttest'>fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number(&quot;10&quot;);
    assert_eq!(n, 20);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>number_str</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>unwrap</span>()
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>double_number</span>(<span class='string'>&quot;10&quot;</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>n</span>, <span class='number'>20</span>);
}</pre>

<!-- At this point, you should be skeptical of calling `unwrap`. For example, if -->

<!-- the string doesn't parse as a number, you'll get a panic: -->

<p>すでにあなたは、<code>unwrap</code> を呼ぶことについて懐疑的になっているはずです。
例えば、文字列が数字としてパースできなければ、パニックが起こります。</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }&#39;, /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</code></pre>

<!-- This is rather unsightly, and if this happened inside a library you're -->

<!-- using, you might be understandably annoyed. Instead, we should try to -->

<!-- handle the error in our function and let the caller decide what to -->

<!-- do. This means changing the return type of `double_number`. But to -->

<!-- what? Well, that requires looking at the signature of the [`parse` -->

<!-- method][9] in the standard library: -->

<p>これは少し目障りです。
もしあなたが使っているライブラリの中でこれが起こされたら、イライラするに違いありません。
代わりに、私たちの関数の中でエラーを処理し、呼び出し元にどうするのかを決めさせるべきです。
そのためには、<code>double_number</code> の戻り値の型（リターン型）を変更しなければなりません。
でも、一体何に？
ええと、これはつまり、標準ライブラリの <a href="../std/primitive.str.html#method.parse"><code>parse</code> メソッド</a> のシグネチャを見ろということです。</p>

<span class='rusttest'>fn main() {
    impl str {
    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>str</span> {
    <span class='kw'>fn</span> <span class='ident'>parse</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>FromStr</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>F</span>::<span class='prelude-val'>Err</span><span class='op'>&gt;</span>;
}</pre>

<!-- Hmm. So we at least know that we need to use a `Result`. Certainly, it's -->

<!-- possible that this could have returned an `Option`. After all, a string either -->

<!-- parses as a number or it doesn't, right? That's certainly a reasonable way to -->

<!-- go, but the implementation internally distinguishes *why* the string didn't -->

<!-- parse as an integer. (Whether it's an empty string, an invalid digit, too big -->

<!-- or too small.) Therefore, using a `Result` makes sense because we want to -->

<!-- provide more information than simply “absence.” We want to say *why* the -->

<!-- parsing failed. You should try to emulate this line of reasoning when faced -->

<!-- with a choice between `Option` and `Result`. If you can provide detailed error -->

<!-- information, then you probably should. (We'll see more on this later.) -->

<p>うむ。最低でも <code>Result</code> を使わないといけないことはわかりました。
もちろん、これが <code>Option</code> を戻すようにすることも可能だったでしょう。
結局のところ、文字列が数字としてパースできたかどうかが知りたいわけですよね？
それも悪いやり方ではありませんが、実装の内側では <em>なぜ</em> 文字列が整数としてパースできなかったを、ちゃんと区別しています。
（空の文字列だったのか、有効な数字でなかったのか、大きすぎたり、小さすぎたりしたのか。）
従って、<code>Result</code> を使ってより多くの情報を提供するほうが、単に「不在」を示すことよりも理にかなっています。
今後、もし <code>Option</code> と <code>Result</code> のどちらを選ぶという事態に遭遇したときは、このような理由付けのやり方を真似てみてください。
もし詳細なエラー情報を提供できるのなら、多分、それをしたほうがいいでしょう。
（後ほど別の例もお見せます。）</p>

<!-- OK, but how do we write our return type? The `parse` method as defined -->

<!-- above is generic over all the different number types defined in the -->

<!-- standard library. We could (and probably should) also make our -->

<!-- function generic, but let's favor explicitness for the moment. We only -->

<!-- care about `i32`, so we need to [find its implementation of -->

<!-- `FromStr`](../std/primitive.i32.html) (do a `CTRL-F` in your browser -->

<!-- for “FromStr”) and look at its [associated type][10] `Err`. We did -->

<!-- this so we can find the concrete error type. In this case, it's -->

<!-- [`std::num::ParseIntError`](../std/num/struct.ParseIntError.html). -->

<!-- Finally, we can rewrite our function: -->

<p>それでは、リターン型をどう書きましょうか？
上の <code>parse</code> メソッドは一般化されているので、標準ライブラリにある、あらゆる数値型について定義されています。
この関数を同じように一般化することもできますが（そして、そうするべきでしょうが）、今は明快さを優先しましょう。
<code>i32</code> だけを扱うことにしますので、それの <a href="../std/primitive.i32.html"><code>FromStr</code> の実装がどうなっているか探しましょう</a> 。
（ブラウザで <code>CTRL-F</code> を押して「FromStr」を探します。）
そして <a href="../book/associated-types.html">関連型(associated type)</a> から <code>Err</code> を見つけます。
こうすれば、具体的なエラー型が見つかります。
この場合、それは <a href="../std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> です。
これでようやく関数を書き直せます：</p>

<span class='rusttest'>use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>;

<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>ParseIntError</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>number_str</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>() {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>double_number</span>(<span class='string'>&quot;10&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>n</span>, <span class='number'>20</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {:?}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- This is a little better, but now we've written a lot more code! The case -->

<!-- analysis has once again bitten us. -->

<p>これで少し良くなりましたが、たくさんのコードを書いてしまいました！
場合分けに、またしてもやられたわけです。</p>

<!-- Combinators to the rescue! Just like `Option`, `Result` has lots of combinators -->

<!-- defined as methods. There is a large intersection of common combinators between -->

<!-- `Result` and `Option`. In particular, `map` is part of that intersection: -->

<p>コンビネータに助けを求めましょう！
ちょうど <code>Option</code> と同じように <code>Result</code> にもたくさんのコンビネータが、メソッドとして定義されています。
<code>Result</code> と <code>Option</code> の間では、共通のコンビネータが数多く存在します。
例えば <code>map</code> も共通なものの一つです：</p>

<span class='rusttest'>use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>;

<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>ParseIntError</span><span class='op'>&gt;</span> {
    <span class='ident'>number_str</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>double_number</span>(<span class='string'>&quot;10&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>n</span>, <span class='number'>20</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {:?}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- The usual suspects are all there for `Result`, including -->

<!-- [`unwrap_or`](../std/result/enum.Result.html#method.unwrap_or) and -->

<!-- [`and_then`](../std/result/enum.Result.html#method.and_then). -->

<!-- Additionally, since `Result` has a second type parameter, there are -->

<!-- combinators that affect only the error type, such as -->

<!-- [`map_err`](../std/result/enum.Result.html#method.map_err) (instead of -->

<!-- `map`) and [`or_else`](../std/result/enum.Result.html#method.or_else) -->

<!-- (instead of `and_then`). -->

<p><code>Result</code> でいつも候補にあがるのは <a href="../std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> と <a href="../std/result/enum.Result.html#method.and_then"><code>and_then</code></a> です。
さらに <code>Result</code> は2つ目の型パラメータを取りますので、エラー型だけに影響を与える <a href="../std/result/enum.Result.html#method.map_err"><code>map_err</code></a> （<code>map</code> に相当）と <a href="../std/result/enum.Result.html#method.or_else"><code>or_else</code></a> （<code>and_then</code> に相当）もあります。</p>

<!-- ### The `Result` type alias idiom -->

<h3 id='result-型エイリアスを用いたイディオム' class='section-header'><a href='#result-型エイリアスを用いたイディオム'><code>Result</code> 型エイリアスを用いたイディオム</a></h3>
<!-- In the standard library, you may frequently see types like -->

<!-- `Result<i32>`. But wait, [we defined `Result`](#code-result-def) to -->

<!-- have two type parameters. How can we get away with only specifying -->

<!-- one? The key is to define a `Result` type alias that *fixes* one of -->

<!-- the type parameters to a particular type. Usually the fixed type is -->

<!-- the error type. For example, our previous example parsing integers -->

<!-- could be rewritten like this: -->

<p>標準ライブラリでは <code>Result&lt;i32&gt;</code> のような型をよく見ると思います。
でも、待ってください。
2つの型パラメータを取るように <a href="#code-result-def"><code>Result</code> を定義したはずです</a> 。
どうして、1つだけを指定して済んだのでしょう？
種を明かすと、<code>Result</code> の型エイリアスを定義して、一方の型パラメータを特定の型に <em>固定</em> したのです。
通常はエラー型の方を固定します。
例えば、先ほどの整数のパースの例は、こう書き換えることもできます。</p>

<span class='rusttest'>fn main() {
    use std::num::ParseIntError;
use std::result;

type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
    unimplemented!();
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>result</span>;

<span class='kw'>type</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>result</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>ParseIntError</span><span class='op'>&gt;</span>;

<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='macro'>unimplemented</span><span class='macro'>!</span>();
}</pre>

<!-- Why would we do this? Well, if we have a lot of functions that could return -->

<!-- `ParseIntError`, then it's much more convenient to define an alias that always -->

<!-- uses `ParseIntError` so that we don't have to write it out all the time. -->

<p>なぜ、こうするのでしょうか？
もし <code>ParseIntError</code> を返す関数をたくさん定義するとしたら、常に <code>ParseIntError</code> を使うエイリアスを定義したほうが便利だからです。
こうすれば、同じことを何度も書かずに済みます。</p>

<!-- The most prominent place this idiom is used in the standard library is -->

<!-- with [`io::Result`](../std/io/type.Result.html). Typically, one writes -->

<!-- `io::Result<T>`, which makes it clear that you're using the `io` -->

<!-- module's type alias instead of the plain definition from -->

<!-- `std::result`. (This idiom is also used for -->

<!-- [`fmt::Result`](../std/fmt/type.Result.html).) -->

<p>標準ライブラリで、このイディオムが際立って多く使われている場所では、<a href="../std/io/type.Result.html"><code>io::Result</code></a> を用いています。
それらは通常 <code>io::Result&lt;T&gt;</code> のように書かれ、<code>std::result</code> のプレーンな定義の代わりに <code>io</code> モジュールの型エイリアスを使っていることが、明確にわかるようになっています。</p>

<!-- ## A brief interlude: unwrapping isn't evil -->

<h2 id='小休止アンラップは悪ではない' class='section-header'><a href='#小休止アンラップは悪ではない'>小休止：アンラップは悪ではない</a></h2>
<!-- If you've been following along, you might have noticed that I've taken a pretty -->

<!-- hard line against calling methods like `unwrap` that could `panic` and abort -->

<!-- your program. *Generally speaking*, this is good advice. -->

<p>これまでの説明を読んだあなたは、 <code>unwrap</code> のような <code>panic</code> を起こし、プログラムをアボートするようなメソッドについて、私がきっぱりと否定する方針をとっていたことに気づいたかもしれません。
<em>一般的には</em> これは良いアドバイスです。</p>

<!-- However, `unwrap` can still be used judiciously. What exactly justifies use of -->

<!-- `unwrap` is somewhat of a grey area and reasonable people can disagree. I'll -->

<!-- summarize some of my *opinions* on the matter. -->

<p>しかしながら <code>unwrap</code> を使うのが賢明なこともあります。
どんな場合に <code>unwrap</code> の使用を正当化できるのかについては、グレーな部分があり、人によって意見が分かれます。
ここで、この問題についての、私の <em>個人的な意見</em> をまとめたいと思います。</p>

<!-- * **In examples and quick 'n' dirty code.** Sometimes you're writing examples -->

<!--   or a quick program, and error handling simply isn't important. Beating the -->

<!--   convenience of `unwrap` can be hard in such scenarios, so it is very -->

<!--   appealing. -->

<ul>
<li><strong>即興で書いたサンプルコード。</strong>
サンプルコードや簡単なプログラムを書いていて、エラーハンドリングが単に重要でないこともあります。
このようなときに <code>unwrap</code> の便利さは、とても魅力的に映るでしょう。
これに打ち勝つのは難しいことです。</li>
</ul>

<!-- * **When panicking indicates a bug in the program.** When the invariants of -->

<!--   your code should prevent a certain case from happening (like, say, popping -->

<!--   from an empty stack), then panicking can be permissible. This is because it -->

<!--   exposes a bug in your program. This can be explicit, like from an `assert!` -->

<!--   failing, or it could be because your index into an array was out of bounds. -->

<ul>
<li><strong>パニックがプログラムのバグの兆候となるとき。</strong>
コードの中の不変条件が、ある特定のケースの発生を未然に防ぐとき（例えば、空のスタックから取り出そうとしたなど）、パニックを起こしても差し支えありません。
なぜなら、そうすることでプログラムに潜むバグが明るみに出るからです。
これは <code>assert!</code> の失敗のような明示的な要因によるものだったり、配列のインデックスが境界から外れたからだったりします。</li>
</ul>

<!-- This is probably not an exhaustive list. Moreover, when using an -->

<!-- `Option`, it is often better to use its -->

<!-- [`expect`](../std/option/enum.Option.html#method.expect) -->

<!-- method. `expect` does exactly the same thing as `unwrap`, except it -->

<!-- prints a message you give to `expect`. This makes the resulting panic -->

<!-- a bit nicer to deal with, since it will show your message instead of -->

<!-- “callaed unwrap on a `None` value.” -->

<p>これは多分、完全なリストではないでしょう。
さらに <code>Option</code> を使うときは、ほとんどの場合で <a href="../std/option/enum.Option.html#method.expect"><code>expect</code></a> メソッドを使う方がいいでしょう。
<code>expect</code> は <code>unwrap</code> とほぼ同じことをしますが、 <code>expect</code> では与えられたメッセージを表示するところが異なります。
この方が結果として起こったパニックを、少し扱いやすいものにします。
なぜなら「 <code>None</code> な値に対してアンラップが呼ばれました」というメッセージの代わりに、指定したメッセージが表示されるからです。</p>

<!-- My advice boils down to this: use good judgment. There's a reason why the words -->

<!-- “never do X” or “Y is considered harmful” don't appear in my writing. There are -->

<!-- trade offs to all things, and it is up to you as the programmer to determine -->

<!-- what is acceptable for your use cases. My goal is only to help you evaluate -->

<!-- trade offs as accurately as possible. -->

<p>私のアドバイスを突き詰めると、よく見極めなさい、ということです。
私の書いた文章の中に「決して、Xをしてはならない」とか「Yは有害だと考えよう」といった言葉が現れないのには、れっきとした理由があります。
あるユースケースでこれが容認できるかどうかは、プログラマであるあなたの判断に委ねられます。
私が目指していることは、あなたがトレードオフをできるかぎり正確に評価できるよう、手助けをすることなのです。</p>

<!-- Now that we've covered the basics of error handling in Rust, and -->

<!-- explained unwrapping, let's start exploring more of the standard -->

<!-- library. -->

<p>これでRustにおけるエラーハンドリングの基礎をカバーできました。
また、アンラップについても解説しました。
では標準ライブラリをもっと探索していきましょう。</p>

<!-- # Working with multiple error types -->

<h1 id='複数のエラー型を扱う' class='section-header'><a href='#複数のエラー型を扱う'>複数のエラー型を扱う</a></h1>
<!-- Thus far, we've looked at error handling where everything was either an
<!-- `Option<T>` or a `Result<T, SomeError>`. But what happens when you have both an
<!-- `Option` and a `Result`? Or what if you have a `Result<T, Error1>` and a
<!-- `Result<T, Error2>`? Handling *composition of distinct error types* is the next
<!-- challenge in front of us, and it will be the major theme throughout the rest of
<!-- this section. -->

<p>これまで見てきたエラーハンドリングでは、 <code>Option&lt;T&gt;</code> または <code>Result&lt;T, SomeError&gt;</code> が1つあるだけでした。
ではもし <code>Option</code> と <code>Result</code> の両方があったらどうなるでしょうか？
あるいは、<code>Result&lt;T, Error1&gt;</code> と <code>Result&lt;T, Error2&gt;</code> があったら？
<em>異なるエラー型の組み合わせ</em> を扱うことが、いま目の前にある次なる課題です。
またこれが、このセクションの残りの大半に共通する、主要なテーマとなります。</p>

<!-- ## Composing `Option` and `Result` -->

<h2 id='option-と-result-を合成する' class='section-header'><a href='#option-と-result-を合成する'><code>Option</code> と <code>Result</code> を合成する</a></h2>
<!-- So far, I've talked about combinators defined for `Option` and combinators -->

<!-- defined for `Result`. We can use these combinators to compose results of -->

<!-- different computations without doing explicit case analysis. -->

<p>これまで話してきたのは <code>Option</code> のために定義されたコンビネータと、 <code>Result</code> のために定義されたコンビネータについてでした。
これらのコンビネータを使うと、様々な処理の結果を明示的な場合分けなしに組み合わせることができました。</p>

<!-- Of course, in real code, things aren't always as clean. Sometimes you have a -->

<!-- mix of `Option` and `Result` types. Must we resort to explicit case analysis, -->

<!-- or can we continue using combinators? -->

<p>もちろん現実のコードは、いつもこんなにクリーンではありません。
時には <code>Option</code> 型と <code>Result</code> 型が混在していることもあるでしょう。
そんなときは、明示的な場合分けに頼るしかないのでしょうか？
それとも、コンビネータを使い続けることができるのでしょうか？</p>

<!-- For now, let's revisit one of the first examples in this section: -->

<p>ここで、このセクションの最初の方にあった例に戻ってみましょう：</p>

<span class='rusttest'>use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // エラー1
    let n: i32 = arg.parse().unwrap(); // エラー2
    println!(&quot;{}&quot;, 2 * n);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>argv</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>();
    <span class='kw'>let</span> <span class='ident'>arg</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>argv</span>.<span class='ident'>nth</span>(<span class='number'>1</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// エラー1</span>
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>parse</span>().<span class='ident'>unwrap</span>(); <span class='comment'>// エラー2</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>);
}</pre>

<!-- Given our new found knowledge of `Option`, `Result` and their various -->

<!-- combinators, we should try to rewrite this so that errors are handled properly -->

<!-- and the program doesn't panic if there's an error. -->

<p>これまでに獲得した知識、つまり <code>Option</code> 、<code>Result</code> と、それらのコンビネータに関する知識を動員して、これを書き換えましょう。
エラーを適切に処理し、もしエラーが起こっても、プログラムがパニックしないようにするのです。</p>

<!-- The tricky aspect here is that `argv.nth(1)` produces an `Option` while -->

<!-- `arg.parse()` produces a `Result`. These aren't directly composable. When faced -->

<!-- with both an `Option` and a `Result`, the solution is *usually* to convert the -->

<!-- `Option` to a `Result`. In our case, the absence of a command line parameter -->

<!-- (from `env::args()`) means the user didn't invoke the program correctly. We -->

<!-- could use a `String` to describe the error. Let's try: -->

<p>ここでの問題は <code>argv.nth(1)</code> が <code>Option</code> を返すのに、 <code>arg.parse()</code> は <code>Result</code> を返すことです。
これらを直接合成することはできません。
<code>Option</code> と <code>Result</code> の両方に出会ったときの <em>通常の</em> 解決策は <code>Option</code> を <code>Result</code> に変換することです。
この例で（<code>env::args()</code> が）コマンドライン引数を返さなかったということは、ユーザーがプログラムを正しく起動しなかったことを意味します。
エラーの理由を示すために、 <code>String</code> を使うこともできます。
試してみましょう：</p>

<p><span id="code-error-double-string"></span></p>

<span class='rusttest'>use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or(&quot;Please give at least one argument&quot;.to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>double_arg</span>(<span class='kw-2'>mut</span> <span class='ident'>argv</span>: <span class='ident'>env</span>::<span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='ident'>argv</span>.<span class='ident'>nth</span>(<span class='number'>1</span>)
        .<span class='ident'>ok_or</span>(<span class='string'>&quot;Please give at least one argument&quot;</span>.<span class='ident'>to_owned</span>())
        .<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>arg</span><span class='op'>|</span> <span class='ident'>arg</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>()))
        .<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>double_arg</span>(<span class='ident'>env</span>::<span class='ident'>args</span>()) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>Please give at least one argument：引数を最低1つ指定してください。</p>
</blockquote>

<!-- There are a couple new things in this example. The first is the use of the -->

<!-- [`Option::ok_or`](../std/option/enum.Option.html#method.ok_or) -->

<!-- combinator. This is one way to convert an `Option` into a `Result`. The -->

<!-- conversion requires you to specify what error to use if `Option` is `None`. -->

<!-- Like the other combinators we've seen, its definition is very simple: -->

<p>この例では、いくつか新しいことがあります。
ひとつ目は <a href="../std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a> コンビネータを使ったことです。
これは <code>Option</code> を <code>Result</code> へ変換する方法の一つです。
変換には <code>Option</code> が <code>None</code> のときに使われるエラーを指定する必要があります。
他のコンビネータと同様に、その定義はとてもシンプルです：</p>

<span class='rusttest'>fn main() {
    fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    match option {
        Some(val) =&gt; Ok(val),
        None =&gt; Err(err),
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>ok_or</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>err</span>: <span class='ident'>E</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>),
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    }
}</pre>

<!-- The other new combinator used here is -->

<!-- [`Result::map_err`](../std/result/enum.Result.html#method.map_err). -->

<!-- This is like `Result::map`, except it maps a function on to the *error* -->

<!-- portion of a `Result` value. If the `Result` is an `Ok(...)` value, then it is -->

<!-- returned unmodified. -->

<p>ここで使った、もう一つの新しいコンビネータは <a href="../std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a> です。
これは <code>Result::map</code> に似ていますが、 <code>Result</code> 値の <em>エラー</em> の部分に対して関数をマップするところが異なります。
もし <code>Result</code> の値が <code>Ok(...)</code> だったら、そのまま変更せずに返します。</p>

<!-- We use `map_err` here because it is necessary for the error types to remain -->

<!-- the same (because of our use of `and_then`). Since we chose to convert the -->

<!-- `Option<String>` (from `argv.nth(1)`) to a `Result<String, String>`, we must -->

<!-- also convert the `ParseIntError` from `arg.parse()` to a `String`. -->

<p><code>map_err</code> を使った理由は、（<code>and_then</code> の用法により）エラーの型を同じに保つ必要があったからです。
ここでは（<code>argv.nth(1)</code>が返した） <code>Option&lt;String&gt;</code> を <code>Result&lt;String, String&gt;</code> に変換することを選んだため、<code>arg.parse()</code> が返した <code>ParseIntError</code> も <code>String</code> に変換しなければならなかったわけです。</p>

<!-- ## The limits of combinators -->

<h2 id='コンビネータの限界' class='section-header'><a href='#コンビネータの限界'>コンビネータの限界</a></h2>
<!-- Doing IO and parsing input is a very common task, and it's one that I -->

<!-- personally have done a lot of in Rust. Therefore, we will use (and continue to -->

<!-- use) IO and various parsing routines to exemplify error handling. -->

<p>入出力と共に入力をパースすることは、非常によく行われます。
そして私がRustを使って個人的にやってきたことのほとんども、これに該当しています。
ですから、ここでは（そして、この後も） IOと様々なパースを行うルーチンを、エラーハンドリングの例として扱っていきます。</p>

<!-- Let's start simple. We are tasked with opening a file, reading all of its -->

<!-- contents and converting its contents to a number. Then we multiply it by `2` -->

<!-- and print the output. -->

<p>まずは簡単なものから始めましょう。
ここでのタスクは、ファイルを開き、その内容を全て読み込み、1つの数値に変換することです。
そしてそれに <code>2</code> を掛けて、結果を表示します。</p>

<!-- Although I've tried to convince you not to use `unwrap`, it can be useful -->

<!-- to first write your code using `unwrap`. It allows you to focus on your problem -->

<!-- instead of the error handling, and it exposes the points where proper error -->

<!-- handling need to occur. Let's start there so we can get a handle on the code, -->

<!-- and then refactor it to use better error handling. -->

<p>いままで <code>unwrap</code> を使わないよう説得してきたわけですが、最初にコードを書くときには <code>unwrap</code> が便利に使えます。
こうすることで、エラーハンドリングではなく、本来解決すべき課題に集中できます。
それと同時に <code>unwrap</code> は、適切なエラーハンドリングが必要とされる場所を教えてくれます。
ここから始めることをコーディングへの取っ掛かりとしましょう。
その後、リファクタリングによって、エラーハンドリングを改善していきます。</p>

<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {
    let mut file = File::open(file_path).unwrap(); // エラー1
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap(); // エラー2
    let n: i32 = contents.trim().parse().unwrap(); // エラー3
    2 * n
}

fn main() {
    let doubled = file_double(&quot;foobar&quot;);
    println!(&quot;{}&quot;, doubled);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// エラー1</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// エラー2</span>
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>().<span class='ident'>unwrap</span>(); <span class='comment'>// エラー3</span>
    <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>doubled</span> <span class='op'>=</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>doubled</span>);
}</pre>

<!-- (N.B. The `AsRef<Path>` is used because those are the -->

<!-- [same bounds used on -->

<!-- `std::fs::File::open`](../std/fs/struct.File.html#method.open). -->

<!-- This makes it ergonomic to use any kind of string as a file path.) -->

<p>（備考： <code>AsRef&lt;Path&gt;</code> を使ったのは、<a href="../std/fs/struct.File.html#method.open"><code>std::fs::File::open</code> で使われているものと同じ境界</a> だからです。
ファイルパスとして、どんな文字列でも受け付けるので、エルゴノミックになります。）</p>

<!-- There are three different errors that can occur here: -->

<p>ここでは3種類のエラーが起こる可能性があります：</p>

<!-- 1. A problem opening the file. -->

<!-- 2. A problem reading data from the file. -->

<!-- 3. A problem parsing the data as a number. -->

<ol>
<li>ファイルを開くときの問題</li>
<li>ファイルからデータを読み込むときの問題</li>
<li>データを数値としてパースするときの問題</li>
</ol>

<!-- The first two problems are described via the -->

<!-- [`std::io::Error`](../std/io/struct.Error.html) type. We know this -->

<!-- because of the return types of -->

<!-- [`std::fs::File::open`](../std/fs/struct.File.html#method.open) and -->

<!-- [`std::io::Read::read_to_string`](../std/io/trait.Read.html#method.read_to_string). -->

<!-- (Note that they both use the [`Result` type alias -->

<!-- idiom](#the-result-type-alias-idiom) described previously. If you -->

<!-- click on the `Result` type, you'll [see the type -->

<!-- alias](../std/io/type.Result.html), and consequently, the underlying -->

<!-- `io::Error` type.)  The third problem is described by the -->

<!-- [`std::num::ParseIntError`](../std/num/struct.ParseIntError.html) -->

<!-- type. The `io::Error` type in particular is *pervasive* throughout the -->

<!-- standard library. You will see it again and again. -->

<p>最初の2つの問題は、<a href="../std/io/struct.Error.html"><code>std::io::Error</code></a> 型で記述されます。
これは <a href="../std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> と <a href="../std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a> のリターン型からわかります。
（ちなみにどちらも、以前紹介した <a href="#result-%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0"><code>Result</code> 型エイリアスのイディオム</a> を用いています。
<code>Result</code> 型のところをクリックすると、いま言った <a href="../std/io/type.Result.html">型エイリアスを見たり</a>、必然的に、中で使われている <code>io::Error</code> 型も見ることになるでしょう。）
3番目の問題は <a href="../std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> 型で記述されます。
特にこの <code>io::Error</code> 型は標準ライブラリ全体に <em>深く浸透しています</em> 。
これからこの型を幾度となく見ることでしょう。</p>

<!-- Let's start the process of refactoring the `file_double` function. To make this -->

<!-- function composable with other components of the program, it should *not* panic -->

<!-- if any of the above error conditions are met. Effectively, this means that the -->

<!-- function should *return an error* if any of its operations fail. Our problem is -->

<!-- that the return type of `file_double` is `i32`, which does not give us any -->

<!-- useful way of reporting an error. Thus, we must start by changing the return -->

<!-- type from `i32` to something else. -->

<p>まず最初に <code>file_double</code> 関数をリファクタリングしましょう。
この関数を、このプログラムの他の構成要素と合成可能にするためには、上記の問題のいずれかに遭遇しても、パニック <em>しない</em> ようにしなければなりません。
これは実質的には、なにかの操作に失敗したときに、この関数が <em>エラーを返すべき</em> であることを意味します。
ここでの問題は、<code>file_double</code> のリターン型が <code>i32</code> であるため、エラーの報告には全く役立たないことです。
従ってリターン型を <code>i32</code> から別の何かに変えることから始めましょう。</p>

<!-- The first thing we need to decide: should we use `Option` or `Result`? We -->

<!-- certainly could use `Option` very easily. If any of the three errors occur, we -->

<!-- could simply return `None`. This will work *and it is better than panicking*, -->

<!-- but we can do a lot better. Instead, we should pass some detail about the error -->

<!-- that occurred. Since we want to express the *possibility of error*, we should -->

<!-- use `Result<i32, E>`. But what should `E` be? Since two *different* types of -->

<!-- errors can occur, we need to convert them to a common type. One such type is -->

<!-- `String`. Let's see how that impacts our code: -->

<p>最初に決めるべきことは、 <code>Option</code> と <code>Result</code> のどちらを使うかです。
<code>Option</code> なら間違いなく簡単に使えます。
もし3つのエラーのどれかが起こったら、単に <code>None</code> を返せばいいのですから。
これはたしかに動きますし、 <em>パニックを起こすよりは良くなっています</em> 。
とはいえ、もっと良くすることもできます。
<code>Option</code> の代わりに、発生したエラーについての詳細を渡すべきでしょう。
ここでは <em>エラーの可能性</em> を示したいのですから、<code>Result&lt;i32, E&gt;</code> を使うのがよさそうです。
でも <code>E</code> を何にしたらいいのでしょうか？
2つの <em>異なる</em> 型のエラーが起こり得ますので、これらを共通の型に変換する必要があります。
そのような型の一つに <code>String</code> があります。
この変更がコードにどんな影響を与えるか見てみましょう：</p>

<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>)
         .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>())
         .<span class='ident'>and_then</span>(<span class='op'>|</span><span class='kw-2'>mut</span> <span class='ident'>file</span><span class='op'>|</span> {
              <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
              <span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>)
                  .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>())
                  .<span class='ident'>map</span>(<span class='op'>|</span>_<span class='op'>|</span> <span class='ident'>contents</span>)
         })
         .<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>contents</span><span class='op'>|</span> {
              <span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>()
                      .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>())
         })
         .<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- This code looks a bit hairy. It can take quite a bit of practice before code -->

<!-- like this becomes easy to write. The way we write it is by *following the -->

<!-- types*. As soon as we changed the return type of `file_double` to -->

<!-- `Result<i32, String>`, we had to start looking for the right combinators. In -->

<!-- this case, we only used three different combinators: `and_then`, `map` and -->

<!-- `map_err`. -->

<p>このコードは、やや難解になってきました。
このようなコードを簡単に書けるようになるまでには、結構な量の練習が必要かもしれません。
こういうものを書くときは <em>型に導かれる</em> ようにします。
<code>file_double</code> のリターン型を <code>Result&lt;i32, String&gt;</code> に変更したらすぐに、それに合ったコンビネータを探し始めるのです。
この例では <code>and_then</code>, <code>map</code>, <code>map_err</code> の、3種類のコンビネータだけを使いました。</p>

<!-- `and_then` is used to chain multiple computations where each computation could -->

<!-- return an error. After opening the file, there are two more computations that -->

<!-- could fail: reading from the file and parsing the contents as a number. -->

<!-- Correspondingly, there are two calls to `and_then`. -->

<p><code>and_then</code> は、エラーを返すかもしれない処理同士を繋いでいくために使います。
ファイルを開いた後に、失敗するかもしれない処理が2つあります：
ファイルから読み込む所と、内容を数値としてパースする所です。
これに対応して <code>and_then</code> も2回呼ばれています。</p>

<!-- `map` is used to apply a function to the `Ok(...)` value of a `Result`. For -->

<!-- example, the very last call to `map` multiplies the `Ok(...)` value (which is -->

<!-- an `i32`) by `2`. If an error had occurred before that point, this operation -->

<!-- would have been skipped because of how `map` is defined. -->

<p><code>map</code> は <code>Result</code> の値が <code>Ok(...)</code> のときに関数を適用するために使います。
例えば、一番最後の <code>map</code> の呼び出しは、<code>Ok(...)</code> の値（ <code>i32</code> 型）に <code>2</code> を掛けます。
もし、これより前にエラーが起きたなら、この操作は <code>map</code> の定義に従ってスキップされます。</p>

<!-- `map_err` is the trick that makes all of this work. `map_err` is like -->

<!-- `map`, except it applies a function to the `Err(...)` value of a `Result`. In -->

<!-- this case, we want to convert all of our errors to one type: `String`. Since -->

<!-- both `io::Error` and `num::ParseIntError` implement `ToString`, we can call the -->

<!-- `to_string()` method to convert them. -->

<p><code>map_err</code> は全体をうまく動かすための仕掛けです。
<code>map_err</code> は <code>map</code> に似ていますが、 <code>Result</code> の値が <code>Err(...)</code> のときに関数を適用するところが異なります。
今回の場合は、全てのエラーを <code>String</code> という同一の型に変換する予定でした。
<code>io::Error</code> と <code>num::ParseIntError</code> の両方が <code>ToString</code> を実装していたので、 <code>to_string()</code> メソッドを呼ぶことで変換できました。</p>

<!-- With all of that said, the code is still hairy. Mastering use of combinators is -->

<!-- important, but they have their limits. Let's try a different approach: early -->

<!-- returns. -->

<p>説明し終わった後でも、このコードは難解なままです。
コンビネータの使い方をマスタすることは重要ですが、コンビネータには限界もあるのです。
次は、早期リターンと呼ばれる、別のアプローチを試してみましょう。</p>

<!-- ## Early returns -->

<h2 id='早期リターン' class='section-header'><a href='#早期リターン'>早期リターン</a></h2>
<!-- I'd like to take the code from the previous section and rewrite it using *early -->

<!-- returns*. Early returns let you exit the function early. We can't return early -->

<!-- in `file_double` from inside another closure, so we'll need to revert back to -->

<!-- explicit case analysis. -->

<p>前の節で使ったコードを、 <em>早期リターン</em> を使って書き直してみようと思います。
早期リターンとは、関数の途中で抜けることを指します。
<code>file_double</code> のクロージャの中にいる間は、早期リターンはできないので、明示的な場合分けまでいったん戻る必要があります。</p>

<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>file</span>) <span class='op'>=&gt;</span> <span class='ident'>file</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>.<span class='ident'>to_string</span>()),
    };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=</span> <span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>) {
        <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>.<span class='ident'>to_string</span>());
    }
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='ident'>n</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>.<span class='ident'>to_string</span>()),
    };
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- Reasonable people can disagree over whether this code is better than the code -->

<!-- that uses combinators, but if you aren't familiar with the combinator approach, -->

<!-- this code looks simpler to read to me. It uses explicit case analysis with -->

<!-- `match` and `if let`. If an error occurs, it simply stops executing the -->

<!-- function and returns the error (by converting it to a string). -->

<p>このコードが、コンビネータを使ったコードよりも良くなったのかについては、人によって意見が分かれるでしょう。
でも、もしあなたがコンビネータによるアプローチに不慣れだったら、このコードのほうが読みやすいと思うかもしれません。
ここでは明示的な場合分けを <code>match</code> と <code>if let</code> で行っています。
もしエラーが起きたら関数の実行を打ち切って、エラーを（文字列に変換してから）返します。</p>

<!-- Isn't this a step backwards though? Previously, we said that the key to -->

<!-- ergonomic error handling is reducing explicit case analysis, yet we've reverted -->

<!-- back to explicit case analysis here. It turns out, there are *multiple* ways to -->

<!-- reduce explicit case analysis. Combinators aren't the only way. -->

<p>でもこれって逆戻りしてませんか？
以前は、エラーハンドリングをエルゴノミックにするために、明示的な場合分けを減らすべきだと言っていました。
それなのに、今は明示的な場合分けに戻ってしまっています。
すぐにわかりますが、明示的な場合分けを減らす方法は <em>複数</em> あるのです。
コンビネータが唯一の方法ではありません。</p>

<!-- ## The `try!` macro -->

<h2 id='try-マクロ' class='section-header'><a href='#try-マクロ'><code>try!</code> マクロ</a></h2>
<!-- A cornerstone of error handling in Rust is the `try!` macro. The `try!` macro -->

<!-- abstracts case analysis like combinators, but unlike combinators, it also -->

<!-- abstracts *control flow*. Namely, it can abstract the *early return* pattern -->

<!-- seen above. -->

<p>Rustでのエラー処理の基礎となるのは <code>try!</code> マクロです。
<code>try!</code> マクロはコンビネータと同様、場合分けを抽象化します。
しかし、コンビネータと異なるのは <em>制御フロー</em> も抽象化してくれることです。
つまり、先ほど見た <em>早期リターン</em> のパターンを抽象化できるのです。</p>

<!-- Here is a simplified definition of a `try!` macro: -->

<p><code>try!</code> マクロの簡略化した定義はこうなります：</p>

<p><span id="code-try-def-simple"></span></p>

<span class='rusttest'>fn main() {
    macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>try</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    });
}</pre>

<!-- (The [real definition](../std/macro.try!.html) is a bit more -->

<!-- sophisticated. We will address that later.) -->

<p>（<a href="../std/macro.try!.html">本当の定義</a> はもっと洗練されています。
後ほど紹介します。）</p>

<!-- Using the `try!` macro makes it very easy to simplify our last example. Since -->

<!-- it does the case analysis and the early return for us, we get tighter code that -->

<!-- is easier to read: -->

<p><code>try!</code> マクロを使うと、最後の例をシンプルにすることが、とても簡単にできます。
場合分けと早期リターンを肩代わりしてくれますので、コードが締まって読みやすくなります。</p>

<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- The `map_err` calls are still necessary given -->

<!-- [our definition of `try!`](#code-try-def-simple). -->

<!-- This is because the error types still need to be converted to `String`. -->

<!-- The good news is that we will soon learn how to remove those `map_err` calls! -->

<!-- The bad news is that we will need to learn a bit more about a couple important -->

<!-- traits in the standard library before we can remove the `map_err` calls. -->

<p><a href="#code-try-def-simple">今の私たちの <code>try!</code> の定義</a> ですと、 <code>map_err</code> は今でも必要です。
なぜなら、エラー型を <code>String</code> に変換しなければならないからです。
でも、いい知らせがあります。
<code>map_err</code> の呼び出しを省く方法をすぐに習うのです！
悪い知らせは、<code>map_err</code> を省く前に、標準ライブラリのいくつかの重要なトレイトについて、もう少し学ぶ必要があるということです。</p>

<!-- ## Defining your own error type -->

<h2 id='独自のエラー型を定義する' class='section-header'><a href='#独自のエラー型を定義する'>独自のエラー型を定義する</a></h2>
<!-- Before we dive into some of the standard library error traits, I'd like to wrap -->

<!-- up this section by removing the use of `String` as our error type in the -->

<!-- previous examples. -->

<p>標準ライブラリのいくつかのエラートレイトについて学ぶ前に、これまでの例にあったエラー型における <code>String</code> の使用を取り除くことで、この節を締めくくりたいと思います。</p>

<!-- Using `String` as we did in our previous examples is convenient because it's -->

<!-- easy to convert errors to strings, or even make up your own errors as strings -->

<!-- on the spot. However, using `String` for your errors has some downsides. -->

<p>これまでの例では <code>String</code> を便利に使ってきました。
なぜなら、エラーは簡単に文字列へ変換できますし、問題が起こったその場で、文字列によるエラーを新たに作ることもできるからです。
しかし <code>String</code> を使ってエラーを表すことには欠点もあります。</p>

<!-- The first downside is that the error messages tend to clutter your -->

<!-- code. It's possible to define the error messages elsewhere, but unless -->

<!-- you're unusually disciplined, it is very tempting to embed the error -->

<!-- message into your code. Indeed, we did exactly this in a [previous -->

<!-- example](#code-error-double-string). -->

<p>ひとつ目の欠点は、エラーメッセージがコードのあちこちに散らかる傾向があることです。
エラーメッセージをどこか別の場所でまとめて定義することもできますが、特別に訓練された人でない限りは、エラーメッセージをコードに埋め込むことへの誘惑に負けてしまうでしょう。
実際、私たちは <a href="#code-error-double-string">以前の例</a> でも、その通りのことをしました。</p>

<!-- The second and more important downside is that `String`s are *lossy*. That is, -->

<!-- if all errors are converted to strings, then the errors we pass to the caller -->

<!-- become completely opaque. The only reasonable thing the caller can do with a -->

<!-- `String` error is show it to the user. Certainly, inspecting the string to -->

<!-- determine the type of error is not robust. (Admittedly, this downside is far -->

<!-- more important inside of a library as opposed to, say, an application.) -->

<p>ふたつ目の、もっと重大な欠点は、 <code>String</code> への変換で <em>情報が欠落する</em> ことです。
もし全てのエラーを文字列に変換してしまったら、呼び出し元に渡したエラーが、オペーク（不透明）になってしまいます。
呼び出し元が <code>String</code> のエラーに対してできる唯一妥当なことは、それをユーザーに表示することだけです。
文字列を解析して、どのタイプのエラーだったか判断するのは、もちろん強固なやり方とはいえません。
（この問題は、ライブラリの中の方が、他のアプリケーションのようなものよりも、間違いなく重大なものになるでしょう。）</p>

<!-- For example, the `io::Error` type embeds an -->

<!-- [`io::ErrorKind`](../std/io/enum.ErrorKind.html), -->

<!-- which is *structured data* that represents what went wrong during an IO -->

<!-- operation. This is important because you might want to react differently -->

<!-- depending on the error. (e.g., A `BrokenPipe` error might mean quitting your -->

<!-- program gracefully while a `NotFound` error might mean exiting with an error -->

<!-- code and showing an error to the user.) With `io::ErrorKind`, the caller can -->

<!-- examine the type of an error with case analysis, which is strictly superior -->

<!-- to trying to tease out the details of an error inside of a `String`. -->

<p>例えば <code>io::Error</code> 型には <a href="../std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a> が埋め込まれます。
これは <em>構造化されたデータ</em> で、IO操作において何が失敗したのかを示します。
エラーによって違った対応を取りたいこともあるので、このことは重要です。
（例： あなたのアプリケーションでは <code>BrokenPipe</code> エラーは正規の手順を踏んだ終了を意味し、 <code>NotFound</code> エラーはエラーコードと共に異常終了して、ユーザーにエラーを表示することを意味するかもしれません。）
<code>io::ErrorKind</code> なら、呼び出し元でエラーの種類を調査するために、場合分けが使えます。
これは <code>String</code> の中からエラーの詳細がなんだったのか探りだすことよりも、明らかに優れています。</p>

<!-- Instead of using a `String` as an error type in our previous example of reading -->

<!-- an integer from a file, we can define our own error type that represents errors -->

<!-- with *structured data*. We endeavor to not drop information from underlying -->

<!-- errors in case the caller wants to inspect the details. -->

<p>ファイルから整数値を取り出す例で <code>String</code> をエラー型として用いた代わりに、独自のエラー型を定義し、 <em>構造化されたデータ</em> によってエラー内容を表すことができます。
呼び出し元が詳細を検査したいときに備え、大元のエラーについての情報を取りこぼさないよう、努力してみましょう。</p>

<!-- The ideal way to represent *one of many possibilities* is to define our own -->

<!-- sum type using `enum`. In our case, an error is either an `io::Error` or a -->

<!-- `num::ParseIntError`, so a natural definition arises: -->

<p><em>多くの可能性のうちの一つ</em> を表す理想的な方法は、 <code>enum</code> を使って独自の直和型を定義することです。
このケースでは、エラーは <code>io::Error</code> もしくは <code>num::ParseIntError</code> でした。
ここから思い浮かぶ自然な定義は：</p>

<span class='rusttest'>fn main() {
    use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
// 全ての型は `Debug` を導出するべきでしょうから、ここでも `Debug` を導出します。
// これにより `CliError` 値について、人間が十分理解できる説明を得られます。
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='comment'>// 全ての型は `Debug` を導出するべきでしょうから、ここでも `Debug` を導出します。</span>
<span class='comment'>// これにより `CliError` 値について、人間が十分理解できる説明を得られます。</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Parse</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
}</pre>

<!-- Tweaking our code is very easy. Instead of converting errors to strings, we -->

<!-- simply convert them to our `CliError` type using the corresponding value -->

<!-- constructor: -->

<p>コードの微調整はいとも簡単です。
エラーを文字列に変換する代わりに、エラーに対応する値コンストラクタを用いて <code>CliError</code> 型に変換すればいいのです：</p>

<span class='rusttest'>#[derive(Debug)]
enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>().<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Parse</span>));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {:?}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- The only change here is switching `map_err(|e| e.to_string())` (which converts -->

<!-- errors to strings) to `map_err(CliError::Io)` or `map_err(CliError::Parse)`. -->

<!-- The *caller* gets to decide the level of detail to report to the user. In -->

<!-- effect, using a `String` as an error type removes choices from the caller while -->

<!-- using a custom `enum` error type like `CliError` gives the caller all of the -->

<!-- conveniences as before in addition to *structured data* describing the error. -->

<p>ここでの変更点は、（エラーを文字列に変換する） <code>map_err(|e| e.to_string())</code> を、<code>map_err(CliError::Io)</code> や <code>map_err(CliError::Parse)</code> へ切り替えたことです。
こうして <em>呼び出し元</em> が、ユーザーに対してどの程度の詳細を報告するか決められるようになりました。
<code>String</code> をエラー型として用いることは、事実上、呼び出し元からこうした選択肢を奪ってしまいます。
<code>CliError</code> のような独自の <code>enum</code> エラー型を用いることは、 <em>構造化されたデータ</em> によるエラーの説明だけでなく、これまでと同様の使いやすさをもたらします。</p>

<!-- A rule of thumb is to define your own error type, but a `String` error type -->

<!-- will do in a pinch, particularly if you're writing an application. If you're -->

<!-- writing a library, defining your own error type should be strongly preferred so -->

<!-- that you don't remove choices from the caller unnecessarily. -->

<p>目安となる方法は独自のエラー型を定義することですが、 <code>String</code> エラー型も、いざというときに役立ちます。
特にアプリケーションを書いているときなどはそうです。
もしライブラリを書いているのなら、呼び出し元の選択肢を理由もなく奪わないために、独自のエラー型を定義することを強く推奨します。</p>

<!-- # Standard library traits used for error handling -->

<h1 id='標準ライブラリのトレイトによるエラー処理' class='section-header'><a href='#標準ライブラリのトレイトによるエラー処理'>標準ライブラリのトレイトによるエラー処理</a></h1>
<!-- The standard library defines two integral traits for error handling: -->

<!-- [`std::error::Error`](../std/error/trait.Error.html) and -->

<!-- [`std::convert::From`](../std/convert/trait.From.html). While `Error` -->

<!-- is designed specifically for generically describing errors, the `From` -->

<!-- trait serves a more general role for converting values between two -->

<!-- distinct types. -->

<p>標準ライブラリでは、エラーハンドリングに欠かせないトレイトが、2つ定義されています：
<a href="../std/error/trait.Error.html"><code>std::error::Error</code></a> と <a href="../std/convert/trait.From.html"><code>std::convert::From</code></a> です。
<code>Error</code> はエラーを総称的に説明することを目的に設計されているのに対し、 <code>From</code> トレイトはもっと汎用的な、2つの異なる型の間で値を変換する役割を担います。</p>

<!-- ## The `Error` trait -->

<h2 id='error-トレイト' class='section-header'><a href='#error-トレイト'><code>Error</code> トレイト</a></h2>
<!-- The `Error` trait is [defined in the standard -->

<!-- library](../std/error/trait.Error.html): -->

<p><code>Error</code> トレイトは <a href="../std/error/trait.Error.html">標準ライブラリで定義されています</a> ：</p>

<span class='rusttest'>fn main() {
    use std::fmt::{Debug, Display};

trait Error: Debug + Display {
 /// A short description of the error.
  /// エラーの簡単な説明
  fn description(&amp;self) -&gt; &amp;str;

  /// The lower level cause of this error, if any.
  /// このエラーの一段下のレベルの原因（もしあれば）
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::{<span class='ident'>Debug</span>, <span class='ident'>Display</span>};

<span class='kw'>trait</span> <span class='ident'>Error</span>: <span class='ident'>Debug</span> <span class='op'>+</span> <span class='ident'>Display</span> {
  <span class='doccomment'>/// エラーの簡単な説明</span>
  <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>;

  <span class='doccomment'>/// このエラーの一段下のレベルの原因（もしあれば）</span>
  <span class='kw'>fn</span> <span class='ident'>cause</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>Error</span><span class='op'>&gt;</span> { <span class='prelude-val'>None</span> }
}</pre>

<!-- This trait is super generic because it is meant to be implemented for *all* -->

<!-- types that represent errors. This will prove useful for writing composable code -->

<!-- as we'll see later. Otherwise, the trait allows you to do at least the -->

<!-- following things: -->

<p>このトレイトは極めて一般的です。
なぜなら、エラーを表す <em>全て</em> の型で実装されることを目的としているからです。
この後すぐ見るように、このことは合成可能なコードを書くのに間違いなく役立ちます。
それ以外にも、このトレイトでは最低でも以下のようなことができます：</p>

<!-- * Obtain a `Debug` representation of the error. -->

<!-- * Obtain a user-facing `Display` representation of the error. -->

<!-- * Obtain a short description of the error (via the `description` method). -->

<!-- * Inspect the causal chain of an error, if one exists (via the `cause` method). -->

<ul>
<li>エラーの <code>Debug</code> 表現を取得する。</li>
<li>エラーのユーザー向け <code>Display</code> 表現を取得する。</li>
<li>エラーの簡単な説明を取得する（<code>description</code> メソッド経由）。</li>
<li>エラーの因果関係のチェーンが提供されているなら、それを調べる（<code>cause</code> メソッド経由）。</li>
</ul>

<!-- The first two are a result of `Error` requiring impls for both `Debug` and -->

<!-- `Display`. The latter two are from the two methods defined on `Error`. The -->

<!-- power of `Error` comes from the fact that all error types impl `Error`, which -->

<!-- means errors can be existentially quantified as a -->

<!-- [trait object](../book/trait-objects.html). -->

<!-- This manifests as either `Box<Error>` or `&Error`. Indeed, the `cause` method -->

<!-- returns an `&Error`, which is itself a trait object. We'll revisit the -->

<!-- `Error` trait's utility as a trait object later. -->

<p>最初の2つは <code>Error</code> が <code>Debug</code> と <code>Display</code> の実装を必要としていることに由来します。
残りの2つは <code>Error</code> が定義している2つのメソッドに由来します。
<code>Error</code> の強力さは、実際に全てのエラー型が <code>Error</code> を実装していることから来ています。
このことは、全てのエラーを1つの <a href="../book/trait-objects.html">トレイトオブジェクト</a> として存在量化(existentially quantify) できることを意味します。
これは <code>Box&lt;Error&gt;</code> または <code>&amp;Error</code> と書くことで表明できます。
実際に <code>cause</code> メソッドは <code>&amp;Error</code> を返し、これ自体はトレイトオブジェクトです。
<code>Error</code> トレイトのトレイトオブジェクトとしての用例については、後ほど再び取りあげます。</p>

<!-- For now, it suffices to show an example implementing the `Error` trait. Let's -->

<!-- use the error type we defined in the -->

<!-- [previous section](#defining-your-own-error-type): -->

<p><code>Error</code> トレイトの実装例を見せるには、いまはこのくらいで十分でしょう。
<a href="#%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">前の節</a> で定義したエラー型を使ってみましょう：</p>

<span class='rusttest'>fn main() {
    use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
// 全ての型は `Debug` を導出するべきでしょうから、ここでも `Debug` を導出します。
// これにより `CliError` 値について、人間が十分理解できる説明を得られます。
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='comment'>// 全ての型は `Debug` を導出するべきでしょうから、ここでも `Debug` を導出します。</span>
<span class='comment'>// これにより `CliError` 値について、人間が十分理解できる説明を得られます。</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Parse</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
}</pre>

<!-- This particular error type represents the possibility of two types of errors -->

<!-- occurring: an error dealing with I/O or an error converting a string to a -->

<!-- number. The error could represent as many error types as you want by adding new -->

<!-- variants to the `enum` definition. -->

<p>このエラー型は2種類のエラー、つまり、IOを扱っているときのエラー、または、文字列を数値に変換するときのエラーが起こる可能性を示しています。
<code>enum</code> 定義のヴァリアントを増やせば、エラーの種類をいくらでも表現できます。</p>

<!-- Implementing `Error` is pretty straight-forward. It's mostly going to be a lot -->

<!-- explicit case analysis. -->

<p><code>Error</code> を実装するのは実に単純な作業です。
大抵は明示的な場合分けの繰り返しになります。</p>

<span class='rusttest'>fn main() {
    use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
          // Both underlying errors already impl `Display`, so we defer to
          // their implementations.
            // 下層のエラーは両方ともすでに `Display` を実装しているので、
            // それらの実装に従います。
            CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),
            CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),
        }
    }
}

impl error::Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
      // Both underlying errors already impl `Error`, so we defer to their
      // implementations.
        // 下層のエラーは両方ともすでに `Error` を実装しているので、
        // それらの実装に従います。
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Parse(ref err) =&gt; err.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
          // N.B. Both of these implicitly cast `err` from their concrete
          // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)
          // to a trait object `&amp;Error`. This works because both error types
          // implement `Error`.
            // 注意：これらは両方とも `err` を、その具象型（`&amp;io::Error` か
            // `&amp;num::ParseIntError` のいずれか）から、トレイトオブジェクト
            // `&amp;Error` へ暗黙的にキャストします。どちらのエラー型も `Error` を
            // 実装しているので、問題なく動きます。
            CliError::Io(ref err) =&gt; Some(err),
            CliError::Parse(ref err) =&gt; Some(err),
        }
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;

<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='comment'>// 下層のエラーは両方ともすでに `Display` を実装しているので、</span>
            <span class='comment'>// それらの実装に従います。</span>
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;IO error: {}&quot;</span>, <span class='ident'>err</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;Parse error: {}&quot;</span>, <span class='ident'>err</span>),
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>error</span>::<span class='ident'>Error</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> {
        <span class='comment'>// 下層のエラーは両方ともすでに `Error` を実装しているので、</span>
        <span class='comment'>// それらの実装に従います。</span>
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>cause</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>error</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='comment'>// 注意：これらは両方とも `err` を、その具象型（`&amp;io::Error` か</span>
            <span class='comment'>// `&amp;num::ParseIntError` のいずれか）から、トレイトオブジェクト</span>
            <span class='comment'>// `&amp;Error` へ暗黙的にキャストします。どちらのエラー型も `Error` を</span>
            <span class='comment'>// 実装しているので、問題なく動きます。</span>
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>err</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>err</span>),
        }
    }
}</pre>

<!-- We note that this is a very typical implementation of `Error`: match on your -->

<!-- different error types and satisfy the contracts defined for `description` and -->

<!-- `cause`. -->

<p>これは極めて典型的な <code>Error</code> の実装だということに留意してください。
このように、それぞれのエラー型にマッチさせて、<code>description</code> と <code>cause</code> のコントラクトを満たします。</p>

<!-- ## The `From` trait -->

<h2 id='from-トレイト' class='section-header'><a href='#from-トレイト'><code>From</code> トレイト</a></h2>
<!-- The `std::convert::From` trait is -->

<!-- [defined in the standard -->

<!-- library](../std/convert/trait.From.html): -->

<p><code>std::convert::From</code> は <a href="../std/convert/trait.From.html">標準ライブラリで定義されています</a> ：</p>

<p><span id="code-from-def"></span></p>

<span class='rusttest'>fn main() {
    trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='self'>Self</span>;
}</pre>

<!-- Deliciously simple, yes? `From` is very useful because it gives us a generic -->

<!-- way to talk about conversion *from* a particular type `T` to some other type -->

<!-- (in this case, “some other type” is the subject of the impl, or `Self`). -->

<!-- The crux of `From` is the -->

<!-- [set of implementations provided by the standard -->

<!-- library](../std/convert/trait.From.html). -->

<p>嬉しいくらい簡単でしょ？
<code>From</code> は、ある特定の <code>T</code> という型 <em>から</em> 、別の型へ変換するための汎用的な方法を提供するので大変便利です
（この場合の「別の型」とは実装の主体、つまり <code>Self</code> です）。
<code>From</code> を支えているのは <a href="../std/convert/trait.From.html">標準ライブラリで提供される一連の実装です</a>。</p>

<!-- Here are a few simple examples demonstrating how `From` works: -->

<p><code>From</code> がどのように動くか、いくつかの例を使って紹介しましょう：</p>

<span class='rusttest'>fn main() {
    let string: String = From::from(&quot;foo&quot;);
let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);
let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>string</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='kw'>let</span> <span class='ident'>bytes</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='kw'>let</span> <span class='ident'>cow</span>: ::<span class='ident'>std</span>::<span class='ident'>borrow</span>::<span class='ident'>Cow</span><span class='op'>&lt;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);</pre>

<!-- OK, so `From` is useful for converting between strings. But what about errors? -->

<!-- It turns out, there is one critical impl: -->

<p>たしかに <code>From</code> が文字列を変換するのに便利なことはわかりました。
でもエラーについてはどうでしょうか？
結論から言うと、これが重要な実装です：</p>

<span class='rusttest'>fn main() {
    impl&lt;&#39;a, E: Error + &#39;a&gt; From&lt;E&gt; for Box&lt;Error + &#39;a&gt;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>E</span>: <span class='ident'>Error</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>E</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span></pre>

<!-- This impl says that for *any* type that impls `Error`, we can convert it to a -->

<!-- trait object `Box<Error>`. This may not seem terribly surprising, but it is -->

<!-- useful in a generic context. -->

<p>この実装では、 <code>Error</code> を実装した <em>全て</em> の型は、トレイトオブジェクト <code>Box&lt;Error&gt;</code> に変換できると言っています。
これは、驚きに値するものには見えないかもしれませんが、一般的なコンテキストで有用なのです。</p>

<!-- Remember the two errors we were dealing with previously? Specifically, -->

<!-- `io::Error` and `num::ParseIntError`. Since both impl `Error`, they work with -->

<!-- `From`: -->

<p>さっき扱った2つのエラーを覚えてますか？
具体的には <code>io::Error</code> と <code>num::ParseIntError</code> でした。
どちらも <code>Error</code> を実装していますので <code>From</code> で動きます。</p>

<span class='rusttest'>fn main() {
    use std::error::Error;
use std::fs;
use std::io;
use std::num;

// We have to jump through some hoops to actually get error values.
// エラーの値にたどり着くまで、何段階かのステップが必要です。
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();

// OK, here are the conversions.
// では、こちらで変換します。
let err1: Box&lt;Error&gt; = From::from(io_err);
let err2: Box&lt;Error&gt; = From::from(parse_err);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>::<span class='ident'>Error</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='comment'>// エラーの値にたどり着くまで、何段階かのステップが必要です。</span>
<span class='kw'>let</span> <span class='ident'>io_err</span>: <span class='ident'>io</span>::<span class='ident'>Error</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>Error</span>::<span class='ident'>last_os_error</span>();
<span class='kw'>let</span> <span class='ident'>parse_err</span>: <span class='ident'>num</span>::<span class='ident'>ParseIntError</span> <span class='op'>=</span> <span class='string'>&quot;not a number&quot;</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>unwrap_err</span>();

<span class='comment'>// では、こちらで変換します。</span>
<span class='kw'>let</span> <span class='ident'>err1</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='ident'>io_err</span>);
<span class='kw'>let</span> <span class='ident'>err2</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='ident'>parse_err</span>);</pre>

<!-- There is a really important pattern to recognize here. Both `err1` and `err2` -->

<!-- have the *same type*. This is because they are existentially quantified types, -->

<!-- or trait objects. In particular, their underlying type is *erased* from the -->

<!-- compiler's knowledge, so it truly sees `err1` and `err2` as exactly the same. -->

<!-- Additionally, we constructed `err1` and `err2` using precisely the same -->

<!-- function call: `From::from`. This is because `From::from` is overloaded on both -->

<!-- its argument and its return type. -->

<p>ここに気づくべき、本当に重要なパターンがあります。
<code>err1</code> と <code>err2</code> の両方ともが <em>同じ型</em> になっているのです。
なぜなら、それらが存在量化型、つまり、トレイトオブジェクトだからです。
特にそれらの背後の型は、コンパイラの知識から <em>消去されます</em> ので、 <code>err1</code> と <code>err2</code> が本当に同じに見えるのです。
さらに私たちは同じ関数呼び出し <code>From::from</code> を使って <code>err1</code> と <code>err2</code> をコンストラクトしました。
これは <code>From::from</code> が引数とリターン型の両方でオーバーロードされているからです。</p>

<!-- This pattern is important because it solves a problem we had earlier: it gives -->

<!-- us a way to reliably convert errors to the same type using the same function. -->

<p>このパターンは重要です。
なぜなら、私たちが前から抱えていた問題を解決するからです：
同じ関数を使って、エラーを同一の型に変換する、確かな方法を提供するからです。</p>

<!-- Time to revisit an old friend; the `try!` macro. -->

<p>いよいよ、私たちの旧友 <code>try!</code> マクロを再訪するときが訪れました。</p>

<!-- ## The real `try!` macro -->

<h2 id='本当の-try-マクロ' class='section-header'><a href='#本当の-try-マクロ'>本当の <code>try!</code> マクロ</a></h2>
<!-- Previously, we presented this definition of `try!`: -->

<p><code>try!</code> の定義は、以前このように提示されました：</p>

<span class='rusttest'>fn main() {
    macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>try</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    });
}</pre>

<!-- This is not its real definition. Its real definition is -->

<!-- [in the standard library](../std/macro.try!.html): -->

<p>これは本当の定義ではありません。
本当の定義は <a href="../std/macro.try!.html">標準ライブラリの中にあります</a>：</p>

<p><span id="code-try-def"></span></p>

<span class='rusttest'>fn main() {
    macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(::std::convert::From::from(err)),
    });
}
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>try</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(::<span class='ident'>std</span>::<span class='ident'>convert</span>::<span class='ident'>From</span>::<span class='ident'>from</span>(<span class='ident'>err</span>)),
    });
}</pre>

<!-- There's one tiny but powerful change: the error value is passed through -->

<!-- `From::from`. This makes the `try!` macro a lot more powerful because it gives -->

<!-- you automatic type conversion for free. -->

<p>文面上はわずかですが、非常に大きな違いがあります：
エラーの値は <code>From::from</code> を経て渡されるのです。
これにより <code>try!</code> マクロは、はるかに強力になります。
なぜなら、自動的な型変換をただで手に入れられるのですから。</p>

<!-- Armed with our more powerful `try!` macro, let's take a look at code we wrote -->

<!-- previously to read a file and convert its contents to an integer: -->

<p>強力になった <code>try!</code> マクロを手に入れたので、以前書いた、ファイルを読み込んで内容を整数値に変換するコードを見直してみましょう：</p>

<span class='rusttest'>fn main() {
    use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<!-- Earlier, we promised that we could get rid of the `map_err` calls. Indeed, all -->

<!-- we have to do is pick a type that `From` works with. As we saw in the previous -->

<!-- section, `From` has an impl that lets it convert any error type into a -->

<!-- `Box<Error>`: -->

<p>以前 <code>map_err</code> の呼び出しを取り除くことができると約束しました。
もちろんです。ここでしなければいけないのは <code>From</code> と共に動く型を一つ選ぶだけでよいのです。
前の節で見たように <code>From</code> の実装の一つは、どんなエラー型でも <code>Box&lt;Error&gt;</code> に変換できます：</p>

<span class='rusttest'>fn main() {
    use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n = try!(contents.trim().parse::&lt;i32&gt;());
    Ok(2 * n)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>::<span class='ident'>Error</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>));
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>());
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<!-- We are getting very close to ideal error handling. Our code has very little -->

<!-- overhead as a result from error handling because the `try!` macro encapsulates -->

<!-- three things simultaneously: -->

<p>理想的なエラーハンドリングまで、あと一歩です。
私たちのコードには、エラーハンドリングを終えた後も、ごくわずかなオーバーヘッドしかありません。
これは <code>try!</code> マクロが同時に3つのことをカプセル化するからです：</p>

<!-- 1. Case analysis. -->

<!-- 2. Control flow. -->

<!-- 3. Eraror type conversion. -->

<ol>
<li>場合分け</li>
<li>制御フロー</li>
<li>エラー型の変換</li>
</ol>

<!-- When all three things are combined, we get code that is unencumbered by -->

<!-- combinators, calls to `unwrap` or case analysis. -->

<p>これら3つが一つになったとき、コンビネータ、 <code>unwrap</code> の呼び出し、場合分けなどの邪魔者を排除したコードが得られるのです。</p>

<!-- There's one little nit left: the `Box<Error>` type is *opaque*. If we -->

<!-- return a `Box<Error>` to the caller, the caller can't (easily) inspect -->

<!-- underlying error type. The situation is certainly better than `String` -->

<!-- because the caller can call methods like -->

<!-- [`description`](../std/error/trait.Error.html#tymethod.description) -->

<!-- and [`cause`](../std/error/trait.Error.html#method.cause), but the -->

<!-- limitation remains: `Box<Error>` is opaque. (N.B. This isn't entirely -->

<!-- true because Rust does have runtime reflection, which is useful in -->

<!-- some scenarios that are [beyond the scope of this -->

<!-- section](https://crates.io/crates/error).) -->

<p>あとひとつ、些細なことが残っています：
<code>Box&lt;Error&gt;</code> 型は <em>オペーク</em> なのです。
もし <code>Box&lt;Error&gt;</code> を呼び出し元に返すと、呼び出し元では背後のエラー型が何であるかを、（簡単には）調べられません。
この状況は <code>String</code> を返すよりは明らかに改善されてます。
なぜなら、呼び出し元では <a href="../std/error/trait.Error.html#tymethod.description"><code>description</code></a> や <a href="../std/error/trait.Error.html#method.cause"><code>cause</code></a> といったメソッドを呼ぶこともできるからです。
しかし <code>Box&lt;Error&gt;</code> が不透明であるという制限は残ります。
（注意：これは完全な真実ではありません。
なぜならRustでは実行時のリフレクションができるからです。
この方法が有効なシナリオもありますが、<a href="https://crates.io/crates/error">このセクションで扱う範囲を超えています</a> ）</p>

<!-- It's time to revisit our custom `CliError` type and tie everything together. -->

<p>では、私たちの独自のエラー型 <code>CliError</code> に戻って、全てを一つにまとめ上げましょう。</p>

<!-- ## Composing custom error types -->

<h2 id='独自のエラー型を合成する' class='section-header'><a href='#独自のエラー型を合成する'>独自のエラー型を合成する</a></h2>
<!-- In the last section, we looked at the real `try!` macro and how it does -->

<!-- automatic type conversion for us by calling `From::from` on the error value. -->

<!-- In particular, we converted errors to `Box<Error>`, which works, but the type -->

<!-- is opaque to callers. -->

<p>前の節では <code>try!</code> マクロの本当の定義を確認し、それが <code>From::from</code> をエラーの値に対して呼ぶことで、自動的な型変換をする様子を見ました。
特にそこでは、エラーを <code>Box&lt;Error&gt;</code> に変換しました。
これはたしかに動きますが、呼び出し元にとって、型がオペークになってしまいました。</p>

<!-- To fix this, we use the same remedy that we're already familiar with: a custom -->

<!-- error type. Once again, here is the code that reads the contents of a file and -->

<!-- converts it to an integer: -->

<p>これを直すために、すでによく知っている改善方法である独自のエラー型を使いましょう。
もう一度、ファイルの内容を読み込んで整数値に変換するコードです：</p>

<span class='rusttest'>fn main() {
    use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
// 全ての型は `Debug` を導出するべきでしょうから、ここでも `Debug` を導出します。
// これにより `CliError` 値について、人間が十分理解できる説明を得られます。
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='self'>self</span>, <span class='ident'>Read</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='comment'>// 全ての型は `Debug` を導出するべきでしょうから、ここでも `Debug` を導出します。</span>
<span class='comment'>// これにより `CliError` 値について、人間が十分理解できる説明を得られます。</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Parse</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
}

<span class='kw'>fn</span> <span class='ident'>file_double_verbose</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>().<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Parse</span>));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<!-- Notice that we still have the calls to `map_err`. Why? Well, recall the -->

<!-- definitions of [`try!`](#code-try-def) and [`From`](#code-from-def). The -->

<!-- problem is that there is no `From` impl that allows us to convert from error -->

<!-- types like `io::Error` and `num::ParseIntError` to our own custom `CliError`. -->

<!-- Of course, it is easy to fix this! Since we defined `CliError`, we can impl -->

<!-- `From` with it: -->

<p><code>map_err</code> がまだあることに注目してください。
なぜって、 <a href="#code-try-def"><code>try!</code></a> と <a href="#code-from-def"><code>From</code></a> の定義を思い出してください。
ここでの問題は <code>io::Error</code> や <code>num::ParseIntError</code> といったエラー型を、私たち独自の <code>CliError</code> に変換できる <code>From</code> の実装が無いことです。
もちろん、これは簡単に直せます！
<code>CliError</code> を定義したわけですから、それに対して <code>From</code> を実装できます：</p>

<span class='rusttest'>fn main() {
    #[derive(Debug)]
enum CliError { Io(io::Error), Parse(num::ParseIntError) }
use std::io;
use std::num;

impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>io</span>::<span class='ident'>Error</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='ident'>err</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>num</span>::<span class='ident'>ParseIntError</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>num</span>::<span class='ident'>ParseIntError</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='ident'>err</span>)
    }
}</pre>

<!-- All these impls are doing is teaching `From` how to create a `CliError` from -->

<!-- other error types. In our case, construction is as simple as invoking the -->

<!-- corresponding value constructor. Indeed, it is *typically* this easy. -->

<p>これらの実装がしていることは、<code>From</code> に対して、どうやって他のエラー型を元に <code>CliError</code> を作るのか、教えてあげているだけです。
このケースでは、単に対応する値コンストラクタを呼ぶことで構築しています。
本当に <em>普通は</em> これくらい簡単にできてしまいます。</p>

<!-- We can finally rewrite `file_double`: -->

<p>これでようやく <code>file_double</code> を書き直せます：</p>

<span class='rusttest'>fn main() {
    use std::io;
use std::num;
enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }
}
impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
}

use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
}</span><pre class='rust rust-example-rendered'>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>));
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>());
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<!-- The only thing we did here was remove the calls to `map_err`. They are no -->

<!-- longer needed because the `try!` macro invokes `From::from` on the error value. -->

<!-- This works because we've provided `From` impls for all the error types that -->

<!-- could appear. -->

<p>ここでしたのは <code>map_err</code> を取り除くことだけです。
それらは <code>try!</code> マクロがエラーの値に対して <code>From::from</code> を呼ぶので、もう不要になりました。
これで動くのは、起こりうる全てのエラー型に対して <code>From</code> の実装を提供したからです。</p>

<!-- If we modified our `file_double` function to perform some other operation, say, -->

<!-- convert a string to a float, then we'd need to add a new variant to our error -->

<!-- type: -->

<p>もし <code>file_double</code> 関数を変更して、なにか他の操作、例えば、文字列を浮動小数点数に変換させたいと思ったら、エラー型のヴァリアントを追加するだけです：</p>

<span class='rusttest'>fn main() {
    use std::io;
use std::num;

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>ParseInt</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
    <span class='ident'>ParseFloat</span>(<span class='ident'>num</span>::<span class='ident'>ParseFloatError</span>),
}</pre>

<!-- And add a new `From` impl: -->

<p>そして、新しい <code>From</code> 実装を追加します：</p>

<span class='rusttest'>fn main() {
    enum CliError {
    Io(::std::io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}

use std::num;

impl From&lt;num::ParseFloatError&gt; for CliError {
    fn from(err: num::ParseFloatError) -&gt; CliError {
        CliError::ParseFloat(err)
    }
}
}</span><pre class='rust rust-example-rendered'>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>num</span>::<span class='ident'>ParseFloatError</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>num</span>::<span class='ident'>ParseFloatError</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>ParseFloat</span>(<span class='ident'>err</span>)
    }
}</pre>

<!-- And that's it! -->

<p>これで完成です！</p>

<!-- ## Advice for library writers -->

<h2 id='ライブラリ作者たちへのアドバイス' class='section-header'><a href='#ライブラリ作者たちへのアドバイス'>ライブラリ作者たちへのアドバイス</a></h2>
<!-- If your library needs to report custom errors, then you should -->

<!-- probably define your own error type. It's up to you whether or not to -->

<!-- expose its representation (like -->

<!-- [`ErrorKind`](../std/io/enum.ErrorKind.html)) or keep it hidden (like -->

<!-- [`ParseIntError`](../std/num/struct.ParseIntError.html)). Regardless -->

<!-- of how you do it, it's usually good practice to at least provide some -->

<!-- information about the error beyond its `String` -->

<!-- representation. But certainly, this will vary depending on use cases. -->

<p>もし、あなたのライブラリがカスタマイズされたエラーを報告しなければならないなら、恐らく、独自のエラー型を定義するべきでしょう。
エラーの表現を表にさらすか（例： <a href="../std/io/enum.ErrorKind.html"><code>ErrorKind</code></a> ） 、隠しておくか（例： <a href="../std/num/struct.ParseIntError.html"><code>ParseIntError</code></a> ）は、あなたの自由です。
いずれかに関係なく、最低でも <code>String</code> による表現を超えたエラー情報を提供することが、ほとんどの場合、良い方法となるしょう。
しかしこれは紛れもなく、ユースケースに深く依存します。</p>

<!-- At a minimum, you should probably implement the -->

<!-- [`Error`](../std/error/trait.Error.html) -->

<!-- trait. This will give users of your library some minimum flexibility for -->

<!-- [composing errors](#the-real-try-macro). Implementing the `Error` trait also -->

<!-- means that users are guaranteed the ability to obtain a string representation -->

<!-- of an error (because it requires impls for both `fmt::Debug` and -->

<!-- `fmt::Display`). -->

<p>最低でも <a href="../std/error/trait.Error.html"><code>Error</code></a> トレイトを実装するべきでしょう。
これにより、ライブラリの利用者に <a href="#%E6%9C%AC%E5%BD%93%E3%81%AE-try-%E3%83%9E%E3%82%AF%E3%83%AD">エラーを合成する</a> ための、最低ラインの柔軟性を与えます。
<code>Error</code> トレイトを実装することは、利用者がエラーの文字列表現を取得できると保証することにもなります（なぜなら、こうすると <code>fmt::Debug</code> と <code>fmt::Display</code> の実装が必須になるからです）。</p>

<!-- Beyond that, it can also be useful to provide implementations of `From` on your -->

<!-- error types. This allows you (the library author) and your users to -->

<!-- [compose more detailed errors](#composing-custom-error-types). For example, -->

<!-- [`csv::Error`](http://burntsushi.net/rustdoc/csv/enum.Error.html) -->

<!-- provides `From` impls for both `io::Error` and `byteorder::Error`. -->

<p>さらには、あなたのエラー型に対して <code>From</code> の実装を提供するのも便利かもしれません。
このことは、（ライブラリ作者である）あなたと利用者が、 <a href="#%E7%8B%AC%E8%87%AA%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E5%9E%8B%E3%82%92%E5%90%88%E6%88%90%E3%81%99%E3%82%8B">より詳細なエラーを合成する</a> ことを可能にします。
例えば <a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a> は <code>io::Error</code> と <code>byteorder::Error</code> の両方に <code>From</code> 実装を提供しています。</p>

<!-- Finally, depending on your tastes, you may also want to define a -->

<!-- [`Result` type alias](#the-result-type-alias-idiom), particularly if your -->

<!-- library defines a single error type. This is used in the standard library -->

<!-- for [`io::Result`](../std/io/type.Result.html) -->

<!-- and [`fmt::Result`](../std/fmt/type.Result.html). -->

<p>最後に、お好みで <a href="#result-%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0"><code>Result</code> 型エイリアス</a> を定義したくなるかもしれません。
特にライブラリでエラー型を一つだけ定義しているときは当てはまります。
この方法は標準ライブラリの <a href="../std/io/type.Result.html"><code>io::Result</code></a> や <a href="../std/fmt/type.Result.html"><code>fmt::Result</code></a> で用いられています。</p>

<!-- # Case study: A program to read population data -->

<h1 id='ケーススタディ人口データを読み込むプログラム' class='section-header'><a href='#ケーススタディ人口データを読み込むプログラム'>ケーススタディ：人口データを読み込むプログラム</a></h1>
<!-- This section was long, and depending on your background, it might be -->

<!-- rather dense. While there is plenty of example code to go along with -->

<!-- the prose, most of it was specifically designed to be pedagogical. So, -->

<!-- we're going to do something new: a case study. -->

<p>このセクションは長かったですね。
あなたのバックグラウンドにもよりますが、内容が少し濃すぎたかもしれません。
たくさんのコード例に、散文的な説明が添えられる形で進行しましたが、これは主に学習を助けるために、あえてこう構成されていたのでした。
次はなにか新しいことをしましょう。ケーススタディです。</p>

<!-- For this, we're going to build up a command line program that lets you -->

<!-- query world population data. The objective is simple: you give it a location -->

<!-- and it will tell you the population. Despite the simplicity, there is a lot -->

<!-- that can go wrong! -->

<p>ここでは世界の人口データを問い合わせるための、コマンドラインプログラムを構築します。
目標はシンプルです：プログラムに場所を与えると、人口を教えてくれます。
シンプルにも関わらず、失敗しそうな所がたくさんあります！</p>

<!-- The data we'll be using comes from the [Data Science -->

<!-- Toolkit][11]. I've prepared some data from it for this exercise. You -->

<!-- can either grab the [world population data][12] (41MB gzip compressed, -->

<!-- 145MB uncompressed) or only the [US population data][13] (2.2MB gzip -->

<!-- compressed, 7.2MB uncompressed). -->

<p>ここで使うデータは <a href="https://github.com/petewarden/dstkdata">データサイエンスツールキット</a> から取得したものです。
これを元に演習で使うデータを準備しましたので、2つのファイルのどちらかをダウンロードしてください：
<a href="http://burntsushi.net/stuff/worldcitiespop.csv.gz">世界の人口データ</a> （gzip圧縮時 41MB、解凍時 145MB）と、 <a href="http://burntsushi.net/stuff/uscitiespop.csv.gz">アメリカ合衆国の人口データ</a> （gzip 圧縮時 2.2MB、解凍時 7.2MB）があります。</p>

<!-- Up until now, we've kept the code limited to Rust's standard library. For a real -->

<!-- task like this though, we'll want to at least use something to parse CSV data, -->

<!-- parse the program arguments and decode that stuff into Rust types automatically. For that, we'll use the -->

<!-- [`csv`](https://crates.io/crates/csv), -->

<!-- and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates. -->

<p>いままで書いてきたコードでは、Rustの標準ライブラリだけを使うようにしてきました。
今回のような現実のタスクでは、最低でもCSVデータをパースする部分と、プログラムの引数をパースして、自動的にRustの型にデコードする部分に何か使いたいでしょう。
これには <a href="https://crates.io/crates/csv"><code>csv</code></a> と <a href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> クレートを使います。</p>

<!-- ## Initial setup -->

<h2 id='最初のセットアップ' class='section-header'><a href='#最初のセットアップ'>最初のセットアップ</a></h2>
<!-- We're not going to spend a lot of time on setting up a project with -->

<!-- Cargo because it is already covered well in [the Cargo -->

<!-- section](getting-started.html#hello-cargo) and [Cargo's documentation][14]. -->

<!-- 訳者コメント：hello-cargo.htmlがリンク切れのため、リンク先を変更しました。 -->

<p>Cargoを使ってプロジェクトをセットアップしますが、その方法はすでに <a href="getting-started.html#hello-cargo">Hello, Cargo!</a> と <a href="http://doc.crates.io/guide.html">Cargoのドキュメント</a> でカバーされていますので、ここでは簡単に説明します。</p>

<!-- To get started from scratch, run `cargo new --bin city-pop` and make sure your -->

<!-- `Cargo.toml` looks something like this: -->

<p>何もない状態から始めるには、<code>cargo new --bin city-pop</code> を実行し、 <code>Cargo.toml</code> を以下のように編集します：</p>

<pre><code class="language-text">[package]
name = &quot;city-pop&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]

[[bin]]
name = &quot;city-pop&quot;

[dependencies]
csv = &quot;0.*&quot;
rustc-serialize = &quot;0.*&quot;
getopts = &quot;0.*&quot;
</code></pre>

<!-- You should already be able to run: -->

<p>これでもう実行できるはずです：</p>

<pre><code class="language-text">cargo build --release
./target/release/city-pop
# 出力: Hello, world!
</code></pre>

<!-- Outputs: Hello, world! -->

<!-- ## Argument parsing -->

<h2 id='引数のパース' class='section-header'><a href='#引数のパース'>引数のパース</a></h2>
<!-- Let's get argument parsing out of the way. We won't go into too much -->

<!-- detail on Getopts, but there is [some good documentation][15] -->

<!-- describing it. The short story is that Getopts generates an argument -->

<!-- parser and a help message from a vector of options (The fact that it -->

<!-- is a vector is hidden behind a struct and a set of methods). Once the -->

<!-- parsing is done, we can decode the program arguments into a Rust -->

<!-- struct. From there, we can get information about the flags, for -->

<!-- instance, whether they were passed in, and what arguments they -->

<!-- had. Here's our program with the appropriate `extern crate` -->

<!-- statements, and the basic argument setup for Getopts: -->

<p>引数のパースができるようにしましょう。
Getoptsについては、あまり深く説明しませんが、詳細を解説した <a href="http://doc.rust-lang.org/getopts/getopts/index.html">ドキュメント</a> があります。
簡単に言うと、Getoptsはオプションのベクタから、引数のパーサーとヘルプメッセージを生成します（実際には、ベクタは構造体とメソッドの背後に隠れています）。
パースが終わると、プログラムの引数をRustの構造体へとデコードできます。
そこから、例えば、フラグが指定されたかとか、フラグの引数がなんであったかといった、フラグの情報を取り出せるようになります。
プログラムに適切な <code>extern crate</code> 文を追加して、Getoptsの基本的な引数を設定すると、こうなります：</p>

<span class='rusttest'>extern crate getopts;
extern crate rustc_serialize;

use getopts::Options;
use std::env;

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = &amp;args[0];

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }
    let data_path = &amp;args[1];
    let city = &amp;args[2];

   // Do stuff with information
    // 情報を元にいろいろなことをする
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>getopts</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rustc_serialize</span>;

<span class='kw'>use</span> <span class='ident'>getopts</span>::<span class='ident'>Options</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>args</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>().<span class='ident'>collect</span>();
    <span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>0</span>];

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
    <span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>opts</span>.<span class='ident'>parse</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>..]) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>m</span>)  <span class='op'>=&gt;</span> { <span class='ident'>m</span> }
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='ident'>e</span>.<span class='ident'>to_string</span>()) }
    };
    <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>opt_present</span>(<span class='string'>&quot;h&quot;</span>) {
        <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
        <span class='kw'>return</span>;
    }
    <span class='kw'>let</span> <span class='ident'>data_path</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>];
    <span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>2</span>];

    <span class='comment'>// 情報を元にいろいろなことをする</span>
}</pre>

<blockquote>
<p>訳注</p>

<ul>
<li>Usage: {} [options] <data-path> <city>：使用法：{} [options] <data-path> <city></li>
<li>Show this usage message.：この使用法のメッセージを表示する。</li>
</ul>
</blockquote>

<!-- First, we get a vector of the arguments passed into our program. We -->

<!-- then store the first one, knowing that it is our program's name. Once -->

<!-- that's done, we set up our argument flags, in this case a simplistic -->

<!-- help message flag. Once we have the argument flags set up, we use -->

<!-- `Options.parse` to parse the argument vector (starting from index one, -->

<!-- because index 0 is the program name). If this was successful, we -->

<!-- assign matches to the parsed object, if not, we panic. Once past that, -->

<!-- we test if the user passed in the help flag, and if so print the usage -->

<!-- message. The option help messages are constructed by Getopts, so all -->

<!-- we have to do to print the usage message is tell it what we want it to -->

<!-- print for the program name and template. If the user has not passed in -->

<!-- the help flag, we assign the proper variables to their corresponding -->

<!-- argumaents. -->

<p>このように、まず、このプログラムに渡された引数のベクタを取得します。
次に、最初の要素、つまり、プログラムの名前を格納します。
続いて引数フラグをセットアップしますが、今回はごく簡単なヘルプメッセージフラグが一つあるだけです。
セットアップできたら <code>Options.parse</code> を使って引数のベクタをパースします（インデックス0はプログラム名ですので、インデックス1から始めます）。
もしパースに成功したら、パースしたオブジェクトをマッチで取り出しますし、失敗したならパニックさせます。
ここまでたどり着いたら、ヘルプフラグが指定されたか調べて、もしそうなら使用法のメッセージを表示します。
ヘルプメッセージのオプションはGetoptsにより生成済みですので、使用法のメッセージを表示するために追加で必要なのは、プログラム名とテンプレートだけです。
もしユーザーがヘルプフラグを指定しなかったなら、変数を用意して、対応する引数の値をセットします。</p>

<!-- ## Writing the logic -->

<h2 id='ロジックを書く' class='section-header'><a href='#ロジックを書く'>ロジックを書く</a></h2>
<!-- We all write code differently, but error handling is usually the last thing we -->

<!-- want to think about. This isn't great for the overall design of a program, but -->

<!-- it can be useful for rapid prototyping. Because Rust forces us to be explicit -->

<!-- about error handling (by making us call `unwrap`), it is easy to see which -->

<!-- parts of our program can cause errors. -->

<p>コードを書く順番は人それぞれですが、エラーハンドリングは最後に考えることが多いでしょう。
これはプログラム全体の設計にとっては、あまり良いことではありません。
しかし、ラピッドプロトタイピングには便利かもしれません。
Rustは私たちにエラーハンドリングが明示的であることを（ <code>unwrap</code> を呼ばせることで）強制しますので、プログラムのどこがエラーを起こすかは、簡単にわかります。</p>

<!-- In this case study, the logic is really simple. All we need to do is parse the -->

<!-- CSV data given to us and print out a field in matching rows. Let's do it. (Make -->

<!-- sure to add `extern crate csv;` to the top of your file.) -->

<p>このケーススタディでは、ロジックは非常にシンプルです。
やることは、与えられたCSVデータをパースして、マッチした行にあるフィールドを表示するだけです。
やってみましょう。
（ファイルの先頭に <code>extern crate csv;</code> を追加することを忘れずに。）</p>

<span class='rusttest'>use std::fs::File;

// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty gritty error
// handling, like parsing strings as integers or floats.
// この構造体はCSVファイルの各行のデータを表現します。
// 型に基づいたデコードにより、文字列を整数や浮動小数点数にパースして
// しまうといった、核心部分のエラーハンドリングの大半から解放されます。
#[derive(Debug, RustcDecodable)]
struct Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

   // Not every row has data for the population, latitude or longitude!
   // So we express them as `Option` types, which admits the possibility of
   // absence. The CSV parser will fill in the correct value for us.
    // 人口、経度、緯度などのデータは全ての行にあるわけではありません！
    // そこで、これらは不在の可能性を許す `Option` 型で表現します。
    // CSVパーサーは、これらを正しい値で埋めてくれます。
    population: Option&lt;u64&gt;,
    latitude: Option&lt;f64&gt;,
    longitude: Option&lt;f64&gt;,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = &amp;args[0];

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };

    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }

    let data_path = &amp;args[1];
    let city: &amp;str = &amp;args[2];

    let file = File::open(data_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);

    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();

        if row.city == city {
            println!(&quot;{}, {}: {:?}&quot;,
                row.city, row.country,
                row.population.expect(&quot;population count&quot;));
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;

<span class='comment'>// この構造体はCSVファイルの各行のデータを表現します。</span>
<span class='comment'>// 型に基づいたデコードにより、文字列を整数や浮動小数点数にパースして</span>
<span class='comment'>// しまうといった、核心部分のエラーハンドリングの大半から解放されます。</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>, <span class='ident'>RustcDecodable</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Row</span> {
    <span class='ident'>country</span>: <span class='ident'>String</span>,
    <span class='ident'>city</span>: <span class='ident'>String</span>,
    <span class='ident'>accent_city</span>: <span class='ident'>String</span>,
    <span class='ident'>region</span>: <span class='ident'>String</span>,

    <span class='comment'>// 人口、経度、緯度などのデータは全ての行にあるわけではありません！</span>
    <span class='comment'>// そこで、これらは不在の可能性を許す `Option` 型で表現します。</span>
    <span class='comment'>// CSVパーサーは、これらを正しい値で埋めてくれます。</span>
    <span class='ident'>population</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>u64</span><span class='op'>&gt;</span>,
    <span class='ident'>latitude</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>,
    <span class='ident'>longitude</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>,
}

<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>args</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>().<span class='ident'>collect</span>();
    <span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>0</span>];

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
    <span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>opts</span>.<span class='ident'>parse</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>..]) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>m</span>)  <span class='op'>=&gt;</span> { <span class='ident'>m</span> }
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='ident'>e</span>.<span class='ident'>to_string</span>()) }
    };

    <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>opt_present</span>(<span class='string'>&quot;h&quot;</span>) {
        <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
        <span class='kw'>return</span>;
    }

    <span class='kw'>let</span> <span class='ident'>data_path</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>];
    <span class='kw'>let</span> <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>2</span>];

    <span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>data_path</span>).<span class='ident'>unwrap</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>file</span>);

    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='ident'>row</span>.<span class='ident'>unwrap</span>();

        <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>,
                <span class='ident'>row</span>.<span class='ident'>city</span>, <span class='ident'>row</span>.<span class='ident'>country</span>,
                <span class='ident'>row</span>.<span class='ident'>population</span>.<span class='ident'>expect</span>(<span class='string'>&quot;population count&quot;</span>));
        }
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>population count：人口のカウント</p>
</blockquote>

<!-- Let's outline the errors. We can start with the obvious: the three places that -->

<!-- `unwrap` is called: -->

<p>ここで、エラーの概要を把握しましょう。
まずは明白なところ、つまり <code>unwrap</code> が呼ばれている3ヶ所から始めます：</p>

<!-- 1. [`File::open`](../std/fs/struct.File.html#method.open) -->

<!--    can return an -->

<!--    [`io::Error`](../std/io/struct.Error.html). -->

<!-- 2. [`csv::Reader::decode`](http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode) -->

<!--    decodes one record at a time, and -->

<!--    [decoding a -->

<!--    record](http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html) -->

<!--    (look at the `Item` associated type on the `Iterator` impl) -->

<!--    can produce a -->

<!--    [`csv::Error`](http://burntsushi.net/rustdoc/csv/enum.Error.html). -->

<!-- 3. If `row.population` is `None`, then calling `expect` will panic. -->

<ol>
<li><a href="../std/fs/struct.File.html#method.open"><code>File::open</code></a> が <a href="../std/io/struct.Error.html"><code>io::Error</code></a> を返すかもしれない。</li>
<li><a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a> は1度に1件のレコードをデコードし、 <a href="http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">レコードのデコード</a> （<code>Iterator</code> の impl の <code>Item</code> 関連型を見てください）は <a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a> を起こすかもしれない。</li>
<li>もし <code>row.population</code> が <code>None</code> なら、 <code>expect</code> の呼び出しはパニックする。</li>
</ol>

<!-- Are there any others? What if we can't find a matching city? Tools like `grep` -->

<!-- will return an error code, so we probably should too. So we have logic errors -->

<!-- specific to our problem, IO errors and CSV parsing errors. We're going to -->

<!-- explore two different ways to approach handling these errors. -->

<p>他にもありますか？
もし一致する都市が見つからなかったら？
<code>grep</code> のようなツールはエラーコードを返しますので、ここでも、そうするべきかもしれません。
つまり、IOエラーとCSVパースエラーの他に、このプログラム特有のエラーロジックがあるわけです。
これらのエラーを扱うために、2つのアプローチを試してみましょう。</p>

<!-- I'd like to start with `Box<Error>`. Later, we'll see how defining our own -->

<!-- error type can be useful. -->

<p>まず <code>Box&lt;Error&gt;</code> から始めたいと思います。
その後で、独自のエラー型を定義すると、どのように便利になるかを見てみましょう。</p>

<!-- ## Error handling with `Box<Error>` -->

<h2 id='boxerror-によるエラー処理' class='section-header'><a href='#boxerror-によるエラー処理'><code>Box&lt;Error&gt;</code> によるエラー処理</a></h2>
<!-- `Box<Error>` is nice because it *just works*. You don't need to define your own -->

<!-- error types and you don't need any `From` implementations. The downside is that -->

<!-- since `Box<Error>` is a trait object, it *erases the type*, which means the -->

<!-- compiler can no longer reason about its underlying type. -->

<p><code>Box&lt;Error&gt;</code> の良いところは <em>とにかく動く</em> ことです。
エラー型を定義して <code>From</code> を実装する、といったことは必要ありません。
これの欠点は <code>Box&lt;Error&gt;</code> がトレイトオブジェクトなので <em>型消去</em> され、コンパイラが背後の型を推測できなくなることです。</p>

<!-- [Previously](#the-limits-of-combinators) we started refactoring our code by -->

<!-- changing the type of our function from `T` to `Result<T, OurErrorType>`. In -->

<!-- this case, `OurErrorType` is only `Box<Error>`. But what's `T`? And can we add -->

<!-- a return type to `main`? -->

<p><a href="#%E3%82%B3%E3%83%B3%E3%83%93%E3%83%8D%E3%83%BC%E3%82%BF%E3%81%AE%E9%99%90%E7%95%8C">以前</a> コードのリファクタリングを、関数の型を <code>T</code> から <code>Result&lt;T, 私たちのエラー型&gt;</code> に変更することから始めました。
ここでは <code>私たちのエラー型</code> は単に <code>Box&lt;Error&gt;</code> です。
でも <code>T</code> は何になるでしょう？
それに <code>main</code> にリターン型を付けられるのでしょうか？</p>

<!-- The answer to the second question is no, we can't. That means we'll need to -->

<!-- write a new function. But what is `T`? The simplest thing we can do is to -->

<!-- return a list of matching `Row` values as a `Vec<Row>`. (Better code would -->

<!-- return an iterator, but that is left as an exercise to the reader.) -->

<p>2つ目の質問の答えはノーです。できません。
つまり新しい関数を書くことになります。
では <code>T</code> は何になるでしょう？
一番簡単にできるのは、マッチした <code>Row</code> 値のリストを <code>Vec&lt;Row&gt;</code> として返すことです。
（もっと良いコードはイテレータを返すかもしれませんが、これは読者の皆さんへの練習問題とします。）</p>

<!-- Let's refactor our code into its own function, but keep the calls to `unwrap`. -->

<!-- Note that we opt to handle the possibility of a missing population count by -->

<!-- simply ignoring that row. -->

<p>該当のコードを、専用の関数へとリファクタリングしましょう。
ただし <code>unwrap</code> の呼び出しはそのままにします。
また、人口のカウントがない場合は、いまは単にその行を無視することに注意してください。</p>

<span class='rusttest'>use std::path::Path;

struct Row {
    // unchanged
    // 変更なし
}

struct PopulationCount {
    city: String,
    country: String,
    // This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    // これは `Option` から変更します。なぜなら、この型の値は
    // 人口のカウントがあるときだけ構築されるようになったからです。
    count: u64,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; {
    let mut found = vec![];
    let file = File::open(file_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();
        match row.population {
          // None =&gt; { } // skip it
            None =&gt; { } // スキップする
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = &amp;args[0];

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }

    let data_path = &amp;args[1];
    let city = &amp;args[2];
    for pop in search(data_path, city) {
        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>struct</span> <span class='ident'>Row</span> {
    <span class='comment'>// 変更なし</span>
}

<span class='kw'>struct</span> <span class='ident'>PopulationCount</span> {
    <span class='ident'>city</span>: <span class='ident'>String</span>,
    <span class='ident'>country</span>: <span class='ident'>String</span>,
    <span class='comment'>// これは `Option` から変更します。なぜなら、この型の値は</span>
    <span class='comment'>// 人口のカウントがあるときだけ構築されるようになったからです。</span>
    <span class='ident'>count</span>: <span class='ident'>u64</span>,
}

<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}

<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>unwrap</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>file</span>);
    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='ident'>row</span>.<span class='ident'>unwrap</span>();
        <span class='kw'>match</span> <span class='ident'>row</span>.<span class='ident'>population</span> {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { } <span class='comment'>// スキップする</span>
            <span class='prelude-val'>Some</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
                <span class='ident'>found</span>.<span class='ident'>push</span>(<span class='ident'>PopulationCount</span> {
                    <span class='ident'>city</span>: <span class='ident'>row</span>.<span class='ident'>city</span>,
                    <span class='ident'>country</span>: <span class='ident'>row</span>.<span class='ident'>country</span>,
                    <span class='ident'>count</span>: <span class='ident'>count</span>,
                });
            },
        }
    }
    <span class='ident'>found</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>args</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>().<span class='ident'>collect</span>();
    <span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>0</span>];

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
    <span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>opts</span>.<span class='ident'>parse</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>..]) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>m</span>)  <span class='op'>=&gt;</span> { <span class='ident'>m</span> }
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='ident'>e</span>.<span class='ident'>to_string</span>()) }
    };
    <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>opt_present</span>(<span class='string'>&quot;h&quot;</span>) {
        <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
        <span class='kw'>return</span>;
    }

    <span class='kw'>let</span> <span class='ident'>data_path</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>];
    <span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>2</span>];
    <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>search</span>(<span class='ident'>data_path</span>, <span class='ident'>city</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
    }
}
</pre>

<!-- While we got rid of one use of `expect` (which is a nicer variant of `unwrap`), -->

<!-- we still should handle the absence of any search results. -->

<p><code>expect</code> （<code>unwrap</code> の少し良い版）の使用を1つ取り除くことができましたが、検索の結果が無いときのハンドリングは、依然として必要です。</p>

<!-- To convert this to proper error handling, we need to do the following: -->

<p>このエラーを適切に処理するためには、以下のようにします：</p>

<!-- 1. Change the return type of `search` to be `Result<Vec<PopulationCount>, -->

<!--    Box<Error>>`. -->

<!-- 2. Use the [`try!` macro](#code-try-def) so that errors are returned to the -->

<!--    caller instead of panicking the program. -->

<!-- 3. Handle the error in `main`. -->

<ol>
<li><code>search</code> のリターン型を <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code> に変更する。</li>
<li><a href="#code-try-def"><code>try!</code> マクロ</a> を使用することで、プログラムをパニックする代わりに、エラーを呼び出し元に返す。</li>
<li><code>main</code> でエラーをハンドリングする。</li>
</ol>

<!-- Let's try it: -->

<p>やってみましょう：</p>

<span class='rusttest'>fn main() {
    use std::error::Error;

// The rest of the code before this is unchanged
// ここ以前の他のコードに変更なし

fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: P, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
    let mut found = vec![];
    let file = try!(File::open(file_path));
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = try!(row);
        match row.population {
          // None =&gt; { } // skip it
            None =&gt; { } // スキップする
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(From::from(&quot;No matching cities with a population were found.&quot;))
    } else {
        Ok(found)
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>::<span class='ident'>Error</span>;

<span class='comment'>// ここ以前の他のコードに変更なし</span>

<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>
         (<span class='ident'>file_path</span>: <span class='ident'>P</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>)
         <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>+</span><span class='ident'>Send</span><span class='op'>+</span><span class='ident'>Sync</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>file</span>);
    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>row</span>);
        <span class='kw'>match</span> <span class='ident'>row</span>.<span class='ident'>population</span> {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { } <span class='comment'>// スキップする</span>
            <span class='prelude-val'>Some</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
                <span class='ident'>found</span>.<span class='ident'>push</span>(<span class='ident'>PopulationCount</span> {
                    <span class='ident'>city</span>: <span class='ident'>row</span>.<span class='ident'>city</span>,
                    <span class='ident'>country</span>: <span class='ident'>row</span>.<span class='ident'>country</span>,
                    <span class='ident'>count</span>: <span class='ident'>count</span>,
                });
            },
        }
    }
    <span class='kw'>if</span> <span class='ident'>found</span>.<span class='ident'>is_empty</span>() {
        <span class='prelude-val'>Err</span>(<span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;No matching cities with a population were found.&quot;</span>))
    } <span class='kw'>else</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>found</span>)
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>No matching cities with a population were found.：<br/>
条件に合う人口データ付きの都市は見つかりませんでした。</p>
</blockquote>

<!-- Instead of `x.unwrap()`, we now have `try!(x)`. Since our function returns a -->

<!-- `Result<T, E>`, the `try!` macro will return early from the function if an -->

<!-- error occurs. -->

<p><code>x.unwrap()</code> の代わりに、今では <code>try!(x)</code> があります。
私たちの関数が <code>Result&lt;T, E&gt;</code> を返すので、エラーの発生時、 <code>try!</code> マクロは関数の途中で戻ります。</p>

<!-- There is one big gotcha in this code: we used `Box<Error + Send + Sync>` -->

<!-- instead of `Box<Error>`. We did this so we could convert a plain string to an -->

<!-- error type. We need these extra bounds so that we can use the -->

<!-- [corresponding `From` -->

<!-- impls](../std/convert/trait.From.html): -->

<p>このコードで1点注意があります：
<code>Box&lt;Error&gt;</code> の代わりに <code>Box&lt;Error + Send + Sync&gt;</code> を使いました。
こうすると、プレーンな文字列をエラー型に変換できます。
<a href="../std/convert/trait.From.html">この <code>From</code> 実装</a> を使うために、このような追加の制限が必要でした。</p>

<span class='rusttest'>fn main() {
    // We are making use of this impl in the code above, since we call `From::from`
// on a `&amp;&#39;static str`.
// 上のコードでは `&amp;&#39;static str` に対して `From::from` を呼ぶことで、
// こちらの実装を使おうとしています。
impl&lt;&#39;a, &#39;b&gt; From&lt;&amp;&#39;b str&gt; for Box&lt;Error + Send + Sync + &#39;a&gt;

// But this is also useful when you need to allocate a new string for an
// error message, usually with `format!`.
// もし `format!` などを使ってエラーメッセージのために新しい文字列を
// 割り当てる場合は、こちらの実装も使えます。
impl From&lt;String&gt; for Box&lt;Error + Send + Sync&gt;
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 上のコードでは `&amp;&#39;static str` に対して `From::from` を呼ぶことで、</span>
<span class='comment'>// こちらの実装を使おうとしています。</span>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span> <span class='op'>+</span> <span class='ident'>Send</span> <span class='op'>+</span> <span class='ident'>Sync</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>

<span class='comment'>// もし `format!` などを使ってエラーメッセージのために新しい文字列を</span>
<span class='comment'>// 割り当てる場合は、こちらの実装も使えます。</span>
<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span> <span class='op'>+</span> <span class='ident'>Send</span> <span class='op'>+</span> <span class='ident'>Sync</span><span class='op'>&gt;</span></pre>

<!-- Since `search` now returns a `Result<T, E>`, `main` should use case analysis -->

<!-- when calling `search`: -->

<p><code>search</code> が <code>Result&lt;T, E&gt;</code> を返すようになったため、 <code>main</code> は <code>search</code> を呼ぶときに場合分けをしなければなりません：</p>

<span class='rusttest'>fn main() {
    ...
match search(&amp;data_file, &amp;city) {
    Ok(pops) =&gt; {
        for pop in pops {
            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
        }
    }
    Err(err) =&gt; println!(&quot;{}&quot;, err)
}
...
}</span><pre class='rust rust-example-rendered'>
...
<span class='kw'>match</span> <span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>data_file</span>, <span class='kw-2'>&amp;</span><span class='ident'>city</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>pops</span>) <span class='op'>=&gt;</span> {
        <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>pops</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
        }
    }
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
}
...</pre>

<!-- Now that we've seen how to do proper error handling with `Box<Error>`, let's -->

<!-- try a different approach with our own custom error type. But first, let's take -->

<!-- a quick break from error handling and add support for reading from `stdin`. -->

<p><code>Box&lt;Error&gt;</code> を使った適切なエラーハンドリングについて見ましたので、次は独自のエラー型による別のアプローチを試してみましょう。
でもその前に、少しの間、エラーハンドリングから離れて、 <code>stdin</code> からの読み込みをサポートしましょう。</p>

<!-- ## Reading from stdin -->

<h2 id='標準入力から読み込む' class='section-header'><a href='#標準入力から読み込む'>標準入力から読み込む</a></h2>
<!-- In our program, we accept a single file for input and do one pass over the -->

<!-- data. This means we probably should be able to accept input on stdin. But maybe -->

<!-- we like the current format too—so let's have both! -->

<p>このプログラムでは、入力としてファイルをただ一つ受け取り、1回のパスでデータを処理しています。
これは、標準入力からの入力を受け付けたほうがいいことを意味しているのかもしれません。
でも、いまの方法も捨てがたいので、両方できるようにしましょう！</p>

<!-- Adding support for stdin is actually quite easy. There are only three things we -->

<!-- have to do: -->

<p>標準入力のサポートを追加するのは実に簡単です。
やることは3つだけです：</p>

<!-- 1. Tweak the program arguments so that a single parameter—the -->

<!--    city—can be accepted while the population data is read from stdin. -->

<!-- 2. Modify the program so that an option `-f` can take the file, if it -->

<!--     is not passed into stdin. -->

<!-- 3. Modify the `search` function to take an *optional* file path. When `None`, -->

<!--    it should know to read from stdin. -->

<ol>
<li>プログラムの引数を微修正して、唯一のパラメータとして「都市」を受け付け、人口データは標準入力から読み込むようにする。</li>
<li>プログラムを修正して、ファイルが標準入力に流し込まれなかったときに、<code>-f</code> オプションからファイルを得られるようにする。</li>
<li><code>search</code> 関数を修正して、ファイルパスを <code>オプションで</code> 受け取れるようにする。もし <code>None</code> なら標準入力から読み込む。</li>
</ol>

<!-- First, here's the new usage: -->

<p>まず、使用法を変更します：</p>

<span class='rusttest'>fn main() {
    fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;city&gt;&quot;, program)));
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}</pre>

<!-- The next part is going to be only a little harder: -->

<p>次のパートはやや難しくなります：</p>

<span class='rusttest'>fn main() {
    ...
let mut opts = Options::new();
opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);
opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);
...
let file = matches.opt_str(&quot;f&quot;);
let data_file = &amp;file.as_ref().map(Path::new);

let city = if !matches.free.is_empty() {
    &amp;matches.free[0]
} else {
    print_usage(&amp;program, opts);
    return;
};

match search(data_file, city) {
    Ok(pops) =&gt; {
        for pop in pops {
            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
        }
    }
    Err(err) =&gt; println!(&quot;{}&quot;, err)
}
...
}</span><pre class='rust rust-example-rendered'>
...
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
<span class='ident'>opts</span>.<span class='ident'>optopt</span>(<span class='string'>&quot;f&quot;</span>, <span class='string'>&quot;file&quot;</span>, <span class='string'>&quot;Choose an input file, instead of using STDIN.&quot;</span>, <span class='string'>&quot;NAME&quot;</span>);
<span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);
...
<span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>opt_str</span>(<span class='string'>&quot;f&quot;</span>);
<span class='kw'>let</span> <span class='ident'>data_file</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>file</span>.<span class='ident'>as_ref</span>().<span class='ident'>map</span>(<span class='ident'>Path</span>::<span class='ident'>new</span>);

<span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='op'>!</span><span class='ident'>matches</span>.<span class='ident'>free</span>.<span class='ident'>is_empty</span>() {
    <span class='kw-2'>&amp;</span><span class='ident'>matches</span>.<span class='ident'>free</span>[<span class='number'>0</span>]
} <span class='kw'>else</span> {
    <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
    <span class='kw'>return</span>;
};

<span class='kw'>match</span> <span class='ident'>search</span>(<span class='ident'>data_file</span>, <span class='ident'>city</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>pops</span>) <span class='op'>=&gt;</span> {
        <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>pops</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
        }
    }
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
}
...</pre>

<blockquote>
<p>訳注：</p>

<p>Choose an input file, instead of using STDIN：<br/>
STDINを使う代わりに、入力ファイルを選択する。</p>
</blockquote>

<!-- In this piece of code, we take `file` (which has the type -->

<!-- `Option<String>`), and convert it to a type that `search` can use, in -->

<!-- this case, `&Option<AsRef<Path>>`. To do this, we take a reference of -->

<!-- file, and map `Path::new` onto it. In this case, `as_ref()` converts -->

<!-- the `Option<String>` into an `Option<&str>`, and from there, we can -->

<!-- execute `Path::new` to the content of the optional, and return the -->

<!-- optional of the new value. Once we have that, it is a simple matter of -->

<!-- getting the `city` argument and executing `search`. -->

<p>このコードでは（<code>Option&lt;String&gt;</code> 型の） <code>file</code> を受け取り、 <code>search</code> が使える型、つまり今回は <code>&amp;Option&lt;AsRef&lt;Path&gt;&gt;</code> へ変換します。
そのためには <code>file</code> の参照を得て、それに対して <code>Path::new</code> をマップします。
このケースでは <code>as_ref()</code> が <code>Option&lt;String&gt;</code> を <code>Option&lt;&amp;str&gt;</code> へ変換しますので、続いて、そのオプション値の中身に対して <code>Path::new</code> を実行することで、新しいオプション値を返します。
ここまでできれば、残りは単に <code>city</code> 引数を取得して <code>search</code> を実行するだけです。</p>

<!-- Modifying `search` is slightly trickier. The `csv` crate can build a -->

<!-- parser out of -->

<!-- [any type that implements `io::Read`](http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader). -->

<!-- But how can we use the same code over both types? There's actually a -->

<!-- couple ways we could go about this. One way is to write `search` such -->

<!-- that it is generic on some type parameter `R` that satisfies -->

<!-- `io::Read`. Another way is to use trait objects: -->

<p><code>search</code> の修正は少し厄介です。
<code>csv</code> トレイトは <a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader"><code>io::Read</code> を実装している型</a> からなら、いずれかを問わず、パーサーを構築できます。
しかし両方の型に同じコードが使えるのでしょうか？
これを実際する方法は2つあります。
ひとつの方法は <code>search</code> を <code>io::Read</code> を満たす型パラメータ <code>R</code> に対するジェネリックとして書くことです。
もうひとつの方法は、以下のように、トレイトオブジェクトを使うことです：</p>

<span class='rusttest'>fn main() {
    use std::io;

// The rest of the code before this is unchanged
// ここ以前の他のコードに変更なし

fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
    let mut found = vec![];
    let input: Box&lt;io::Read&gt; = match *file_path {
        None =&gt; Box::new(io::stdin()),
        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    // The rest remains unchanged!
    // これ以降は変更なし！
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='comment'>// ここ以前の他のコードに変更なし</span>

<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>
         (<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>P</span><span class='op'>&gt;</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>)
         <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>+</span><span class='ident'>Send</span><span class='op'>+</span><span class='ident'>Sync</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>input</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Read</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>file_path</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>io</span>::<span class='ident'>stdin</span>()),
        <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>file_path</span>) <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>))),
    };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>input</span>);
    <span class='comment'>// これ以降は変更なし！</span>
}</pre>

<!-- ## Error handling with a custom type -->

<h2 id='独自のエラー型によるエラー処理' class='section-header'><a href='#独自のエラー型によるエラー処理'>独自のエラー型によるエラー処理</a></h2>
<!-- Previously, we learned how to -->

<!-- [compose errors using a custom error type](#composing-custom-error-types). -->

<!-- We did this by defining our error type as an `enum` and implementing `Error` -->

<!-- and `From`. -->

<p>以前、どうやって <a href="#composing-custom-error-types">独自のエラー型を使ってエラーを合成する</a> のか学びました。
そのときはエラー型を <code>enum</code> 型として定義して、<code>Error</code> と <code>From</code> を実装することで実現しました。</p>

<!-- Since we have three distinct errors (IO, CSV parsing and not found), let's -->

<!-- define an `enum` with three variants: -->

<p>3つの異なるエラー（IO、CSVのパース、検索結果なし）がありますので <code>enum</code> として3つのヴァリアントを定義しましょう：</p>

<span class='rusttest'>fn main() {
    #[derive(Debug)]
enum CliError {
    Io(io::Error),
    Csv(csv::Error),
    NotFound,
}
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Csv</span>(<span class='ident'>csv</span>::<span class='ident'>Error</span>),
    <span class='ident'>NotFound</span>,
}</pre>

<!-- And now for impls on `Display` and `Error`: -->

<p><code>Display</code> と <code>Error</code> を実装します：</p>

<span class='rusttest'>fn main() {
    impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            CliError::Io(ref err) =&gt; err.fmt(f),
            CliError::Csv(ref err) =&gt; err.fmt(f),
            CliError::NotFound =&gt; write!(f, &quot;No matching cities with a \
                                             population were found.&quot;),
        }
    }
}

impl Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Csv(ref err) =&gt; err.description(),
            CliError::NotFound =&gt; &quot;not found&quot;,
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {            
            CliError::Io(ref err) =&gt; Some(err),
            CliError::Parse(ref err) =&gt; Some(err),
           // Our custom error doesn&#39;t have an underlying cause, but we could
           // modify it so that it does.
            // 今回の自前のエラーは下流の原因となるエラーは持っていませんが
            // そのように変更することも可能です。
            CliError::NotFound() =&gt; None,
        }
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>fmt</span>(<span class='ident'>f</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Csv</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>fmt</span>(<span class='ident'>f</span>),
            <span class='ident'>CliError</span>::<span class='ident'>NotFound</span> <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;No matching cities with a \
                                             population were found.&quot;</span>),
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>Error</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
            <span class='ident'>CliError</span>::<span class='ident'>Csv</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
            <span class='ident'>CliError</span>::<span class='ident'>NotFound</span> <span class='op'>=&gt;</span> <span class='string'>&quot;not found&quot;</span>,
        }
    }

    <span class='kw'>fn</span> <span class='ident'>cause</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>error</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {            
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>err</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>err</span>),
            <span class='comment'>// 今回の自前のエラーは下流の原因となるエラーは持っていませんが</span>
            <span class='comment'>// そのように変更することも可能です。</span>
            <span class='ident'>CliError</span>::<span class='ident'>NotFound</span>() <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        }
    }
}</pre>

<!-- Before we can use our `CliError` type in our `search` function, we need to -->

<!-- provide a couple `From` impls. How do we know which impls to provide? Well, -->

<!-- we'll need to convert from both `io::Error` and `csv::Error` to `CliError`. -->

<!-- Those are the only external errors, so we'll only need two `From` impls for -->

<!-- now: -->

<p><code>CliError</code> を <code>search</code> 関数の型に使う前に、いくつかの <code>From</code> 実装を用意しなければなりません。
どのエラーについて用意したらいいのでしょう？
ええと <code>io::Error</code> と <code>csv::Error</code> の両方を <code>CliError</code> に変換する必要があります。
外部エラーはこれだけですので、今は2つの <code>From</code> 実装だけが必要になるのです：</p>

<span class='rusttest'>fn main() {
    impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;csv::Error&gt; for CliError {
    fn from(err: csv::Error) -&gt; CliError {
        CliError::Csv(err)
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>io</span>::<span class='ident'>Error</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='ident'>err</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>csv</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>csv</span>::<span class='ident'>Error</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Csv</span>(<span class='ident'>err</span>)
    }
}</pre>

<!-- The `From` impls are important because of how -->

<!-- [`try!` is defined](#code-try-def). In particular, if an error occurs, -->

<!-- `From::from` is called on the error, which in this case, will convert it to our -->

<!-- own error type `CliError`. -->

<p><a href="#code-try-def"><code>try!</code> がこのように定義</a> されているので、 <code>From</code> の実装が重要になります。
特にエラーが起こると、エラーに対して <code>From::from</code> が呼ばれますので、このケースでは、それらのエラーが私たち独自のエラー型 <code>CliError</code> へ変換されます。</p>

<!-- With the `From` impls done, we only need to make two small tweaks to our -->

<!-- `search` function: the return type and the “not found” error. Here it is in -->

<!-- full: -->

<p><code>From</code> の実装ができましたので、<code>search</code> 関数に2つの小さな修正が必要です：
リターン型と「not found」エラーです。
全体はこうなります：</p>

<span class='rusttest'>fn main() {
    fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {
    let mut found = vec![];
    let input: Box&lt;io::Read&gt; = match *file_path {
        None =&gt; Box::new(io::stdin()),
        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = try!(row);
        match row.population {
          // None =&gt; { } // skip it
            None =&gt; { } // スキップする
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(CliError::NotFound)
    } else {
        Ok(found)
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>
         (<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>P</span><span class='op'>&gt;</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>)
         <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>input</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Read</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>file_path</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>io</span>::<span class='ident'>stdin</span>()),
        <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>file_path</span>) <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>))),
    };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>input</span>);
    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>row</span>);
        <span class='kw'>match</span> <span class='ident'>row</span>.<span class='ident'>population</span> {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { } <span class='comment'>// スキップする</span>
            <span class='prelude-val'>Some</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
                <span class='ident'>found</span>.<span class='ident'>push</span>(<span class='ident'>PopulationCount</span> {
                    <span class='ident'>city</span>: <span class='ident'>row</span>.<span class='ident'>city</span>,
                    <span class='ident'>country</span>: <span class='ident'>row</span>.<span class='ident'>country</span>,
                    <span class='ident'>count</span>: <span class='ident'>count</span>,
                });
            },
        }
    }
    <span class='kw'>if</span> <span class='ident'>found</span>.<span class='ident'>is_empty</span>() {
        <span class='prelude-val'>Err</span>(<span class='ident'>CliError</span>::<span class='ident'>NotFound</span>)
    } <span class='kw'>else</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>found</span>)
    }
}</pre>

<!-- No other changes are necessary. -->

<p>これ以外の変更は不要です。</p>

<!-- ## Adding functionality -->

<h2 id='機能を追加する' class='section-header'><a href='#機能を追加する'>機能を追加する</a></h2>
<!-- Writing generic code is great, because generalizing stuff is cool, and -->

<!-- it can then be useful later. But sometimes, the juice isn't worth the -->

<!-- squeeze. Look at what we just did in the previous step: -->

<p>汎用的なコードを書くのは素晴らしいことです。
なぜなら、物事を汎用的にするのはクールですし、後になって役立つかもしれません。
でも時には、その苦労の甲斐がないこともあります。
最後のステップで何をしたか振り返ってみましょう：</p>

<!-- 1. Defined a new error type. -->

<!-- 2. Added impls for `Error`, `Display` and two for `From`. -->

<ol>
<li>新しいエラー型を定義した。</li>
<li><code>Error</code> と <code>Display</code> の実装を追加し、2つのエラーに対して <code>From</code> も実装した。</li>
</ol>

<!-- The big downside here is that our program didn't improve a whole lot. -->

<!-- There is quite a bit of overhead to representing errors with `enum`s, -->

<!-- especially in short programs like this. -->

<p>ここでの大きな問題は、このプログラムは全体で見ると大して良くならなかったことです。
<code>enum</code> でエラーを表現するには、多くの付随する作業が必要です。
特にこのような短いプログラムでは、それが顕著に現れました。</p>

<!-- *One* useful aspect of using a custom error type like we've done here is that -->

<!-- the `main` function can now choose to handle errors differently. Previously, -->

<!-- with `Box<Error>`, it didn't have much of a choice: just print the message. -->

<!-- We're still doing that here, but what if we wanted to, say, add a `--quiet` -->

<!-- flag? The `--quiet` flag should silence any verbose output. -->

<p>ここでしたような独自のエラー型を使うのが便利といえる <em>一つの</em> 要素は、 <code>main</code> 関数がエラーによってどう対処するのかを選択できるようになったことです。
以前の <code>Box&lt;Error&gt;</code> では、メッセージを表示する以外、選択の余地はほとんどありませんでした。
いまでもそうですが、例えば、もし <code>--quiet</code> フラグを追加したくなったらどうでしょうか？
<code>--quiet</code> フラグは詳細な出力を抑止すべきです。</p>

<!-- Right now, if the program doesn't find a match, it will output a message saying -->

<!-- so. This can be a little clumsy, especially if you intend for the program to -->

<!-- be used in shell scripts. -->

<p>いま現在は、プログラムがマッチするものを見つけられなかったとき、それを告げるメッセージを表示します。
これは、特にプログラムをシェルスクリプトから使いたいときなどは、扱いにくいかもしれません。</p>

<!-- So let's start by adding the flags. Like before, we need to tweak the usage -->

<!-- string and add a flag to the Option variable. Once we've done that, Getopts does the rest: -->

<p>フラグを追加してみましょう。
以前したように、使用法についての文字列を少し修正して、オプション変数にフラグを追加します。
そこまですれば、残りはGetoptsがやってくれます：</p>

<span class='rusttest'>fn main() {
    ...
let mut opts = Options::new();
opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);
opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);
opts.optflag(&quot;q&quot;, &quot;quiet&quot;, &quot;Silences errors and warnings.&quot;);
...
}</span><pre class='rust rust-example-rendered'>
...
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
<span class='ident'>opts</span>.<span class='ident'>optopt</span>(<span class='string'>&quot;f&quot;</span>, <span class='string'>&quot;file&quot;</span>, <span class='string'>&quot;Choose an input file, instead of using STDIN.&quot;</span>, <span class='string'>&quot;NAME&quot;</span>);
<span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);
<span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;q&quot;</span>, <span class='string'>&quot;quiet&quot;</span>, <span class='string'>&quot;Silences errors and warnings.&quot;</span>);
...</pre>

<!-- Now we only need to implement our “quiet” functionality. This requires us to -->

<!-- tweak the case analysis in `main`: -->

<p>後は「quiet」機能を実装するだけです。
<code>main</code> 関数の場合分けを少し修正します：</p>

<span class='rusttest'>fn main() {
    match search(&amp;args.arg_data_path, &amp;args.arg_city) {
    Err(CliError::NotFound) if args.flag_quiet =&gt; process::exit(1),
    Err(err) =&gt; panic!(&quot;{}&quot;, err),
    Ok(pops) =&gt; for pop in pops {
        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>.<span class='ident'>arg_data_path</span>, <span class='kw-2'>&amp;</span><span class='ident'>args</span>.<span class='ident'>arg_city</span>) {
    <span class='prelude-val'>Err</span>(<span class='ident'>CliError</span>::<span class='ident'>NotFound</span>) <span class='kw'>if</span> <span class='ident'>args</span>.<span class='ident'>flag_quiet</span> <span class='op'>=&gt;</span> <span class='ident'>process</span>::<span class='ident'>exit</span>(<span class='number'>1</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>),
    <span class='prelude-val'>Ok</span>(<span class='ident'>pops</span>) <span class='op'>=&gt;</span> <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>pops</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>Silences errors and warnings.：エラーや警告を抑止します。</p>
</blockquote>

<!-- Certainly, we don't want to be quiet if there was an IO error or if the data -->

<!-- failed to parse. Therefore, we use case analysis to check if the error type is -->

<!-- `NotFound` *and* if `--quiet` has been enabled. If the search failed, we still -->

<!-- quit with an exit code (following `grep`'s convention). -->

<p>もちろん、IOエラーが起こったり、データのパースに失敗したときは、エラーを抑止したくはありません。
そこで場合分けを行い、エラータイプが <code>NotFound</code> <em>かつ</em> <code>--quiet</code> が指定されたかを検査しています。
もし検索に失敗したら、今まで通り（ <code>grep</code> の動作にならい）なにも表示せず、exitコードと共に終了します。</p>

<!-- If we had stuck with `Box<Error>`, then it would be pretty tricky to implement -->

<!-- the `--quiet` functionality. -->

<p>もし <code>Box&lt;Error&gt;</code> で留まっていたら、 <code>--quiet</code> 機能を実装するのは、かなり面倒だったでしょう。</p>

<!-- This pretty much sums up our case study. From here, you should be ready to go -->

<!-- out into the world and write your own programs and libraries with proper error -->

<!-- handling. -->

<p>これが、このケーススタディの締めくくりとなります。
これからは外の世界に飛び出して、あなた自身のプログラムやライブラリを、適切なエラーハンドリングと共に書くことができるでしょう。</p>

<!-- # The Short Story -->

<h1 id='まとめ' class='section-header'><a href='#まとめ'>まとめ</a></h1>
<!-- Since this section is long, it is useful to have a quick summary for error -->

<!-- handling in Rust. These are some good “rules of thumb." They are emphatically -->

<!-- *not* commandments. There are probably good reasons to break every one of these -->

<!-- heuristics! -->

<p>このセクションは長いので、Rustにおけるエラー処理について簡単にまとめたほうがいいでしょう。
そこには「大まかな法則」が存在しますが、これらは命令的なものでは断固として <em>ありません</em> 。
それぞれのヒューリスティックを破るだけの十分な理由もあり得ます！</p>

<!-- * If you're writing short example code that would be overburdened by error -->

<!--   handling, it's probably fine to use `unwrap` (whether that's -->

<!--   [`Result::unwrap`](../std/result/enum.Result.html#method.unwrap), -->

<!--   [`Option::unwrap`](../std/option/enum.Option.html#method.unwrap) -->

<!--   or preferably -->

<!--   [`Option::expect`](../std/option/enum.Option.html#method.expect)). -->

<!--   Consumers of your code should know to use proper error handling. (If they -->

<!--   don't, send them here!) -->

<!-- * If you're writing a quick 'n' dirty program, don't feel ashamed if you use -->

<!--   `unwrap`. Be warned: if it winds up in someone else's hands, don't be -->

<!--   surprised if they are agitated by poor error messages! -->

<!-- * If you're writing a quick 'n' dirty program and feel ashamed about panicking -->

<!--   anyway, then use either a `String` or a `Box<Error + Send + Sync>` for your -->

<!--   error type (the `Box<Error + Send + Sync>` type is because of the -->

<!--   [available `From` impls](../std/convert/trait.From.html)). -->

<!-- * Otherwise, in a program, define your own error types with appropriate -->

<!--   [`From`](../std/convert/trait.From.html) -->

<!--   and -->

<!--   [`Error`](../std/error/trait.Error.html) -->

<!--   impls to make the [`try!`](../std/macro.try!.html) -->

<!--   macro more ergonomic. -->

<!-- * If you're writing a library and your code can produce errors, define your own -->

<!--   error type and implement the -->

<!--   [`std::error::Error`](../std/error/trait.Error.html) -->

<!--   trait. Where appropriate, implement -->

<!--   [`From`](../std/convert/trait.From.html) to make both -->

<!--   your library code and the caller's code easier to write. (Because of Rust's -->

<!--   coherence rules, callers will not be able to impl `From` on your error type, -->

<!--   so your library should do it.) -->

<!-- * Learn the combinators defined on -->

<!--   [`Option`](../std/option/enum.Option.html) -->

<!--   and -->

<!--   [`Result`](../std/result/enum.Result.html). -->

<!--   Using them exclusively can be a bit tiring at times, but I've personally -->

<!--   found a healthy mix of `try!` and combinators to be quite appealing. -->

<!--   `and_then`, `map` and `unwrap_or` are my favorites. -->

<ul>
<li>もし短いサンプルコードを書いていて、エラーハンドリングが重荷になるようなら、 <code>unwrap</code> を使っても大丈夫かもしれません（ <a href="../std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>, <a href="../std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>, <a href="../std/option/enum.Option.html#method.expect"><code>Option::expect</code></a> のいずれかが使えます）。
あなたのコードを参考にする人は、正しいエラーハンドリングについて知っているべきです。（そうでなければ、このセクションを紹介してください！）</li>
<li>もし即興のプログラムを書いているなら <code>unwrap</code> を使うことに罪悪感を持たなくてもいいでしょう。
ただし警告があります：もしそれが最終的に他の人たちの手に渡るなら、彼らが貧弱なエラーメッセージに動揺してもおかしくありません。</li>
<li>もし即興のプログラムを書いていて、パニックすることに、どうしても後ろめたさを感じるなら、エラー型として <code>String</code> か <code>Box&lt;Error + Send + Sync&gt;</code> のいずれかを使ってください（ <code>Box&lt;Error + Send + Sync&gt;</code> は <a href="../std/convert/trait.From.html"><code>From</code> 実装がある</a> ので使えます）。</li>
<li>これらに該当しないなら、独自のエラー型を定義し、適切な <a href="../std/convert/trait.From.html"><code>From</code></a> と <a href="../std/error/trait.Error.html"><code>Error</code></a> を実装することで <a href="../std/macro.try!.html"><code>try!</code></a> マクロをエルゴノミックにしましょう。</li>
<li>もしライブラリを書いていて、そのコードがエラーを起こす可能性があるなら、独自のエラー型を定義し、 <a href="../std/error/trait.Error.html"><code>std::error::Error</code></a> トレイトを実装してください。
もし必要なら <a href="../std/convert/trait.From.html"><code>From</code></a> を実装することで、ライブラリ自身と呼び出し元のコードを書きやすくしてください。
（Rustの調和性規則(coherence rule) により、呼び出し側では、あなたのエラー型に対して <code>From</code> を実装することはできません。
ライブラリでするべきです。）</li>
<li><a href="../std/option/enum.Option.html"><code>Option</code></a> と <a href="../std/result/enum.Result.html"><code>Result</code></a> で定義されているコンビネータについて学んでください。
それだけを使うのは大変ですが、 <code>try!</code> と コンビネータを適度にミックスすることは、個人的には、とても魅力的な方法だと考えています。
<code>and_then</code>, <code>map</code>, <code>unwrap_or</code> が私のお気に入りです。</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>