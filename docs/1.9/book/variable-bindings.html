<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>変数束縛</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    <meta name="robots" content="noindex">


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル：数当てゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a class='active' href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='vectors.html'><b>4.7.</b> ベクタ</a>
</li>
<li><a  href='ownership.html'><b>4.8.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.9.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.10.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.11.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.12.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.13.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.14.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.15.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.16.</b> メソッド構文</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> 他言語関数インターフェース</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語アイテム</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>
<blockquote class="header-caveat">
  <p>
    <strong>注意: <a href="https://doc.rust-jp.rs/book-ja/">最新版のドキュメントをご覧ください。</a></strong>この第1版ドキュメントは古くなっており、最新情報が反映されていません。リンク先のドキュメントが現在の Rust の最新のドキュメントです。
  </p>
</blockquote>

    <h1 class="title">変数束縛</h1>
    <!-- % Variable Bindings -->

<!-- Virtually every non-'Hello World’ Rust program uses *variable bindings*. They -->

<!-- bind some value to a name, so it can be used later. `let` is -->

<!-- used to introduce a binding, like this: -->

<p>事実上全ての「Hello World」でないRustのプログラムは <em>変数束縛</em> を使っています。
変数束縛は何らかの値を名前へと束縛するので、後でその値を使えます。
このように、 <code>let</code> が束縛を導入するのに使われています。</p>

<blockquote>
<p>訳注: 普通、束縛というときは名前 <em>を</em> 値 <em>へ</em> と束縛しますが、このドキュメントでは逆になっています。
     Rustでは他の言語と違って1つの値に対して1つの名前が対応するのであえてこう書いてるのかもしれません。</p>
</blockquote>

<span class='rusttest'>fn main() {
    let x = 5;
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
}</pre>

<!-- Putting `fn main() {` in each example is a bit tedious, so we’ll leave that out -->

<!-- in the future. If you’re following along, make sure to edit your `main()` -->

<!-- function, rather than leaving it off. Otherwise, you’ll get an error. -->

<p>例で毎回 <code>fn main() {</code> と書くのは長ったらしいのでこれ以後は省略します。
もし試しながら読んでいるのならそのまま書くのではなくちゃんと <code>main()</code> 関数の中身を編集するようにしてください。そうしないとエラーになります。</p>

<!-- # Patterns -->

<h1 id='パターン' class='section-header'><a href='#パターン'>パターン</a></h1>
<!-- In many languages, a variable binding would be called a *variable*, but Rust’s -->

<!-- variable bindings have a few tricks up their sleeves. For example the -->

<!-- left-hand side of a `let` statement is a ‘[pattern][pattern]’, not just a -->

<!-- variable name. This means we can do things like: -->

<p>多くの言語では変数束縛は <em>変数</em> と呼ばれるでしょうが、Rustの変数束縛は多少皮を被せてあります。
例えば、 <code>let</code> 文の左側は「<a href="patterns.html">パターン</a>」であって、ただの変数名ではありません。
これはこのようなことができるということです。</p>

<span class='rusttest'>fn main() {
    let (x, y) = (1, 2);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>);</pre>

<!-- After this statement is evaluated, `x` will be one, and `y` will be two. -->

<!-- Patterns are really powerful, and have [their own section][pattern] in the -->

<!-- book. We don’t need those features for now, so we’ll keep this in the back -->

<!-- of our minds as we go forward. -->

<p>この文が評価されたあと、 <code>x</code> は1になり、 <code>y</code> は2になります。
パターンは本当に強力で、本書には<a href="patterns.html">パターンのセクション</a>もあります。
今のところこの機能は必要ないので頭の片隅に留めておいてだけいてください。</p>

<!-- # Type annotations -->

<h1 id='型アノテーション' class='section-header'><a href='#型アノテーション'>型アノテーション</a></h1>
<!-- Rust is a statically typed language, which means that we specify our types up -->

<!-- front, and they’re checked at compile time. So why does our first example -->

<!-- compile? Well, Rust has this thing called ‘type inference’. If it can figure -->

<!-- out what the type of something is, Rust doesn’t require you to actually type it -->

<!-- out. -->

<p>Rustは静的な型付言語であり、前もって型を与えておいて、それがコンパイル時に検査されます。
じゃあなぜ最初の例はコンパイルが通るのでしょう?ええと、Rustには「型推論」と呼ばれるものがあります。
型推論が型が何であるか判断できるなら、型を書く必要はなくなります。</p>

<!-- We can add the type if we want to, though. Types come after a colon (`:`): -->

<p>書きたいなら型を書くこともできます。型はコロン(<code>:</code>)のあとに書きます。</p>

<span class='rusttest'>fn main() {
    let x: i32 = 5;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>5</span>;</pre>

<!-- If I asked you to read this out loud to the rest of the class, you’d say “`x` -->

<!-- is a binding with the type `i32` and the value `five`.” -->

<p>これをクラスのみんなに聞こえるように声に出して読むなら、「 <code>x</code> は型 <code>i32</code> を持つ束縛で、値は <code>五</code> である。」となります。</p>

<!-- In this case we chose to represent `x` as a 32-bit signed integer. Rust has -->

<!-- many different primitive integer types. They begin with `i` for signed integers -->

<!-- and `u` for unsigned integers. The possible integer sizes are 8, 16, 32, and 64 -->

<!-- bits. -->

<p>この場合 <code>x</code> を32bit符号付き整数として表現することを選びました。
Rustには多くのプリミティブな整数型があります。プリミティブな整数型は符号付き型は <code>i</code> 、符号無し型は <code>u</code> から始まります。
整数型として可能なサイズは8、16、32、64ビットです。</p>

<!-- In future examples, we may annotate the type in a comment. The examples will -->

<!-- look like this: -->

<p>以後の例では型はコメントで注釈することにします。
先の例はこのようになります。</p>

<span class='rusttest'>fn main() {
    let x = 5; // x: i32
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// x: i32</span>
}</pre>

<!-- Note the similarities between this annotation and the syntax you use with -->

<!-- `let`. Including these kinds of comments is not idiomatic Rust, but we'll -->

<!-- occasionally include them to help you understand what the types that Rust -->

<!-- infers are. -->

<p>この注釈と <code>let</code> の時に使う記法の類似性に留意してください。
このようなコメントを書くのはRust的ではありませんが、時折理解の手助けのためにRustが推論する型をコメントで注釈します。</p>

<!-- # Mutability -->

<h1 id='可変性' class='section-header'><a href='#可変性'>可変性</a></h1>
<!-- By default, bindings are *immutable*. This code will not compile: -->

<p>デフォルトで、 束縛は <em>イミュータブル</em> です。このコードのコンパイルは通りません。</p>

<span class='rusttest'>fn main() {
    let x = 5;
x = 10;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;</pre>

<!-- It will give you this error: -->

<p>次のようなエラーが出ます。</p>

<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>

<blockquote>
<p>訳注:
<code>エラー: イミュータブルな変数 `x` に再代入しています</code></p>
</blockquote>

<!-- If you want a binding to be mutable, you can use `mut`: -->

<p>束縛をミュータブルにしたいなら、<code>mut</code>が使えます。</p>

<span class='rusttest'>fn main() {
    let mut x = 5; // mut x: i32
x = 10;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// mut x: i32</span>
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;</pre>

<!-- There is no single reason that bindings are immutable by default, but we can -->

<!-- think about it through one of Rust’s primary focuses: safety. If you forget to -->

<!-- say `mut`, the compiler will catch it, and let you know that you have mutated -->

<!-- something you may not have intended to mutate. If bindings were mutable by -->

<!-- default, the compiler would not be able to tell you this. If you _did_ intend -->

<!-- mutation, then the solution is quite easy: add `mut`. -->

<p>束縛がデフォルトでイミュータブルであるのは複合的な理由によるものですが、Rustの主要な焦点、安全性の一環だと考えることができます。
もし <code>mut</code> を忘れたらコンパイラが捕捉して、変更するつもりでなかったものを変更した旨を教えてくれます。
束縛がデフォルトでミュータブルだったらコンパイラはこれを捕捉できません。
もし <em>本当に</em> 変更を意図していたのなら話は簡単です。 <code>mut</code> をつけ加えればいいのです。</p>

<!-- There are other good reasons to avoid mutable state when possible, but they’re -->

<!-- out of the scope of this guide. In general, you can often avoid explicit -->

<!-- mutation, and so it is preferable in Rust. That said, sometimes, mutation is -->

<!-- what you need, so it’s not verboten. -->

<p>可能な時にはミュータブルを避けた方が良い理由は他にもあるのですがそれはこのガイドの範囲を越えています。
一般に、明示的な変更は避けられることが多いのでRustでもそうした方が良いのです。
しかし変更が本当に必要なこともあるという意味で、厳禁という訳ではないのです。</p>

<!-- # Initializing bindings -->

<h1 id='束縛を初期化する' class='section-header'><a href='#束縛を初期化する'>束縛を初期化する</a></h1>
<!-- Rust variable bindings have one more aspect that differs from other languages: -->

<!-- bindings are required to be initialized with a value before you're allowed to -->

<!-- use them. -->

<p>Rustの束縛はもう1つ他の言語と異る点があります。束縛を使う前に値で初期化されている必要があるのです。</p>

<!-- Let’s try it out. Change your `src/main.rs` file to look like this: -->

<p>試してみましょう。 <code>src/main.rs</code> をいじってこのようにしてみてください。</p>

<span class='rusttest'>fn main() {
    let x: i32;

    println!(&quot;Hello world!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello world!&quot;</span>);
}</pre>

<!-- You can use `cargo build` on the command line to build it. You’ll get a -->

<!-- warning, but it will still print "Hello, world!": -->

<p>コマンドラインで <code>cargo build</code> を使ってビルドできます。
警告が出ますが、それでもまだ「Hello, world!」は表示されます。</p>

<pre><code class="language-text">   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>

<!-- Rust warns us that we never use the variable binding, but since we never use -->

<!-- it, no harm, no foul. Things change if we try to actually use this `x`, -->

<!-- however. Let’s do that. Change your program to look like this: -->

<p>Rustは一度も使われない変数について警告を出しますが、一度も使われないので人畜無害です。
ところがこの <code>x</code> を使おうとすると事は一変します。やってみましょう。
プログラムをこのように変更してください。</p>

<span class='rusttest'>fn main() {
    let x: i32;

    println!(&quot;The value of x is: {}&quot;, x);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The value of x is: {}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<!-- And try to build it. You’ll get an error: -->

<p>そしてビルドしてみてください。このようなエラーが出るはずです。</p>

<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;The value of x is: {}&quot;, x);
                                                    ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</code></pre>

<!-- Rust will not let us use a value that has not been initialized. Next, let’s -->

<!-- talk about this stuff we've added to `println!`. -->

<p>Rustでは未初期化の値を使うことは許されていません。
次に、 <code>println!</code> に追加したものについて話しましょう。</p>

<!-- If you include two curly braces (`{}`, some call them moustaches...) in your -->

<!-- string to print, Rust will interpret this as a request to interpolate some sort -->

<!-- of value. *String interpolation* is a computer science term that means "stick -->

<!-- in the middle of a string." We add a comma, and then `x`, to indicate that we -->

<!-- want `x` to be the value we’re interpolating. The comma is used to separate -->

<!-- arguments we pass to functions and macros, if you’re passing more than one. -->

<p>表示する文字列に2つの波括弧(<code>{}</code>、口髭という人もいます…(訳注: 海外の顔文字は横になっているので首を傾けて <code>{</code> を眺めてみてください。また、日本語だと「中括弧」と呼ぶ人もいますね))を入れました。
Rustはこれを、何かの値で補間(interpolate)してほしいのだと解釈します。
<em>文字列補間</em> (string interpolation)はコンピュータサイエンスの用語で、「文字列の間に差し込む」という意味です。
その後に続けてカンマ、そして <code>x</code> を置いて、 <code>x</code> が補間に使う値だと指示しています。
カンマは2つ以上の引数を関数やマクロに渡す時に使われます。</p>

<!-- When you use the curly braces, Rust will attempt to display the value in a -->

<!-- meaningful way by checking out its type. If you want to specify the format in a -->

<!-- more detailed manner, there are a [wide number of options available][format]. -->

<!-- For now, we'll stick to the default: integers aren't very complicated to -->

<!-- print. -->

<p>波括弧を使うと、Rustは補間に使う値の型を調べて意味のある方法で表示しようとします。
フォーマットをさらに詳しく指定したいなら<a href="../std/fmt/index.html">数多くのオプションが利用できます</a>。
とりあえずのところ、デフォルトに従いましょう。整数の表示はそれほど複雑ではありません。</p>

<!-- # Scope and shadowing -->

<h1 id='スコープとシャドーイング' class='section-header'><a href='#スコープとシャドーイング'>スコープとシャドーイング</a></h1>
<!-- Let’s get back to bindings. Variable bindings have a scope - they are -->

<!-- constrained to live in a block they were defined in. A block is a collection -->

<!-- of statements enclosed by `{` and `}`. Function definitions are also blocks! -->

<!-- In the following example we define two variable bindings, `x` and `y`, which -->

<!-- live in different blocks. `x` can be accessed from inside the `fn main() {}` -->

<!-- block, while `y` can be accessed only from inside the inner block: -->

<p>束縛に話を戻しましょう。変数束縛にはスコープがあります。変数束縛は定義されたブロック内でしか有効でありません。
ブロックは <code>{</code> と <code>}</code> に囲まれた文の集まりです。関数定義もブロックです!
以下の例では異なるブロックで有効な2つの変数束縛、 <code>x</code> と <code>y</code> を定義しています。
<code>x</code> は <code>fn main() {}</code> ブロックの中でアクセス可能ですが、 <code>y</code> は内側のブロックからのみアクセスできます。</p>

<span class='rusttest'>fn main() {
    let x: i32 = 17;
    {
        let y: i32 = 3;
        println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    }
//    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // This won&#39;t work
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // これは動きません
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>17</span>;
    {
        <span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>3</span>;
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The value of x is {} and value of y is {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
    }
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The value of x is {} and value of y is {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>); <span class='comment'>// これは動きません</span>
}</pre>

<!-- The first `println!` would print "The value of x is 17 and the value of y is -->

<!-- 3", but this example cannot be compiled successfully, because the second -->

<!-- `println!` cannot access the value of `y`, since it is not in scope anymore. -->

<!-- Instead we get this error: -->

<p>最初の <code>println!</code> は「The value of x is 17 and the value of y is 3」(訳注: 「xの値は17でyの値は3」)と表示するはずですが、
2つめの <code>println!</code> は <code>y</code> がもうスコープにいないため <code>y</code> にアクセスできないのでこの例はコンパイルできません。
代わりに以下のようなエラーが出ます。</p>

<pre><code class="language-bash">$ cargo build
   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)
main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]
main.rs:7     println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // これは動きません
                                                                       ^
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:56 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
main.rs:7:5: 7:65 note: expansion site
main.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
Could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>

<!-- Additionally, variable bindings can be shadowed. This means that a later -->

<!-- variable binding with the same name as another binding, that's currently in -->

<!-- scope, will override the previous binding. -->

<p>さらに加えて、変数束縛は覆い隠すことができます(訳注: このことをシャドーイングと言います)。
つまり後に出てくる同じ名前の変数束縛があるとそれがスコープに入り、以前の束縛を上書きするのです。</p>

<span class='rusttest'>fn main() {
    let x: i32 = 8;
{
//    println!(&quot;{}&quot;, x); // Prints &quot;8&quot;
    println!(&quot;{}&quot;, x); // &quot;8&quot;を表示する
    let x = 12;
//    println!(&quot;{}&quot;, x); // Prints &quot;12&quot;
    println!(&quot;{}&quot;, x); // &quot;12&quot;を表示する
}
// println!(&quot;{}&quot;, x); // Prints &quot;8&quot;
println!(&quot;{}&quot;, x); // &quot;8&quot;を表示する
let x =  42;
// println!(&quot;{}&quot;, x); // Prints &quot;42&quot;
println!(&quot;{}&quot;, x); // &quot;42&quot;を表示する
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>8</span>;
{
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); <span class='comment'>// &quot;8&quot;を表示する</span>
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>12</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); <span class='comment'>// &quot;12&quot;を表示する</span>
}
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); <span class='comment'>// &quot;8&quot;を表示する</span>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span>  <span class='number'>42</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); <span class='comment'>// &quot;42&quot;を表示する</span></pre>

<!-- Shadowing and mutable bindings may appear as two sides of the same coin, but -->

<!-- they are two distinct concepts that can't always be used interchangeably. For -->

<!-- one, shadowing enables us to rebind a name to a value of a different type. It -->

<!-- is also possible to change the mutability of a binding. -->

<p>シャドーイングとミュータブルな束縛はコインの表と裏のように見えるかもしれませんが、それぞれ独立な概念であり互いに代用ができないケースがあります。
その1つにシャドーイングは同じ名前に違う型の値を再束縛することができます。</p>

<span class='rusttest'>fn main() {
    let mut x: i32 = 1;
x = 7;
// let x = x; // x is now immutable and is bound to 7
let x = x; // xはイミュータブルになって7に束縛されました

let y = 4;
// let y = &quot;I can also be bound to text!&quot;; // y is now of a different type
let y = &quot;I can also be bound to text!&quot;; // yは違う型になりました
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='number'>1</span>;
<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>7</span>;
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// xはイミュータブルになって7に束縛されました</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>4</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='string'>&quot;I can also be bound to text!&quot;</span>; <span class='comment'>// yは違う型になりました</span></pre>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>