<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Splitting Borrows</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='meet-safe-and-unsafe.html'><b>2.</b> Meet Safe and Unsafe</a>
<ul class='section'>
<li><a  href='safe-unsafe-meaning.html'><b>2.1.</b> How Safe and Unsafe Interact</a>
</li>
<li><a  href='working-with-unsafe.html'><b>2.2.</b> Working with Unsafe</a>
</li>
</ul>
</li>
<li><a  href='data.html'><b>3.</b> Data Layout</a>
<ul class='section'>
<li><a  href='repr-rust.html'><b>3.1.</b> repr(Rust)</a>
</li>
<li><a  href='exotic-sizes.html'><b>3.2.</b> Exotically Sized Types</a>
</li>
<li><a  href='other-reprs.html'><b>3.3.</b> Other reprs</a>
</li>
</ul>
</li>
<li><a  href='ownership.html'><b>4.</b> Ownership</a>
<ul class='section'>
<li><a  href='references.html'><b>4.1.</b> References</a>
</li>
<li><a  href='lifetimes.html'><b>4.2.</b> Lifetimes</a>
</li>
<li><a  href='lifetime-mismatch.html'><b>4.3.</b> Limits of Lifetimes</a>
</li>
<li><a  href='lifetime-elision.html'><b>4.4.</b> Lifetime Elision</a>
</li>
<li><a  href='unbounded-lifetimes.html'><b>4.5.</b> Unbounded Lifetimes</a>
</li>
<li><a  href='hrtb.html'><b>4.6.</b> Higher-Rank Trait Bounds</a>
</li>
<li><a  href='subtyping.html'><b>4.7.</b> Subtyping and Variance</a>
</li>
<li><a  href='dropck.html'><b>4.8.</b> Drop Check</a>
</li>
<li><a  href='phantom-data.html'><b>4.9.</b> PhantomData</a>
</li>
<li><a class='active' href='borrow-splitting.html'><b>4.10.</b> Splitting Borrows</a>
</li>
</ul>
</li>
<li><a  href='conversions.html'><b>5.</b> Type Conversions</a>
<ul class='section'>
<li><a  href='coercions.html'><b>5.1.</b> Coercions</a>
</li>
<li><a  href='dot-operator.html'><b>5.2.</b> The Dot Operator</a>
</li>
<li><a  href='casts.html'><b>5.3.</b> Casts</a>
</li>
<li><a  href='transmutes.html'><b>5.4.</b> Transmutes</a>
</li>
</ul>
</li>
<li><a  href='uninitialized.html'><b>6.</b> Uninitialized Memory</a>
<ul class='section'>
<li><a  href='checked-uninit.html'><b>6.1.</b> Checked</a>
</li>
<li><a  href='drop-flags.html'><b>6.2.</b> Drop Flags</a>
</li>
<li><a  href='unchecked-uninit.html'><b>6.3.</b> Unchecked</a>
</li>
</ul>
</li>
<li><a  href='obrm.html'><b>7.</b> Ownership Based Resource Management</a>
<ul class='section'>
<li><a  href='constructors.html'><b>7.1.</b> Constructors</a>
</li>
<li><a  href='destructors.html'><b>7.2.</b> Destructors</a>
</li>
<li><a  href='leaking.html'><b>7.3.</b> Leaking</a>
</li>
</ul>
</li>
<li><a  href='unwinding.html'><b>8.</b> Unwinding</a>
<ul class='section'>
<li><a  href='exception-safety.html'><b>8.1.</b> Exception Safety</a>
</li>
<li><a  href='poisoning.html'><b>8.2.</b> Poisoning</a>
</li>
</ul>
</li>
<li><a  href='concurrency.html'><b>9.</b> Concurrency</a>
<ul class='section'>
<li><a  href='races.html'><b>9.1.</b> Races</a>
</li>
<li><a  href='send-and-sync.html'><b>9.2.</b> Send and Sync</a>
</li>
<li><a  href='atomics.html'><b>9.3.</b> Atomics</a>
</li>
</ul>
</li>
<li><a  href='vec.html'><b>10.</b> Implementing Vec</a>
<ul class='section'>
<li><a  href='vec-layout.html'><b>10.1.</b> Layout</a>
</li>
<li><a  href='vec-alloc.html'><b>10.2.</b> Allocating</a>
</li>
<li><a  href='vec-push-pop.html'><b>10.3.</b> Push and Pop</a>
</li>
<li><a  href='vec-dealloc.html'><b>10.4.</b> Deallocating</a>
</li>
<li><a  href='vec-deref.html'><b>10.5.</b> Deref</a>
</li>
<li><a  href='vec-insert-remove.html'><b>10.6.</b> Insert and Remove</a>
</li>
<li><a  href='vec-into-iter.html'><b>10.7.</b> IntoIter</a>
</li>
<li><a  href='vec-raw.html'><b>10.8.</b> RawVec</a>
</li>
<li><a  href='vec-drain.html'><b>10.9.</b> Drain</a>
</li>
<li><a  href='vec-zsts.html'><b>10.10.</b> Handling Zero-Sized Types</a>
</li>
<li><a  href='vec-final.html'><b>10.11.</b> Final Code</a>
</li>
</ul>
</li>
<li><a  href='arc-and-mutex.html'><b>11.</b> Implementing Arc and Mutex</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Splitting Borrows</h1>
    <p>The mutual exclusion property of mutable references can be very limiting when
working with a composite structure. The borrow checker understands some basic
stuff, but will fall over pretty easily. It does understand structs
sufficiently to know that it&#39;s possible to borrow disjoint fields of a struct
simultaneously. So this works today:</p>

<span class='rusttest'>fn main() {
    struct Foo {
    a: i32,
    b: i32,
    c: i32,
}

let mut x = Foo {a: 0, b: 0, c: 0};
let a = &amp;mut x.a;
let b = &amp;mut x.b;
let c = &amp;x.c;
*b += 1;
let c2 = &amp;x.c;
*a += 10;
println!(&quot;{} {} {} {}&quot;, a, b, c, c2);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>i32</span>,
    <span class='ident'>b</span>: <span class='ident'>i32</span>,
    <span class='ident'>c</span>: <span class='ident'>i32</span>,
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Foo</span> {<span class='ident'>a</span>: <span class='number'>0</span>, <span class='ident'>b</span>: <span class='number'>0</span>, <span class='ident'>c</span>: <span class='number'>0</span>};
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>.<span class='ident'>a</span>;
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>.<span class='ident'>b</span>;
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='ident'>c</span>;
<span class='op'>*</span><span class='ident'>b</span> <span class='op'>+=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>c2</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>.<span class='ident'>c</span>;
<span class='op'>*</span><span class='ident'>a</span> <span class='op'>+=</span> <span class='number'>10</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} {} {} {}&quot;</span>, <span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>, <span class='ident'>c2</span>);</pre>

<p>However borrowck doesn&#39;t understand arrays or slices in any way, so this doesn&#39;t
work:</p>

<span class='rusttest'>fn main() {
    let mut x = [1, 2, 3];
let a = &amp;mut x[0];
let b = &amp;mut x[1];
println!(&quot;{} {}&quot;, a, b);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>[<span class='number'>0</span>];
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>x</span>[<span class='number'>1</span>];
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} {}&quot;</span>, <span class='ident'>a</span>, <span class='ident'>b</span>);</pre>

<pre><code class="language-text">&lt;anon&gt;:4:14: 4:18 error: cannot borrow `x[..]` as mutable more than once at a time
&lt;anon&gt;:4 let b = &amp;mut x[1];
                      ^~~~
&lt;anon&gt;:3:14: 3:18 note: previous borrow of `x[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x[..]` until the borrow ends
&lt;anon&gt;:3 let a = &amp;mut x[0];
                      ^~~~
&lt;anon&gt;:6:2: 6:2 note: previous borrow ends here
&lt;anon&gt;:1 fn main() {
&lt;anon&gt;:2 let mut x = [1, 2, 3];
&lt;anon&gt;:3 let a = &amp;mut x[0];
&lt;anon&gt;:4 let b = &amp;mut x[1];
&lt;anon&gt;:5 println!(&quot;{} {}&quot;, a, b);
&lt;anon&gt;:6 }
         ^
error: aborting due to 2 previous errors
</code></pre>

<p>While it was plausible that borrowck could understand this simple case, it&#39;s
pretty clearly hopeless for borrowck to understand disjointness in general
container types like a tree, especially if distinct keys actually <em>do</em> map
to the same value.</p>

<p>In order to &quot;teach&quot; borrowck that what we&#39;re doing is ok, we need to drop down
to unsafe code. For instance, mutable slices expose a <code>split_at_mut</code> function
that consumes the slice and returns two mutable slices. One for everything to
the left of the index, and one for everything to the right. Intuitively we know
this is safe because the slices don&#39;t overlap, and therefore alias. However
the implementation requires some unsafety:</p>

<span class='rusttest'>fn main() {
    fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
    let len = self.len();
    let ptr = self.as_mut_ptr();
    assert!(mid &lt;= len);
    unsafe {
        (from_raw_parts_mut(ptr, mid),
         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>split_at_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>mid</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>], <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>T</span>]) {
    <span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>len</span>();
    <span class='kw'>let</span> <span class='ident'>ptr</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>as_mut_ptr</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>mid</span> <span class='op'>&lt;=</span> <span class='ident'>len</span>);
    <span class='kw'>unsafe</span> {
        (<span class='ident'>from_raw_parts_mut</span>(<span class='ident'>ptr</span>, <span class='ident'>mid</span>),
         <span class='ident'>from_raw_parts_mut</span>(<span class='ident'>ptr</span>.<span class='ident'>offset</span>(<span class='ident'>mid</span> <span class='kw'>as</span> <span class='ident'>isize</span>), <span class='ident'>len</span> <span class='op'>-</span> <span class='ident'>mid</span>))
    }
}</pre>

<p>This is actually a bit subtle. So as to avoid ever making two <code>&amp;mut</code>&#39;s to the
same value, we explicitly construct brand-new slices through raw pointers.</p>

<p>However more subtle is how iterators that yield mutable references work.
The iterator trait is defined as follows:</p>

<span class='rusttest'>fn main() {
    trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Iterator</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span>;
}</pre>

<p>Given this definition, Self::Item has <em>no</em> connection to <code>self</code>. This means that
we can call <code>next</code> several times in a row, and hold onto all the results
<em>concurrently</em>. This is perfectly fine for by-value iterators, which have
exactly these semantics. It&#39;s also actually fine for shared references, as they
admit arbitrarily many references to the same thing (although the iterator needs
to be a separate object from the thing being shared).</p>

<p>But mutable references make this a mess. At first glance, they might seem
completely incompatible with this API, as it would produce multiple mutable
references to the same object!</p>

<p>However it actually <em>does</em> work, exactly because iterators are one-shot objects.
Everything an IterMut yields will be yielded at most once, so we don&#39;t
actually ever yield multiple mutable references to the same piece of data.</p>

<p>Perhaps surprisingly, mutable iterators don&#39;t require unsafe code to be
implemented for many types!</p>

<p>For instance here&#39;s a singly linked list:</p>

<span class='rusttest'>fn main() {}
type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct LinkedList&lt;T&gt; {
    head: Link&lt;T&gt;,
}

pub struct IterMut&lt;&#39;a, T: &#39;a&gt;(Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;);

impl&lt;T&gt; LinkedList&lt;T&gt; {
    fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut(self.head.as_mut().map(|node| &amp;mut **node))
    }
}

impl&lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; {
    type Item = &amp;&#39;a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node| {
            self.0 = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span>;

<span class='kw'>struct</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>elem</span>: <span class='ident'>T</span>,
    <span class='ident'>next</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>LinkedList</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>head</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>LinkedList</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>iter_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>IterMut</span>(<span class='self'>self</span>.<span class='ident'>head</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='op'>*</span><span class='ident'>node</span>))
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>take</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> {
            <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>=</span> <span class='ident'>node</span>.<span class='ident'>next</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='op'>*</span><span class='ident'>node</span>);
            <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>node</span>.<span class='ident'>elem</span>
        })
    }
}</pre>

<p>Here&#39;s a mutable slice:</p>

<span class='rusttest'>fn main() {}
use std::mem;

pub struct IterMut&lt;&#39;a, T: &#39;a&gt;(&amp;&#39;a mut[T]);

impl&lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; {
    type Item = &amp;&#39;a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::replace(&amp;mut self.0, &amp;mut []);
        if slice.is_empty() { return None; }

        let (l, r) = slice.split_at_mut(1);
        self.0 = r;
        l.get_mut(0)
    }
}

impl&lt;&#39;a, T&gt; DoubleEndedIterator for IterMut&lt;&#39;a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::replace(&amp;mut self.0, &amp;mut []);
        if slice.is_empty() { return None; }

        let new_len = slice.len() - 1;
        let (l, r) = slice.split_at_mut(new_len);
        self.0 = l;
        r.get_mut(0)
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span>[<span class='ident'>T</span>]);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>replace</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> []);
        <span class='kw'>if</span> <span class='ident'>slice</span>.<span class='ident'>is_empty</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span>; }

        <span class='kw'>let</span> (<span class='ident'>l</span>, <span class='ident'>r</span>) <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split_at_mut</span>(<span class='number'>1</span>);
        <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>=</span> <span class='ident'>r</span>;
        <span class='ident'>l</span>.<span class='ident'>get_mut</span>(<span class='number'>0</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>slice</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>replace</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='number'>0</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> []);
        <span class='kw'>if</span> <span class='ident'>slice</span>.<span class='ident'>is_empty</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span>; }

        <span class='kw'>let</span> <span class='ident'>new_len</span> <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>len</span>() <span class='op'>-</span> <span class='number'>1</span>;
        <span class='kw'>let</span> (<span class='ident'>l</span>, <span class='ident'>r</span>) <span class='op'>=</span> <span class='ident'>slice</span>.<span class='ident'>split_at_mut</span>(<span class='ident'>new_len</span>);
        <span class='self'>self</span>.<span class='number'>0</span> <span class='op'>=</span> <span class='ident'>l</span>;
        <span class='ident'>r</span>.<span class='ident'>get_mut</span>(<span class='number'>0</span>)
    }
}</pre>

<p>And here&#39;s a binary tree:</p>

<span class='rusttest'>fn main() {}
use std::collections::VecDeque;

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    left: Link&lt;T&gt;,
    right: Link&lt;T&gt;,
}

pub struct Tree&lt;T&gt; {
    root: Link&lt;T&gt;,
}

struct NodeIterMut&lt;&#39;a, T: &#39;a&gt; {
    elem: Option&lt;&amp;&#39;a mut T&gt;,
    left: Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;,
    right: Option&lt;&amp;&#39;a mut Node&lt;T&gt;&gt;,
}

enum State&lt;&#39;a, T: &#39;a&gt; {
    Elem(&amp;&#39;a mut T),
    Node(&amp;&#39;a mut Node&lt;T&gt;),
}

pub struct IterMut&lt;&#39;a, T: &#39;a&gt;(VecDeque&lt;NodeIterMut&lt;&#39;a, T&gt;&gt;);

impl&lt;T&gt; Tree&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        let mut deque = VecDeque::new();
        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));
        IterMut(deque)
    }
}

impl&lt;T&gt; Node&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; NodeIterMut&lt;T&gt; {
        NodeIterMut {
            elem: Some(&amp;mut self.elem),
            left: self.left.as_mut().map(|node| &amp;mut **node),
            right: self.right.as_mut().map(|node| &amp;mut **node),
        }
    }
}


impl&lt;&#39;a, T&gt; Iterator for NodeIterMut&lt;&#39;a, T&gt; {
    type Item = State&lt;&#39;a, T&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.left.take() {
            Some(node) =&gt; Some(State::Node(node)),
            None =&gt; match self.elem.take() {
                Some(elem) =&gt; Some(State::Elem(elem)),
                None =&gt; match self.right.take() {
                    Some(node) =&gt; Some(State::Node(node)),
                    None =&gt; None,
                }
            }
        }
    }
}

impl&lt;&#39;a, T&gt; DoubleEndedIterator for NodeIterMut&lt;&#39;a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.right.take() {
            Some(node) =&gt; Some(State::Node(node)),
            None =&gt; match self.elem.take() {
                Some(elem) =&gt; Some(State::Elem(elem)),
                None =&gt; match self.left.take() {
                    Some(node) =&gt; Some(State::Node(node)),
                    None =&gt; None,
                }
            }
        }
    }
}

impl&lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; {
    type Item = &amp;&#39;a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.front_mut().and_then(|node_it| node_it.next()) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_front(node.iter_mut()),
                None =&gt; if let None = self.0.pop_front() { return None },
            }
        }
    }
}

impl&lt;&#39;a, T&gt; DoubleEndedIterator for IterMut&lt;&#39;a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_back(node.iter_mut()),
                None =&gt; if let None = self.0.pop_back() { return None },
            }
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>VecDeque</span>;

<span class='kw'>type</span> <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span><span class='op'>&gt;</span>;

<span class='kw'>struct</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>elem</span>: <span class='ident'>T</span>,
    <span class='ident'>left</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
    <span class='ident'>right</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Tree</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>root</span>: <span class='ident'>Link</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>,
}

<span class='kw'>struct</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>elem</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span><span class='op'>&gt;</span>,
    <span class='ident'>left</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>,
    <span class='ident'>right</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>,
}

<span class='kw'>enum</span> <span class='ident'>State</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>Elem</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>),
    <span class='ident'>Node</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>),
}

<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>VecDeque</span><span class='op'>&lt;</span><span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;&gt;</span>);

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Tree</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>iter_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>deque</span> <span class='op'>=</span> <span class='ident'>VecDeque</span>::<span class='ident'>new</span>();
        <span class='self'>self</span>.<span class='ident'>root</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>root</span><span class='op'>|</span> <span class='ident'>deque</span>.<span class='ident'>push_front</span>(<span class='ident'>root</span>.<span class='ident'>iter_mut</span>()));
        <span class='ident'>IterMut</span>(<span class='ident'>deque</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Node</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>iter_mut</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='ident'>NodeIterMut</span> {
            <span class='ident'>elem</span>: <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>.<span class='ident'>elem</span>),
            <span class='ident'>left</span>: <span class='self'>self</span>.<span class='ident'>left</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='op'>*</span><span class='ident'>node</span>),
            <span class='ident'>right</span>: <span class='self'>self</span>.<span class='ident'>right</span>.<span class='ident'>as_mut</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>node</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='op'>*</span><span class='op'>*</span><span class='ident'>node</span>),
        }
    }
}


<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='ident'>State</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span>;

    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>left</span>.<span class='ident'>take</span>() {
            <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>elem</span>.<span class='ident'>take</span>() {
                <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>right</span>.<span class='ident'>take</span>() {
                    <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
                    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
                }
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>NodeIterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>right</span>.<span class='ident'>take</span>() {
            <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>elem</span>.<span class='ident'>take</span>() {
                <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>left</span>.<span class='ident'>take</span>() {
                    <span class='prelude-val'>Some</span>(<span class='ident'>node</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)),
                    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
                }
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Iterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>Item</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>next</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>loop</span> {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>front_mut</span>().<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>node_it</span><span class='op'>|</span> <span class='ident'>node_it</span>.<span class='ident'>next</span>()) {
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>),
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>push_front</span>(<span class='ident'>node</span>.<span class='ident'>iter_mut</span>()),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>None</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>pop_front</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span> },
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>DoubleEndedIterator</span> <span class='kw'>for</span> <span class='ident'>IterMut</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>next_back</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='self'>Self</span>::<span class='ident'>Item</span><span class='op'>&gt;</span> {
        <span class='kw'>loop</span> {
            <span class='kw'>match</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>back_mut</span>().<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>node_it</span><span class='op'>|</span> <span class='ident'>node_it</span>.<span class='ident'>next_back</span>()) {
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Elem</span>(<span class='ident'>elem</span>)) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Some</span>(<span class='ident'>elem</span>),
                <span class='prelude-val'>Some</span>(<span class='ident'>State</span>::<span class='ident'>Node</span>(<span class='ident'>node</span>)) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>push_back</span>(<span class='ident'>node</span>.<span class='ident'>iter_mut</span>()),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>None</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>pop_back</span>() { <span class='kw'>return</span> <span class='prelude-val'>None</span> },
            }
        }
    }
}</pre>

<p>All of these are completely safe and work on stable Rust! This ultimately
falls out of the simple struct case we saw before: Rust understands that you
can safely split a mutable reference into subfields. We can then encode
permanently consuming a reference via Options (or in the case of slices,
replacing with an empty slice).</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>