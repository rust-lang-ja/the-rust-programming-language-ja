<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Let binding</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../style/README.html'><b>2.</b> Style</a>
<ul class='section'>
<li><a  href='../style/whitespace.html'><b>2.1.</b> Whitespace</a>
</li>
<li><a  href='../style/comments.html'><b>2.2.</b> Comments</a>
</li>
<li><a  href='../style/braces.html'><b>2.3.</b> Braces, semicolons, commas</a>
</li>
<li><a  href='../style/naming/README.html'><b>2.4.</b> Naming</a>
<ul class='section'>
<li><a  href='../style/naming/ownership.html'><b>2.4.1.</b> Ownership variants</a>
</li>
<li><a  href='../style/naming/containers.html'><b>2.4.2.</b> Containers/wrappers</a>
</li>
<li><a  href='../style/naming/conversions.html'><b>2.4.3.</b> Conversions</a>
</li>
<li><a  href='../style/naming/iterators.html'><b>2.4.4.</b> Iterators</a>
</li>
</ul>
</li>
<li><a  href='../style/imports.html'><b>2.5.</b> Imports</a>
</li>
<li><a  href='../style/organization.html'><b>2.6.</b> Organization</a>
</li>
</ul>
</li>
<li><a  href='../features/README.html'><b>3.</b> Guidelines by Rust feature</a>
<ul class='section'>
<li><a class='active' href='../features/let.html'><b>3.1.</b> Let binding</a>
</li>
<li><a  href='../features/match.html'><b>3.2.</b> Pattern matching</a>
</li>
<li><a  href='../features/loops.html'><b>3.3.</b> Loops</a>
</li>
<li><a  href='../features/functions-and-methods/README.html'><b>3.4.</b> Functions and methods</a>
<ul class='section'>
<li><a  href='../features/functions-and-methods/input.html'><b>3.4.1.</b> Input</a>
</li>
<li><a  href='../features/functions-and-methods/output.html'><b>3.4.2.</b> Output</a>
</li>
<li><a  href='../features/functions-and-methods/convenience.html'><b>3.4.3.</b> For convenience</a>
</li>
</ul>
</li>
<li><a  href='../features/types/README.html'><b>3.5.</b> Types</a>
<ul class='section'>
<li><a  href='../features/types/conversions.html'><b>3.5.1.</b> Conversions</a>
</li>
<li><a  href='../features/types/newtype.html'><b>3.5.2.</b> The newtype pattern</a>
</li>
</ul>
</li>
<li><a  href='../features/traits/README.html'><b>3.6.</b> Traits</a>
<ul class='section'>
<li><a  href='../features/traits/generics.html'><b>3.6.1.</b> For generics</a>
</li>
<li><a  href='../features/traits/objects.html'><b>3.6.2.</b> For objects</a>
</li>
<li><a  href='../features/traits/overloading.html'><b>3.6.3.</b> For overloading</a>
</li>
<li><a  href='../features/traits/extensions.html'><b>3.6.4.</b> For extensions</a>
</li>
<li><a  href='../features/traits/reuse.html'><b>3.6.5.</b> For reuse</a>
</li>
<li><a  href='../features/traits/common.html'><b>3.6.6.</b> Common traits</a>
</li>
</ul>
</li>
<li><a  href='../features/modules.html'><b>3.7.</b> Modules</a>
</li>
<li><a  href='../features/crates.html'><b>3.8.</b> Crates</a>
</li>
</ul>
</li>
<li><a  href='../ownership/README.html'><b>4.</b> Ownership and resources</a>
<ul class='section'>
<li><a  href='../ownership/constructors.html'><b>4.1.</b> Constructors</a>
</li>
<li><a  href='../ownership/builders.html'><b>4.2.</b> Builders</a>
</li>
<li><a  href='../ownership/destructors.html'><b>4.3.</b> Destructors</a>
</li>
<li><a  href='../ownership/raii.html'><b>4.4.</b> RAII</a>
</li>
<li><a  href='../ownership/cell-smart.html'><b>4.5.</b> Cells and smart pointers</a>
</li>
</ul>
</li>
<li><a  href='../errors/README.html'><b>5.</b> Errors</a>
<ul class='section'>
<li><a  href='../errors/signaling.html'><b>5.1.</b> Signaling</a>
</li>
<li><a  href='../errors/handling.html'><b>5.2.</b> Handling</a>
</li>
<li><a  href='../errors/propagation.html'><b>5.3.</b> Propagation</a>
</li>
<li><a  href='../errors/ergonomics.html'><b>5.4.</b> Ergonomics</a>
</li>
</ul>
</li>
<li><a  href='../safety/README.html'><b>6.</b> Safety and guarantees</a>
<ul class='section'>
<li><a  href='../safety/unsafe.html'><b>6.1.</b> Using unsafe</a>
</li>
<li><a  href='../safety/lib-guarantees.html'><b>6.2.</b> Library guarantees</a>
</li>
</ul>
</li>
<li><a  href='../testing/README.html'><b>7.</b> Testing</a>
<ul class='section'>
<li><a  href='../testing/unit.html'><b>7.1.</b> Unit testing</a>
</li>
</ul>
</li>
<li><a  href='../platform.html'><b>8.</b> FFI, platform-specific code</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Let binding</h1>
    
<h3 id='always-separately-bind-raii-guards-fixme-needs-rfc' class='section-header'><a href='#always-separately-bind-raii-guards-fixme-needs-rfc'>Always separately bind RAII guards. [FIXME: needs RFC]</a></h3>
<p>Prefer</p>

<span class='rusttest'>fn main() {
    fn use_mutex(m: sync::mutex::Mutex&lt;i32&gt;) {
    let guard = m.lock();
    do_work(guard);
    drop(guard); // unlock the lock
    // do other work
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>use_mutex</span>(<span class='ident'>m</span>: <span class='ident'>sync</span>::<span class='ident'>mutex</span>::<span class='ident'>Mutex</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='ident'>guard</span> <span class='op'>=</span> <span class='ident'>m</span>.<span class='ident'>lock</span>();
    <span class='ident'>do_work</span>(<span class='ident'>guard</span>);
    <span class='ident'>drop</span>(<span class='ident'>guard</span>); <span class='comment'>// unlock the lock</span>
    <span class='comment'>// do other work</span>
}</pre>

<p>over</p>

<span class='rusttest'>fn main() {
    fn use_mutex(m: sync::mutex::Mutex&lt;i32&gt;) {
    do_work(m.lock());
    // do other work
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>use_mutex</span>(<span class='ident'>m</span>: <span class='ident'>sync</span>::<span class='ident'>mutex</span>::<span class='ident'>Mutex</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>) {
    <span class='ident'>do_work</span>(<span class='ident'>m</span>.<span class='ident'>lock</span>());
    <span class='comment'>// do other work</span>
}</pre>

<p>As explained in the <a href="../ownership/raii.html">RAII guide</a>, RAII guards are values
that represent ownership of some resource and whose destructor releases the
resource. Because the lifetime of guards are significant, they should always be
explicitly <code>let</code>-bound to make the lifetime clear. Consider using an explicit
<code>drop</code> to release the resource early.</p>

<h3 id='prefer-conditional-expressions-to-deferred-initialization-fixme-needs-rfc' class='section-header'><a href='#prefer-conditional-expressions-to-deferred-initialization-fixme-needs-rfc'>Prefer conditional expressions to deferred initialization. [FIXME: needs RFC]</a></h3>
<p>Prefer</p>

<span class='rusttest'>fn main() {
    let foo = match bar {
    Baz =&gt; 0,
    Quux =&gt; 1
};
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>bar</span> {
    <span class='ident'>Baz</span> <span class='op'>=&gt;</span> <span class='number'>0</span>,
    <span class='ident'>Quux</span> <span class='op'>=&gt;</span> <span class='number'>1</span>
};</pre>

<p>over</p>

<span class='rusttest'>fn main() {
    let foo;
match bar {
    Baz =&gt; {
        foo = 0;
    }
    Quux =&gt; {
        foo = 1;
    }
}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>foo</span>;
<span class='kw'>match</span> <span class='ident'>bar</span> {
    <span class='ident'>Baz</span> <span class='op'>=&gt;</span> {
        <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>0</span>;
    }
    <span class='ident'>Quux</span> <span class='op'>=&gt;</span> {
        <span class='ident'>foo</span> <span class='op'>=</span> <span class='number'>1</span>;
    }
}</pre>

<p>unless the conditions for initialization are too complex to fit into a simple
conditional expression.</p>

<h3 id='use-type-annotations-for-clarification-prefer-explicit-generics-when-inference-fails-fixme-needs-rfc' class='section-header'><a href='#use-type-annotations-for-clarification-prefer-explicit-generics-when-inference-fails-fixme-needs-rfc'>Use type annotations for clarification; prefer explicit generics when inference fails. [FIXME: needs RFC]</a></h3>
<p>Prefer</p>

<span class='rusttest'>fn main() {
    let v = s.iter().map(|x| x * 2)
                .collect::&lt;Vec&lt;_&gt;&gt;();
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>)
                .<span class='ident'>collect</span>::<span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span>();</pre>

<p>over</p>

<span class='rusttest'>fn main() {
    let v: Vec&lt;_&gt; = s.iter().map(|x| x * 2)
                        .collect();
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>v</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span> <span class='op'>*</span> <span class='number'>2</span>)
                        .<span class='ident'>collect</span>();</pre>

<p>When the type of a value might be unclear to the <em>reader</em> of the code, consider
explicitly annotating it in a <code>let</code>.</p>

<p>On the other hand, when the type is unclear to the <em>compiler</em>, prefer to specify
the type by explicit generics instantiation, which is usually more clear.</p>

<h3 id='shadowing-fixme' class='section-header'><a href='#shadowing-fixme'>Shadowing [FIXME]</a></h3>
<blockquote>
<p><strong>[FIXME]</strong> Repeatedly shadowing a binding is somewhat common in Rust code. We
need to articulate a guideline on when it is appropriate/useful and when not.</p>
</blockquote>

<h3 id='prefer-immutable-bindings-fixme-needs-rfc' class='section-header'><a href='#prefer-immutable-bindings-fixme-needs-rfc'>Prefer immutable bindings. [FIXME: needs RFC]</a></h3>
<p>Use <code>mut</code> bindings to signal the span during which a value is mutated:</p>

<span class='rusttest'>fn main() {
    let mut v = Vec::new();
// push things onto v
let v = v;
// use v immutably henceforth
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='comment'>// push things onto v</span>
<span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='ident'>v</span>;
<span class='comment'>// use v immutably henceforth</span></pre>

<h3 id='prefer-to-bind-all-struct-or-tuple-fields-fixme-needs-rfc' class='section-header'><a href='#prefer-to-bind-all-struct-or-tuple-fields-fixme-needs-rfc'>Prefer to bind all <code>struct</code> or tuple fields. [FIXME: needs RFC]</a></h3>
<p>When consuming a <code>struct</code> or tuple via a <code>let</code>, bind all of the fields rather
than using <code>..</code> to elide the ones you don&#39;t need. The benefit is that when
fields are added, the compiler will pinpoint all of the places where that type
of value was consumed, which will often need to be adjusted to take the new
field properly into account.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>