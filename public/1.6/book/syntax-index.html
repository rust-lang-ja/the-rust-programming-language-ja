<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Syntax Index</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang Items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a class='active' href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Syntax Index</h1>
    
<h2 id='keywords' class='section-header'><a href='#keywords'>Keywords</a></h2>
<ul>
<li><code>as</code>: primitive casting.  See <a href="casting-between-types.html#as">Casting Between Types (<code>as</code>)</a>.</li>
<li><code>break</code>: break out of loop.  See <a href="loops.html#ending-iteration-early">Loops (Ending Iteration Early)</a>.</li>
<li><code>const</code>: constant items and constant raw pointers.  See <a href="const-and-static.html"><code>const</code> and <code>static</code></a>, <a href="raw-pointers.html">Raw Pointers</a>.</li>
<li><code>continue</code>: continue to next loop iteration.  See <a href="loops.html#ending-iteration-early">Loops (Ending Iteration Early)</a>.</li>
<li><code>crate</code>: external crate linkage.  See <a href="crates-and-modules.html#importing-external-crates">Crates and Modules (Importing External Crates)</a>.</li>
<li><code>else</code>: fallback for <code>if</code> and <code>if let</code> constructs.  See <a href="if.html"><code>if</code></a>, <a href="if-let.html"><code>if let</code></a>.</li>
<li><code>enum</code>: defining enumeration.  See <a href="enums.html">Enums</a>.</li>
<li><code>extern</code>: external crate, function, and variable linkage.  See <a href="crates-and-modules.html#importing-external-crates">Crates and Modules (Importing External Crates)</a>, <a href="ffi.html">Foreign Function Interface</a>.</li>
<li><code>false</code>: boolean false literal.  See <a href="primitive-types.html#booleans">Primitive Types (Booleans)</a>.</li>
<li><code>fn</code>: function definition and function pointer types.  See <a href="functions.html">Functions</a>.</li>
<li><code>for</code>: iterator loop, part of trait <code>impl</code> syntax, and higher-ranked lifetime syntax.  See <a href="loops.html#for">Loops (<code>for</code>)</a>, <a href="method-syntax.html">Method Syntax</a>.</li>
<li><code>if</code>: conditional branching.  See <a href="if.html"><code>if</code></a>, <a href="if-let.html"><code>if let</code></a>.</li>
<li><code>impl</code>: inherent and trait implementation blocks.  See <a href="method-syntax.html">Method Syntax</a>.</li>
<li><code>in</code>: part of <code>for</code> loop syntax.  See <a href="loops.html#for">Loops (<code>for</code>)</a>.</li>
<li><code>let</code>: variable binding.  See <a href="variable-bindings.html">Variable Bindings</a>.</li>
<li><code>loop</code>: unconditional, infinite loop.  See <a href="loops.html#loop">Loops (<code>loop</code>)</a>.</li>
<li><code>match</code>: pattern matching.  See <a href="match.html">Match</a>.</li>
<li><code>mod</code>: module declaration.  See <a href="crates-and-modules.html#defining-modules">Crates and Modules (Defining Modules)</a>.</li>
<li><code>move</code>: part of closure syntax.  See <a href="closures.html#move-closures">Closures (<code>move</code> closures)</a>.</li>
<li><code>mut</code>: denotes mutability in pointer types and pattern bindings.  See <a href="mutability.html">Mutability</a>.</li>
<li><code>pub</code>: denotes public visibility in <code>struct</code> fields, <code>impl</code> blocks, and modules.  See <a href="crates-and-modules.html#exporting-a-public-interface">Crates and Modules (Exporting a Public Interface)</a>.</li>
<li><code>ref</code>: by-reference binding.  See <a href="patterns.html#ref-and-ref-mut">Patterns (<code>ref</code> and <code>ref mut</code>)</a>.</li>
<li><code>return</code>: return from function.  See <a href="functions.html#early-returns">Functions (Early Returns)</a>.</li>
<li><code>Self</code>: implementor type alias.  See <a href="traits.html">Traits</a>.</li>
<li><code>self</code>: method subject.  See <a href="method-syntax.html#method-calls">Method Syntax (Method Calls)</a>.</li>
<li><code>static</code>: global variable.  See <a href="const-and-static.html#static"><code>const</code> and <code>static</code> (<code>static</code>)</a>.</li>
<li><code>struct</code>: structure definition.  See <a href="structs.html">Structs</a>.</li>
<li><code>trait</code>: trait definition.  See <a href="traits.html">Traits</a>.</li>
<li><code>true</code>: boolean true literal.  See <a href="primitive-types.html#booleans">Primitive Types (Booleans)</a>.</li>
<li><code>type</code>: type alias, and associated type definition.  See <a href="type-aliases.html"><code>type</code> Aliases</a>, <a href="associated-types.html">Associated Types</a>.</li>
<li><code>unsafe</code>: denotes unsafe code, functions, traits, and implementations.  See <a href="unsafe.html">Unsafe</a>.</li>
<li><code>use</code>: import symbols into scope.  See <a href="crates-and-modules.html#importing-modules-with-use">Crates and Modules (Importing Modules with <code>use</code>)</a>.</li>
<li><code>where</code>: type constraint clauses.  See <a href="traits.html#where-clause">Traits (<code>where</code> clause)</a>.</li>
<li><code>while</code>: conditional loop.  See <a href="loops.html#while">Loops (<code>while</code>)</a>.</li>
</ul>

<h2 id='operators-and-symbols' class='section-header'><a href='#operators-and-symbols'>Operators and Symbols</a></h2>
<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): denotes macro expansion.  See <a href="macros.html">Macros</a>.</li>
<li><code>!</code> (<code>!expr</code>): bitwise or logical complement.  Overloadable (<code>Not</code>).</li>
<li><code>%</code> (<code>expr % expr</code>): arithmetic remainder.  Overloadable (<code>Rem</code>).</li>
<li><code>%=</code> (<code>var %= expr</code>): arithmetic remainder &amp; assignment.</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>): bitwise and.  Overloadable (<code>BitAnd</code>).</li>
<li><code>&amp;</code> (<code>&amp;expr</code>): borrow.  See <a href="references-and-borrowing.html">References and Borrowing</a>.</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;&#39;a type</code>, <code>&amp;&#39;a mut type</code>): borrowed pointer type.  See <a href="references-and-borrowing.html">References and Borrowing</a>.</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): bitwise and &amp; assignment.</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): logical and.</li>
<li><code>*</code> (<code>expr * expr</code>): arithmetic multiplication.  Overloadable (<code>Mul</code>).</li>
<li><code>*</code> (<code>*expr</code>): dereference.</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): raw pointer.  See <a href="raw-pointers.html">Raw Pointers</a>.</li>
<li><code>*=</code> (<code>var *= expr</code>): arithmetic multiplication &amp; assignment.</li>
<li><code>+</code> (<code>expr + expr</code>): arithmetic addition.  Overloadable (<code>Add</code>).</li>
<li><code>+</code> (<code>trait + trait</code>, <code>&#39;a + trait</code>): compound type constraint.  See <a href="traits.html#multiple-trait-bounds">Traits (Multiple Trait Bounds)</a>.</li>
<li><code>+=</code> (<code>var += expr</code>): arithmetic addition &amp; assignment.</li>
<li><code>,</code>: argument and element separator.  See <a href="attributes.html">Attributes</a>, <a href="functions.html">Functions</a>, <a href="structs.html">Structs</a>, <a href="generics.html">Generics</a>, <a href="match.html">Match</a>, <a href="closures.html">Closures</a>, <a href="crates-and-modules.html#importing-modules-with-use">Crates and Modules (Importing Modules with <code>use</code>)</a>.</li>
<li><code>-</code> (<code>expr - expr</code>): arithmetic subtraction.  Overloadable (<code>Sub</code>).</li>
<li><code>-</code> (<code>- expr</code>): arithmetic negation.  Overloadable (<code>Neg</code>).</li>
<li><code>-=</code> (<code>var -= expr</code>): arithmetic subtraction &amp; assignment.</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): function and closure return type.  See <a href="functions.html">Functions</a>, <a href="closures.html">Closures</a>.</li>
<li><code>-&gt; !</code> (<code>fn(…) -&gt; !</code>, <code>|…| -&gt; !</code>): diverging function or closure. See <a href="functions.html#diverging-functions">Diverging Functions</a>.</li>
<li><code>.</code> (<code>expr.ident</code>): member access.  See <a href="structs.html">Structs</a>, <a href="method-syntax.html">Method Syntax</a>.</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): right-exclusive range literal.</li>
<li><code>..</code> (<code>..expr</code>): struct literal update syntax.  See <a href="structs.html#update-syntax">Structs (Update syntax)</a>.</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): &quot;and the rest&quot; pattern binding.  See <a href="patterns.html#ignoring-bindings">Patterns (Ignoring bindings)</a>.</li>
<li><code>...</code> (<code>expr ... expr</code>): inclusive range pattern.  See <a href="patterns.html#ranges">Patterns (Ranges)</a>.</li>
<li><code>/</code> (<code>expr / expr</code>): arithmetic division.  Overloadable (<code>Div</code>).</li>
<li><code>/=</code> (<code>var /= expr</code>): arithmetic division &amp; assignment.</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): constraints.  See <a href="variable-bindings.html">Variable Bindings</a>, <a href="functions.html">Functions</a>, <a href="structs.html">Structs</a>, <a href="traits.html">Traits</a>.</li>
<li><code>:</code> (<code>ident: expr</code>): struct field initializer.  See <a href="structs.html">Structs</a>.</li>
<li><code>:</code> (<code>&#39;a: loop {…}</code>): loop label.  See <a href="loops.html#loop-labels">Loops (Loops Labels)</a>.</li>
<li><code>;</code>: statement and item terminator.</li>
<li><code>;</code> (<code>[…; len]</code>): part of fixed-size array syntax.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): left-shift.  Overloadable (<code>Shl</code>).</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): left-shift &amp; assignment.</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): less-than comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>&lt;=</code> (<code>var &lt;= expr</code>): less-than or equal-to comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): assignment/equivalence.  See <a href="variable-bindings.html">Variable Bindings</a>, <a href="type-aliases.html"><code>type</code> Aliases</a>, generic parameter defaults.</li>
<li><code>==</code> (<code>var == expr</code>): comparison.  Overloadable (<code>Eq</code>, <code>PartialEq</code>).</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): part of match arm syntax.  See <a href="match.html">Match</a>.</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): greater-than comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>&gt;=</code> (<code>var &gt;= expr</code>): greater-than or equal-to comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): right-shift.  Overloadable (<code>Shr</code>).</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): right-shift &amp; assignment.</li>
<li><code>@</code> (<code>ident @ pat</code>): pattern binding.  See <a href="patterns.html#bindings">Patterns (Bindings)</a>.</li>
<li><code>^</code> (<code>expr ^ expr</code>): bitwise exclusive or.  Overloadable (<code>BitXor</code>).</li>
<li><code>^=</code> (<code>var ^= expr</code>): bitwise exclusive or &amp; assignment.</li>
<li><code>|</code> (<code>expr | expr</code>): bitwise or.  Overloadable (<code>BitOr</code>).</li>
<li><code>|</code> (<code>pat | pat</code>): pattern alternatives.  See <a href="patterns.html#multiple-patterns">Patterns (Multiple patterns)</a>.</li>
<li><code>|</code> (<code>|…| expr</code>): closures.  See <a href="closures.html">Closures</a>.</li>
<li><code>|=</code> (<code>var |= expr</code>): bitwise or &amp; assignment.</li>
<li><code>||</code> (<code>expr || expr</code>): logical or.</li>
<li><code>_</code>: &quot;ignored&quot; pattern binding.  See <a href="patterns.html#ignoring-bindings">Patterns (Ignoring bindings)</a>.</li>
</ul>

<h2 id='other-syntax' class='section-header'><a href='#other-syntax'>Other Syntax</a></h2>
<!-- Various bits of standalone stuff. -->

<ul>
<li><code>&#39;ident</code>: named lifetime or loop label.  See <a href="lifetimes.html">Lifetimes</a>, <a href="loops.html#loop-labels">Loops (Loops Labels)</a>.</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …: numeric literal of specific type.</li>
<li><code>&quot;…&quot;</code>: string literal.  See <a href="strings.html">Strings</a>.</li>
<li><code>r&quot;…&quot;</code>, <code>r#&quot;…&quot;#</code>, <code>r##&quot;…&quot;##</code>, …: raw string literal, escape characters are not processed. See <a href="../reference.html#raw-string-literals">Reference (Raw String Literals)</a>.</li>
<li><code>b&quot;…&quot;</code>: byte string literal, constructs a <code>[u8]</code> instead of a string. See <a href="../reference.html#byte-string-literals">Reference (Byte String Literals)</a>.</li>
<li><code>br&quot;…&quot;</code>, <code>br#&quot;…&quot;#</code>, <code>br##&quot;…&quot;##</code>, …: raw byte string literal, combination of raw and byte string literal. See <a href="../reference.html#raw-byte-string-literals">Reference (Raw Byte String Literals)</a>.</li>
<li><code>&#39;…&#39;</code>: character literal.  See <a href="primitive-types.html#char">Primitive Types (<code>char</code>)</a>.</li>
<li><code>b&#39;…&#39;</code>: ASCII byte literal.</li>
<li><code>|…| expr</code>: closure.  See <a href="closures.html">Closures</a>.</li>
</ul>

<!-- Path-related syntax -->

<ul>
<li><code>ident::ident</code>: path.  See <a href="crates-and-modules.html#defining-modules">Crates and Modules (Defining Modules)</a>.</li>
<li><code>::path</code>: path relative to the crate root (<em>i.e.</em> an explicitly absolute path).  See <a href="crates-and-modules.html#re-exporting-with-pub-use">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>self::path</code>: path relative to the current module (<em>i.e.</em> an explicitly relative path).  See <a href="crates-and-modules.html#re-exporting-with-pub-use">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>super::path</code>: path relative to the parent of the current module.  See <a href="crates-and-modules.html#re-exporting-with-pub-use">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>type::ident</code>: associated constants, functions, and types.  See <a href="associated-types.html">Associated Types</a>.</li>
<li><code>&lt;type&gt;::…</code>: associated item for a type which cannot be directly named (<em>e.g.</em> <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, <em>etc.</em>).  See <a href="associated-types.html">Associated Types</a>.</li>
</ul>

<!-- Generics -->

<ul>
<li><code>path&lt;…&gt;</code> (<em>e.g.</em> <code>Vec&lt;u8&gt;</code>): specifies parameters to generic type <em>in a type</em>.  See <a href="generics.html">Generics</a>.</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>e.g.</em> <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>): specifies parameters to generic type, function, or method <em>in an expression</em>.</li>
<li><code>fn ident&lt;…&gt; …</code>: define generic function.  See <a href="generics.html">Generics</a>.</li>
<li><code>struct ident&lt;…&gt; …</code>: define generic structure.  See <a href="generics.html">Generics</a>.</li>
<li><code>enum ident&lt;…&gt; …</code>: define generic enumeration.  See <a href="generics.html">Generics</a>.</li>
<li><code>impl&lt;…&gt; …</code>: define generic implementation.</li>
<li><code>for&lt;…&gt; type</code>: higher-ranked lifetime bounds.</li>
<li><code>type&lt;ident=type&gt;</code> (<em>e.g.</em> <code>Iterator&lt;Item=T&gt;</code>): a generic type where one or more associated types have specific assignments.  See <a href="associated-types.html">Associated Types</a>.</li>
</ul>

<!-- Constraints -->

<ul>
<li><code>T: U</code>: generic parameter <code>T</code> constrained to types that implement <code>U</code>.  See <a href="traits.html">Traits</a>.</li>
<li><code>T: &#39;a</code>: generic type <code>T</code> must outlive lifetime <code>&#39;a</code>.</li>
<li><code>&#39;b: &#39;a</code>: generic lifetime <code>&#39;b</code> must outlive lifetime <code>&#39;a</code>.</li>
<li><code>T: ?Sized</code>: allow generic type parameter to be a dynamically-sized type.  See <a href="unsized-types.html#?sized">Unsized Types (<code>?Sized</code>)</a>.</li>
<li><code>&#39;a + trait</code>, <code>trait + trait</code>: compound type constraint.  See <a href="traits.html#multiple-trait-bounds">Traits (Multiple Trait Bounds)</a>.</li>
</ul>

<!-- Macros and attributes -->

<ul>
<li><code>#[meta]</code>: outer attribute.  See <a href="attributes.html">Attributes</a>.</li>
<li><code>#![meta]</code>: inner attribute.  See <a href="attributes.html">Attributes</a>.</li>
<li><code>$ident</code>: macro substitution.  See <a href="macros.html">Macros</a>.</li>
<li><code>$ident:kind</code>: macro capture.  See <a href="macros.html">Macros</a>.</li>
<li><code>$(…)…</code>: macro repetition.  See <a href="macros.html">Macros</a>.</li>
</ul>

<!-- Comments -->

<ul>
<li><code>//</code>: line comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>//!</code>: inner line doc comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>///</code>: outer line doc comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>/*…*/</code>: block comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>/*!…*/</code>: inner block doc comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>/**…*/</code>: outer block doc comment.  See <a href="comments.html">Comments</a>.</li>
</ul>

<!-- Various things involving parens and tuples -->

<ul>
<li><code>()</code>: empty tuple (<em>a.k.a.</em> unit), both literal and type.</li>
<li><code>(expr)</code>: parenthesized expression.</li>
<li><code>(expr,)</code>: single-element tuple expression.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>(type,)</code>: single-element tuple type.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>(expr, …)</code>: tuple expression.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>(type, …)</code>: tuple type.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>expr(expr, …)</code>: function call expression.  Also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants.  See <a href="functions.html">Functions</a>.</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: macro invocation.  See <a href="macros.html">Macros</a>.</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: tuple indexing.  See <a href="primitive-types.html#tuple-indexing">Primitive Types (Tuple Indexing)</a>.</li>
</ul>

<!-- Bracey things -->

<ul>
<li><code>{…}</code>: block expression.</li>
<li><code>Type {…}</code>: <code>struct</code> literal.  See <a href="structs.html">Structs</a>.</li>
</ul>

<!-- Brackety things -->

<ul>
<li><code>[…]</code>: array literal.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>[expr; len]</code>: array literal containing <code>len</code> copies of <code>expr</code>.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>[type; len]</code>: array type containing <code>len</code> instances of <code>type</code>.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>expr[expr]</code>: collection indexing.  Overloadable (<code>Index</code>, <code>IndexMut</code>).</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, <code>RangeFull</code> as the &quot;index&quot;.</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>