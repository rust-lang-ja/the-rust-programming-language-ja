<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Strings</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 哲学者の晩餐</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> 生存期</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> 可変性</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a class='active' href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレイトとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`と`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ無し型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> イントリンシック</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語事項</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンク</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Strings</h1>
    <p>Strings are an important concept for any programmer to master. Rust’s string
handling system is a bit different from other languages, due to its systems
focus. Any time you have a data structure of variable size, things can get
tricky, and strings are a re-sizable data structure. That being said, Rust’s
strings also work differently than in some other systems languages, such as C.</p>

<p>Let’s dig into the details. A ‘string’ is a sequence of Unicode scalar values
encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid
encoding of UTF-8 sequences. Additionally, unlike some systems languages,
strings are not null-terminated and can contain null bytes.</p>

<p>Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let’s talk about
<code>&amp;str</code> first. These are called ‘string slices’. A string slice has a fixed
size, and cannot be mutated. It is a reference to a sequence of UTF-8 bytes.</p>
<span class='rusttest'>fn main() {
    let greeting = &quot;Hello there.&quot;; // greeting: &amp;&#39;static str
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>greeting</span> <span class='op'>=</span> <span class='string'>&quot;Hello there.&quot;</span>; <span class='comment'>// greeting: &amp;&#39;static str</span></pre>

<p><code>&quot;Hello there.&quot;</code> is a string literal and its type is <code>&amp;&#39;static str</code>. A string
literal is a string slice that is statically allocated, meaning that it’s saved
inside our compiled program, and exists for the entire duration it runs. The
<code>greeting</code> binding is a reference to this statically allocated string. Any
function expecting a string slice will also accept a string literal.</p>

<p>String literals can span multiple lines. There are two forms. The first will
include the newline and the leading spaces:</p>
<span class='rusttest'>fn main() {
    let s = &quot;foo
        bar&quot;;
    
    assert_eq!(&quot;foo\n        bar&quot;, s);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo
    bar&quot;</span>;

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;foo\n        bar&quot;</span>, <span class='ident'>s</span>);</pre>

<p>The second, with a <code>\</code>, trims the spaces and the newline:</p>
<span class='rusttest'>fn main() {
    let s = &quot;foo\
        bar&quot;; 
    
    assert_eq!(&quot;foobar&quot;, s);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;foo\
    bar&quot;</span>; 

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='string'>&quot;foobar&quot;</span>, <span class='ident'>s</span>);</pre>

<p>Rust has more than just <code>&amp;str</code>s though. A <code>String</code>, is a heap-allocated string.
This string is growable, and is also guaranteed to be UTF-8. <code>String</code>s are
commonly created by converting from a string slice using the <code>to_string</code>
method.</p>
<span class='rusttest'>fn main() {
    let mut s = &quot;Hello&quot;.to_string(); // mut s: String
    println!(&quot;{}&quot;, s);
    
    s.push_str(&quot;, world.&quot;);
    println!(&quot;{}&quot;, s);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>(); <span class='comment'>// mut s: String</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);

<span class='ident'>s</span>.<span class='ident'>push_str</span>(<span class='string'>&quot;, world.&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>s</span>);</pre>

<p><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>
<span class='rusttest'>fn takes_slice(slice: &amp;str) {
    println!(&quot;Got: {}&quot;, slice);
}

fn main() {
    let s = &quot;Hello&quot;.to_string();
    takes_slice(&amp;s);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>takes_slice</span>(<span class='ident'>slice</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Got: {}&quot;</span>, <span class='ident'>slice</span>);
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>.<span class='ident'>to_string</span>();
    <span class='ident'>takes_slice</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>);
}</pre>

<p>This coercion does not happen for functions that accept one of <code>&amp;str</code>’s traits
instead of <code>&amp;str</code>. For example, <a href="../std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> has a parameter
of type <code>ToSocketAddrs</code>. A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly
converted using <code>&amp;*</code>.</p>
<span class='rusttest'>fn main() {
    use std::net::TcpStream;
    
    TcpStream::connect(&quot;192.168.0.1:3000&quot;); // &amp;str parameter
    
    let addr_string = &quot;192.168.0.1:3000&quot;.to_string();
    TcpStream::connect(&amp;*addr_string); // convert addr_string to &amp;str
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>net</span>::<span class='ident'>TcpStream</span>;

<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='string'>&quot;192.168.0.1:3000&quot;</span>); <span class='comment'>// &amp;str parameter</span>

<span class='kw'>let</span> <span class='ident'>addr_string</span> <span class='op'>=</span> <span class='string'>&quot;192.168.0.1:3000&quot;</span>.<span class='ident'>to_string</span>();
<span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='ident'>addr_string</span>); <span class='comment'>// convert addr_string to &amp;str</span></pre>

<p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a
<code>String</code> involves allocating memory. No reason to do that unless you have to!</p>

<h2 id='indexing' class='section-header'><a href='#indexing'>Indexing</a></h2>
<p>Because strings are valid UTF-8, strings do not support indexing:</p>
<span class='rusttest'>fn main() {
    let s = &quot;hello&quot;;
    
    println!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;hello&quot;</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The first letter of s is {}&quot;</span>, <span class='ident'>s</span>[<span class='number'>0</span>]); <span class='comment'>// ERROR!!!</span></pre>

<p>Usually, access to a vector with <code>[]</code> is very fast. But, because each character
in a UTF-8 encoded string can be multiple bytes, you have to walk over the
string to find the nᵗʰ letter of a string. This is a significantly more
expensive operation, and we don’t want to be misleading. Furthermore, ‘letter’
isn’t something defined in Unicode, exactly. We can choose to look at a string as
individual bytes, or as codepoints:</p>
<span class='rusttest'>fn main() {
    let hachiko = &quot;忠犬ハチ公&quot;;
    
    for b in hachiko.as_bytes() {
        print!(&quot;{}, &quot;, b);
    }
    
    println!(&quot;&quot;);
    
    for c in hachiko.chars() {
        print!(&quot;{}, &quot;, c);
    }
    
    println!(&quot;&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hachiko</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;

<span class='kw'>for</span> <span class='ident'>b</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>as_bytes</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>b</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);

<span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}, &quot;</span>, <span class='ident'>c</span>);
}

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;&quot;</span>);</pre>

<p>This prints:</p>

<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
忠, 犬, ハ, チ, 公,
</code></pre>

<p>As you can see, there are more bytes than <code>char</code>s.</p>

<p>You can get something similar to an index like this:</p>
<span class='rusttest'>fn main() {
    let hachiko = &quot;忠犬ハチ公&quot;;
    let dog = hachiko.chars().nth(1); // kinda like hachiko[1]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='ident'>hachiko</span>.<span class='ident'>chars</span>().<span class='ident'>nth</span>(<span class='number'>1</span>); <span class='comment'>// kinda like hachiko[1]</span></pre>

<p>This emphasizes that we have to walk from the beginning of the list of <code>chars</code>.</p>

<h2 id='slicing' class='section-header'><a href='#slicing'>Slicing</a></h2>
<p>You can get a slice of a string with slicing syntax:</p>
<span class='rusttest'>fn main() {
    let dog = &quot;hachiko&quot;;
    let hachi = &amp;dog[0..5];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='string'>&quot;hachiko&quot;</span>;
<span class='kw'>let</span> <span class='ident'>hachi</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>dog</span>[<span class='number'>0</span>..<span class='number'>5</span>];</pre>

<p>But note that these are <em>byte</em> offsets, not <em>character</em> offsets. So
this will fail at runtime:</p>
<span class='rusttest'>fn main() {
    let dog = &quot;忠犬ハチ公&quot;;
    let hachi = &amp;dog[0..2];
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>dog</span> <span class='op'>=</span> <span class='string'>&quot;忠犬ハチ公&quot;</span>;
<span class='kw'>let</span> <span class='ident'>hachi</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>dog</span>[<span class='number'>0</span>..<span class='number'>2</span>];</pre>

<p>with this error:</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;index 0 and/or 2 in `忠犬ハチ公` do not lie on
character boundary&#39;
</code></pre>

<h2 id='concatenation' class='section-header'><a href='#concatenation'>Concatenation</a></h2>
<p>If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>
<span class='rusttest'>fn main() {
    let hello = &quot;Hello &quot;.to_string();
    let world = &quot;world!&quot;;
    
    let hello_world = hello + world;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='string'>&quot;world!&quot;</span>;

<span class='kw'>let</span> <span class='ident'>hello_world</span> <span class='op'>=</span> <span class='ident'>hello</span> <span class='op'>+</span> <span class='ident'>world</span>;</pre>

<p>But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>
<span class='rusttest'>fn main() {
    let hello = &quot;Hello &quot;.to_string();
    let world = &quot;world!&quot;.to_string();
    
    let hello_world = hello + &amp;world;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='string'>&quot;Hello &quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>world</span> <span class='op'>=</span> <span class='string'>&quot;world!&quot;</span>.<span class='ident'>to_string</span>();

<span class='kw'>let</span> <span class='ident'>hello_world</span> <span class='op'>=</span> <span class='ident'>hello</span> <span class='op'>+</span> <span class='kw-2'>&amp;</span><span class='ident'>world</span>;</pre>

<p>This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code>. This is a
feature called ‘<a href="deref-coercions.html"><code>Deref</code> coercions</a>’.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>