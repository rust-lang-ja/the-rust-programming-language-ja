<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>構造体</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 晩餐する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> 生存期</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> 可変性</a>
</li>
<li><a class='active' href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`と`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ無し型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> イントリンシック</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang Items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">構造体</h1>
    <!-- % Structs -->

<!-- `struct`s are a way of creating more complex data types. For example, if we were
doing calculations involving coordinates in 2D space, we would need both an `x`
and a `y` value: -->

<p><code>struct</code>はより複雑なデータ型を作る方法の1つです。例えば、もし私たちが2次元空間の座標に関する計算を行っているとして、<code>x</code>と<code>y</code>、両方の値が必要になるでしょう。</p>
<span class='rusttest'>fn main() {
    let origin_x = 0;
    let origin_y = 0;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>origin_x</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>origin_y</span> <span class='op'>=</span> <span class='number'>0</span>;</pre>

<!-- A `struct` lets us combine these two into a single, unified datatype: -->

<p><code>struct</code>でこれら2つを1つのデータ型にまとめることができます。</p>
<span class='rusttest'>struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!(&quot;The origin is at ({}, {})&quot;, origin.x, origin.y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> }; <span class='comment'>// origin: Point</span>

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The origin is at ({}, {})&quot;</span>, <span class='ident'>origin</span>.<span class='ident'>x</span>, <span class='ident'>origin</span>.<span class='ident'>y</span>);
}</pre>

<!-- There’s a lot going on here, so let’s break it down. We declare a `struct` with
the `struct` keyword, and then with a name. By convention, `struct`s begin with
a capital letter and are camel cased: `PointInSpace`, not `Point_In_Space`. -->

<p>ここで多くの情報が出てきましたから、順番に見ていきましょう。まず、<code>struct</code>キーワードを使って構造体とその名前を宣言しています。慣習により、構造体は初めが大文字のキャメルケースで記述しています。<code>PointInSpace</code>であり、<code>Point_In_Space</code>ではありません。</p>

<!-- We can create an instance of our `struct` via `let`, as usual, but we use a `key:
value` style syntax to set each field. The order doesn’t need to be the same as
in the original declaration. -->

<p>いつものように、<code>let</code>で<code>struct</code>のインスタンスを作ることができますが、ここでは<code>key: value</code>スタイルの構文でそれぞれのフィールドに値をセットしています。順序は元の宣言と同じである必要はありません。</p>

<!-- Finally, because fields have names, we can access the field through dot
notation: `origin.x`. -->

<p>最後に、作成された構造体のフィールドは名前を持つため、<code>origin.x</code>というようにドット表記でアクセスできます。</p>

<!-- The values in `struct`s are immutable by default, like other bindings in Rust.
Use `mut` to make them mutable -->

<p>Rustの他の束縛のように、<code>struct</code>が持つ値はイミュータブルがデフォルトです。<code>mut</code>を使うと値をミュータブルにできます。</p>
<span class='rusttest'>struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!(&quot;The point is at ({}, {})&quot;, point.x, point.y);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> };

    <span class='ident'>point</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The point is at ({}, {})&quot;</span>, <span class='ident'>point</span>.<span class='ident'>x</span>, <span class='ident'>point</span>.<span class='ident'>y</span>);
}</pre>

<!-- This will print `The point is at (5, 0)`. -->

<p>これは<code>The point is at (5, 0)</code>と出力されます。</p>

<!-- Rust does not support field mutability at the language level, so you cannot
write something like this: -->

<p>Rustは言語レベルでフィールドのミュータビリティに対応していないため、以下の様に書くことはできません。</p>
<span class='rusttest'>fn main() {
    struct Point {
        mut x: i32,
        y: i32,
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='kw-2'>mut</span> <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}</pre>

<!-- Mutability is a property of the binding, not of the structure itself. If you’re
used to field-level mutability, this may seem strange at first, but it
significantly simplifies things. It even lets you make things mutable for a short
time only: -->

<p>ミュータビリティは束縛に付与できる属性であり、構造体自体に付与できる属性ではありません。もしあなたがフィールドレベルのミュータビリティを使うのであれば、初めこそ奇妙に見えるものの、非常に簡単に実現できる方法があります。以下の方法で少しの間だけミュータブルな構造体を作ることができます。</p>
<span class='rusttest'>struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    let point = point; // この新しい束縛でここから変更できなくなります

    point.y = 6; // これはエラーになります
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span> };

    <span class='ident'>point</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

    <span class='kw'>let</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>point</span>; <span class='comment'>// この新しい束縛でここから変更できなくなります</span>

    <span class='ident'>point</span>.<span class='ident'>y</span> <span class='op'>=</span> <span class='number'>6</span>; <span class='comment'>// これはエラーになります</span>
}</pre>

<!-- # Update syntax -->

<h1 id='アップデート構文' class='section-header'><a href='#アップデート構文'>アップデート構文</a></h1>
<!-- A `struct` can include `..` to indicate that you want to use a copy of some
other `struct` for some of the values. For example: -->

<p><code>struct</code>の初期化時には、値の一部を他の構造体からコピーしたいことを示す<code>..</code>を含めることができます。例えば、</p>
<span class='rusttest'>fn main() {
    struct Point3d {
        x: i32,
        y: i32,
        z: i32,
    }
    
    let mut point = Point3d { x: 0, y: 0, z: 0 };
    point = Point3d { y: 1, .. point };
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Point3d</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
    <span class='ident'>z</span>: <span class='ident'>i32</span>,
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point3d</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span>, <span class='ident'>z</span>: <span class='number'>0</span> };
<span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point3d</span> { <span class='ident'>y</span>: <span class='number'>1</span>, .. <span class='ident'>point</span> };</pre>

<!-- This gives `point` a new `y`, but keeps the old `x` and `z` values. It doesn’t
have to be the same `struct` either, you can use this syntax when making new
ones, and it will copy the values you don’t specify:-->

<p>ここでは<code>point</code>に新しい<code>y</code>を与えていますが、<code>x</code>と<code>z</code>は古い値を維持します。どれかの<code>struct</code>と同じ値を作る他にも、この構文を新たな値の作成に使用でき、明示することなく値のコピーが行えます。</p>
<span class='rusttest'>fn main() {
    struct Point3d {
        x: i32,
        y: i32,
        z: i32,
    }
    let origin = Point3d { x: 0, y: 0, z: 0 };
    let point = Point3d { z: 1, x: 2, .. origin };
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point3d</span> { <span class='ident'>x</span>: <span class='number'>0</span>, <span class='ident'>y</span>: <span class='number'>0</span>, <span class='ident'>z</span>: <span class='number'>0</span> };
<span class='kw'>let</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='ident'>Point3d</span> { <span class='ident'>z</span>: <span class='number'>1</span>, <span class='ident'>x</span>: <span class='number'>2</span>, .. <span class='ident'>origin</span> };</pre>

<!-- # Tuple structs -->

<h1 id='タプル構造体' class='section-header'><a href='#タプル構造体'>タプル構造体</a></h1>
<!-- Rust has another data type that’s like a hybrid between a [tuple][tuple] and a
`struct`, called a ‘tuple struct’. Tuple structs have a name, but
their fields don’t:-->

<p>Rustには「タプル構造体」と呼ばれる、<a href="primitive-types.html#tuples">タプル</a>と<code>struct</code>のハイブリットのようなデータ型があります。タプル構造体自体には名前がありますが、そのフィールドには名前がありません。</p>
<span class='rusttest'>fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Color</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);
<span class='kw'>struct</span> <span class='ident'>Point</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>, <span class='ident'>i32</span>);</pre>

<!-- These two will not be equal, even if they have the same values: -->

<p>これら2つは同じ値を持つ同士であったとしても等しくありません。</p>
<span class='rusttest'>fn main() {
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>black</span> <span class='op'>=</span> <span class='ident'>Color</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span>(<span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>0</span>);</pre>

<!-- It is almost always better to use a `struct` than a tuple struct. We would write
`Color` and `Point` like this instead: -->

<p>ほとんどの場合タプル構造体よりも<code>struct</code>を使ったほうが良いです。<code>Color</code>や<code>Point</code>はこのようにも書けます。</p>
<span class='rusttest'>fn main() {
    struct Color {
        red: i32,
        blue: i32,
        green: i32,
    }
    
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Color</span> {
    <span class='ident'>red</span>: <span class='ident'>i32</span>,
    <span class='ident'>blue</span>: <span class='ident'>i32</span>,
    <span class='ident'>green</span>: <span class='ident'>i32</span>,
}

<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
    <span class='ident'>z</span>: <span class='ident'>i32</span>,
}</pre>

<!-- Now, we have actual names, rather than positions. Good names are important,
and with a `struct`, we have actual names. -->

<p>今、私たちはフィールドの位置ではなく実際のフィールドの名前を持っています。良い名前は重要で、<code>struct</code>を使うということは、実際に名前を持っているということです。</p>

<blockquote>
<p>訳注: 原文を元に噛み砕くと、「タプルはフィールドの並びによって区別され、構造体はフィールドの名前によって区別されます。これはタプルと構造体の最たる違いであり、構造体を持つことは名前を付けられたデータの集まりを持つことに等しいため、構造体における名前付けは重要です。」といった所でしょうか。</p>
</blockquote>

<!-- There _is_ one case when a tuple struct is very useful, though, and that’s a
tuple struct with only one element. We call this the ‘newtype’ pattern, because
it allows you to create a new type, distinct from that of its contained value
and expressing its own semantic meaning: -->

<p>タプル構造体が非常に便利な場合も_あります_が、1要素で使う場合だけです。タプル構造体の中に入っている値と、それ自体のセマンティックな表現を明確に区別できるような新しい型を作成できることから、私たちはこれを「newtype」パターンと呼んでいます。</p>
<span class='rusttest'>fn main() {
    struct Inches(i32);
    
    let length = Inches(10);
    
    let Inches(integer_length) = length;
    println!(&quot;length is {} inches&quot;, integer_length);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Inches</span>(<span class='ident'>i32</span>);

<span class='kw'>let</span> <span class='ident'>length</span> <span class='op'>=</span> <span class='ident'>Inches</span>(<span class='number'>10</span>);

<span class='kw'>let</span> <span class='ident'>Inches</span>(<span class='ident'>integer_length</span>) <span class='op'>=</span> <span class='ident'>length</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;length is {} inches&quot;</span>, <span class='ident'>integer_length</span>);</pre>

<!-- As you can see here, you can extract the inner integer type through a
destructuring `let`, just as with regular tuples. In this case, the
`let Inches(integer_length)` assigns `10` to `integer_length`. -->

<p>上記の通り、<code>let</code>を使って分解することで、標準のタプルと同じように内部の整数型を取り出すことができます。
このケースでは<code>let Inches(integer_length)</code>が<code>integer_length</code>へ<code>10</code>を束縛します。</p>

<h1 id='unit-like-構造体' class='section-header'><a href='#unit-like-構造体'>Unit-like 構造体</a></h1>
<!-- You can define a `struct` with no members at all: -->

<p>あなたは全くメンバを持たない<code>struct</code>を定義できます。</p>
<span class='rusttest'>fn main() {
    struct Electron;
    
    let x = Electron;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Electron</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Electron</span>;</pre>

<!-- Such a `struct` is called ‘unit-like’ because it resembles the empty
tuple, `()`, sometimes called ‘unit’. Like a tuple struct, it defines a
new type. -->

<p>空のタプルである<code>()</code>は時々<code>unit</code>と呼ばれ、それに似ていることからこのような構造体を<code>unit-like</code>と呼んでいます。タプル構造体のように、これは新しい型を定義します。</p>

<!-- This is rarely useful on its own (although sometimes it can serve as a
marker type), but in combination with other features, it can become
useful. For instance, a library may ask you to create a structure that
implements a certain [trait][trait] to handle events. If you don’t have
any data you need to store in the structure, you can just create a
unit-like `struct`. -->

<p>これは単体でもごくまれに役立ちます(もっとも、時々型をマーク代わりとして役立てる程度です)が、他の機能と組み合わせることにより便利になります。例えば、ライブラリはあなたにイベントを処理できる特定の<a href="traits.html">トレイト</a>が実装されたストラクチャの作成を要求するかもしれません。もしそのストラクチャの中に保存すべき値が何もなければ、あなたはダミーのデータを作成する必要はなく、ただunit-likeな<code>struct</code>を作るだけで良いのです。</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>