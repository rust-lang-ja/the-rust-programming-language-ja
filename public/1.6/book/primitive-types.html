<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Primitive Types</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> ã¯ã˜ã‚ã‚‹</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustã‚’å­¦ã¶</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> æ•°å½“ã¦ã‚²ãƒ¼ãƒ </a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> æ™©é¤ã™ã‚‹å“²å­¦è€…</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> ä»–è¨€èªã¨å…±å­˜ã™ã‚‹</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã¨ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> å¤‰æ•°æŸç¸›</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> é–¢æ•°</a>
</li>
<li><a class='active' href='primitive-types.html'><b>4.3.</b> ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> ã‚³ãƒ¡ãƒ³ãƒˆ</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ãƒ«ãƒ¼ãƒ—</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> æ‰€æœ‰æ¨©</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> å‚ç…§ã¨å€Ÿç”¨</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ç”Ÿå­˜æœŸ</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> å¯å¤‰æ€§</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> æ§‹é€ ä½“</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> åˆ—æŒ™å‹</a>
</li>
<li><a  href='match.html'><b>4.13.</b> ãƒãƒƒãƒ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> ãƒ‘ã‚¿ãƒ¼ãƒ³</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> ãƒ¡ã‚½ãƒƒãƒ‰æ§‹æ–‡</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ãƒ™ã‚¯ã‚¿</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> æ–‡å­—åˆ—</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> ãƒˆãƒ¬ã‚¤ãƒˆ</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> å…±é€šã®é–¢æ•°å‘¼å‡ºæ§‹æ–‡</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> ã‚¯ãƒ¬ã‚¤ãƒˆã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`ã¨`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆ</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`ã‚¨ã‚¤ãƒªã‚¢ã‚¹</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> å‹ã®ã‚­ãƒ£ã‚¹ãƒˆ</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> é–¢é€£å‹</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> ã‚µã‚¤ã‚ºç„¡ã—å‹</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> æ¼”ç®—å­ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefã«ã‚ˆã‚‹å‹å¼·åˆ¶</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> ãƒã‚¯ãƒ­</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> ç”Ÿãƒã‚¤ãƒ³ã‚¿</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> ã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> ãƒ†ã‚¹ãƒˆ</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> æ¡ä»¶ä»˜ãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> ä¸¦è¡Œ</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> ä¿è¨¼ã‚’é¸ã¶</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> Borrowã¨AsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> ãƒªãƒªãƒ¼ã‚¹ãƒãƒ£ãƒãƒ«</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç„¡ã—ã§Rustã‚’ä½¿ã†</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ—ãƒ©ã‚°ã‚¤ãƒ³</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¢ã‚»ãƒ³ãƒ–ãƒª</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> ã‚¤ãƒ³ãƒˆãƒªãƒ³ã‚·ãƒƒã‚¯</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> è¨€èªäº‹é …</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> é«˜åº¦ãªãƒªãƒ³ã‚¯</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Boxæ§‹æ–‡ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> ã‚¹ãƒ©ã‚¤ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> é–¢é€£å®šæ•°</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> ç”¨èªé›†</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> æ§‹æ–‡ã®ç´¢å¼•</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> é–¢ä¿‚æ›¸ç›®</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Primitive Types</h1>
    <p>The Rust language has a number of types that are considered â€˜primitiveâ€™. This
means that theyâ€™re built-in to the language. Rust is structured in such a way
that the standard library also provides a number of useful types built on top
of these ones, as well, but these are the most primitive.</p>

<h1 id='booleans' class='section-header'><a href='#booleans'>Booleans</a></h1>
<p>Rust has a built in boolean type, named <code>bool</code>. It has two values, <code>true</code> and <code>false</code>:</p>
<span class='rusttest'>fn main() {
    let x = true;
    
    let y: bool = false;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='boolval'>true</span>;

<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>bool</span> <span class='op'>=</span> <span class='boolval'>false</span>;</pre>

<p>A common use of booleans is in <a href="if.html"><code>if</code> conditionals</a>.</p>

<p>You can find more documentation for <code>bool</code>s <a href="../std/primitive.bool.html">in the standard library
documentation</a>.</p>

<h1 id='char' class='section-header'><a href='#char'><code>char</code></a></h1>
<p>The <code>char</code> type represents a single Unicode scalar value. You can create <code>char</code>s
with a single tick: (<code>&#39;</code>)</p>
<span class='rusttest'>fn main() {
    let x = &#39;x&#39;;
    let two_hearts = &#39;ğŸ’•&#39;;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='string'>&#39;x&#39;</span>;
<span class='kw'>let</span> <span class='ident'>two_hearts</span> <span class='op'>=</span> <span class='string'>&#39;ğŸ’•&#39;</span>;</pre>

<p>Unlike some other languages, this means that Rustâ€™s <code>char</code> is not a single byte,
but four.</p>

<p>You can find more documentation for <code>char</code>s <a href="../std/primitive.char.html">in the standard library
documentation</a>.</p>

<h1 id='numeric-types' class='section-header'><a href='#numeric-types'>Numeric types</a></h1>
<p>Rust has a variety of numeric types in a few categories: signed and unsigned,
fixed and variable, floating-point and integer.</p>

<p>These types consist of two parts: the category, and the size. For example,
<code>u16</code> is an unsigned type with sixteen bits of size. More bits lets you have
bigger numbers.</p>

<p>If a number literal has nothing to cause its type to be inferred, it defaults:</p>
<span class='rusttest'>fn main() {
    let x = 42; // x has type i32
    
    let y = 1.0; // y has type f64
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>42</span>; <span class='comment'>// x has type i32</span>

<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>1.0</span>; <span class='comment'>// y has type f64</span></pre>

<p>Hereâ€™s a list of the different numeric types, with links to their documentation
in the standard library:</p>

<ul>
<li><a href="../std/primitive.i8.html">i8</a></li>
<li><a href="../std/primitive.i16.html">i16</a></li>
<li><a href="../std/primitive.i32.html">i32</a></li>
<li><a href="../std/primitive.i64.html">i64</a></li>
<li><a href="../std/primitive.u8.html">u8</a></li>
<li><a href="../std/primitive.u16.html">u16</a></li>
<li><a href="../std/primitive.u32.html">u32</a></li>
<li><a href="../std/primitive.u64.html">u64</a></li>
<li><a href="../std/primitive.isize.html">isize</a></li>
<li><a href="../std/primitive.usize.html">usize</a></li>
<li><a href="../std/primitive.f32.html">f32</a></li>
<li><a href="../std/primitive.f64.html">f64</a></li>
</ul>

<p>Letâ€™s go over them by category:</p>

<h2 id='signed-and-unsigned' class='section-header'><a href='#signed-and-unsigned'>Signed and Unsigned</a></h2>
<p>Integer types come in two varieties: signed and unsigned. To understand the
difference, letâ€™s consider a number with four bits of size. A signed, four-bit
number would let you store numbers from <code>-8</code> to <code>+7</code>. Signed numbers use
â€œtwoâ€™s complement representationâ€. An unsigned four bit number, since it does
not need to store negatives, can store values from <code>0</code> to <code>+15</code>.</p>

<p>Unsigned types use a <code>u</code> for their category, and signed types use <code>i</code>. The <code>i</code>
is for â€˜integerâ€™. So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is an
eight-bit signed number.</p>

<h2 id='fixed-size-types' class='section-header'><a href='#fixed-size-types'>Fixed size types</a></h2>
<p>Fixed size types have a specific number of bits in their representation. Valid
bit sizes are <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code>. So, <code>u32</code> is an unsigned, 32-bit integer,
and <code>i64</code> is a signed, 64-bit integer.</p>

<h2 id='variable-sized-types' class='section-header'><a href='#variable-sized-types'>Variable sized types</a></h2>
<p>Rust also provides types whose size depends on the size of a pointer of the
underlying machine. These types have â€˜sizeâ€™ as the category, and come in signed
and unsigned varieties. This makes for two types: <code>isize</code> and <code>usize</code>.</p>

<h2 id='floating-point-types' class='section-header'><a href='#floating-point-types'>Floating-point types</a></h2>
<p>Rust also has two floating point types: <code>f32</code> and <code>f64</code>. These correspond to
IEEE-754 single and double precision numbers.</p>

<h1 id='arrays' class='section-header'><a href='#arrays'>Arrays</a></h1>
<p>Like many programming languages, Rust has list types to represent a sequence of
things. The most basic is the <em>array</em>, a fixed-size list of elements of the
same type. By default, arrays are immutable.</p>
<span class='rusttest'>fn main() {
    let a = [1, 2, 3]; // a: [i32; 3]
    let mut m = [1, 2, 3]; // m: [i32; 3]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// a: [i32; 3]</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]; <span class='comment'>// m: [i32; 3]</span></pre>

<p>Arrays have type <code>[T; N]</code>. Weâ€™ll talk about this <code>T</code> notation <a href="generics.html">in the generics
section</a>. The <code>N</code> is a compile-time constant, for the length of the
array.</p>

<p>Thereâ€™s a shorthand for initializing each element of an array to the same
value. In this example, each element of <code>a</code> will be initialized to <code>0</code>:</p>
<span class='rusttest'>fn main() {
    let a = [0; 20]; // a: [i32; 20]
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>; <span class='number'>20</span>]; <span class='comment'>// a: [i32; 20]</span></pre>

<p>You can get the number of elements in an array <code>a</code> with <code>a.len()</code>:</p>
<span class='rusttest'>fn main() {
    let a = [1, 2, 3];
    
    println!(&quot;a has {} elements&quot;, a.len());
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;a has {} elements&quot;</span>, <span class='ident'>a</span>.<span class='ident'>len</span>());</pre>

<p>You can access a particular element of an array with <em>subscript notation</em>:</p>
<span class='rusttest'>fn main() {
    let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]
    
    println!(&quot;The second name is: {}&quot;, names[1]);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>names</span> <span class='op'>=</span> [<span class='string'>&quot;Graydon&quot;</span>, <span class='string'>&quot;Brian&quot;</span>, <span class='string'>&quot;Niko&quot;</span>]; <span class='comment'>// names: [&amp;str; 3]</span>

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The second name is: {}&quot;</span>, <span class='ident'>names</span>[<span class='number'>1</span>]);</pre>

<p>Subscripts start at zero, like in most programming languages, so the first name
is <code>names[0]</code> and the second name is <code>names[1]</code>. The above example prints
<code>The second name is: Brian</code>. If you try to use a subscript that is not in the
array, you will get an error: array access is bounds-checked at run-time. Such
errant access is the source of many bugs in other systems programming
languages.</p>

<p>You can find more documentation for <code>array</code>s <a href="../std/primitive.array.html">in the standard library
documentation</a>.</p>

<h1 id='slices' class='section-header'><a href='#slices'>Slices</a></h1>
<p>A â€˜sliceâ€™ is a reference to (or â€œviewâ€ into) another data structure. They are
useful for allowing safe, efficient access to a portion of an array without
copying. For example, you might want to reference just one line of a file read
into memory. By nature, a slice is not created directly, but from an existing
variable binding. Slices have a defined length, can be mutable or immutable.</p>

<h2 id='slicing-syntax' class='section-header'><a href='#slicing-syntax'>Slicing syntax</a></h2>
<p>You can use a combo of <code>&amp;</code> and <code>[]</code> to create a slice from various things. The
<code>&amp;</code> indicates that slices are similar to references, and the <code>[]</code>s, with a
range, let you define the length of the slice:</p>
<span class='rusttest'>fn main() {
    let a = [0, 1, 2, 3, 4];
    let complete = &amp;a[..]; // A slice containing all of the elements in a
    let middle = &amp;a[1..4]; // A slice of a: just the elements 1, 2, and 3
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> [<span class='number'>0</span>, <span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>];
<span class='kw'>let</span> <span class='ident'>complete</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[..]; <span class='comment'>// A slice containing all of the elements in a</span>
<span class='kw'>let</span> <span class='ident'>middle</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>a</span>[<span class='number'>1</span>..<span class='number'>4</span>]; <span class='comment'>// A slice of a: just the elements 1, 2, and 3</span></pre>

<p>Slices have type <code>&amp;[T]</code>. Weâ€™ll talk about that <code>T</code> when we cover
<a href="generics.html">generics</a>.</p>

<p>You can find more documentation for slices <a href="../std/primitive.slice.html">in the standard library
documentation</a>.</p>

<h1 id='str' class='section-header'><a href='#str'><code>str</code></a></h1>
<p>Rustâ€™s <code>str</code> type is the most primitive string type. As an <a href="unsized-types.html">unsized type</a>,
itâ€™s not very useful by itself, but becomes useful when placed behind a reference,
like <a href="strings.html"><code>&amp;str</code></a>. As such, weâ€™ll just leave it at that.</p>

<p>You can find more documentation for <code>str</code> <a href="../std/primitive.str.html">in the standard library
documentation</a>.</p>

<h1 id='tuples' class='section-header'><a href='#tuples'>Tuples</a></h1>
<p>A tuple is an ordered list of fixed size. Like this:</p>
<span class='rusttest'>fn main() {
    let x = (1, &quot;hello&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);</pre>

<p>The parentheses and commas form this two-length tuple. Hereâ€™s the same code, but
with the type annotated:</p>
<span class='rusttest'>fn main() {
    let x: (i32, &amp;str) = (1, &quot;hello&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span>: (<span class='ident'>i32</span>, <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='string'>&quot;hello&quot;</span>);</pre>

<p>As you can see, the type of a tuple looks just like the tuple, but with each
position having a type name rather than the value. Careful readers will also
note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple.
In systems programming languages, strings are a bit more complex than in other
languages. For now, just read <code>&amp;str</code> as a <em>string slice</em>, and weâ€™ll learn more
soon.</p>

<p>You can assign one tuple into another, if they have the same contained types
and <a href="glossary.html#arity">arity</a>. Tuples have the same arity when they have the same length.</p>
<span class='rusttest'>fn main() {
    let mut x = (1, 2); // x: (i32, i32)
    let y = (2, 3); // y: (i32, i32)
    
    x = y;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>); <span class='comment'>// x: (i32, i32)</span>
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> (<span class='number'>2</span>, <span class='number'>3</span>); <span class='comment'>// y: (i32, i32)</span>

<span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>y</span>;</pre>

<p>You can access the fields in a tuple through a <em>destructuring let</em>. Hereâ€™s
an example:</p>
<span class='rusttest'>fn main() {
    let (x, y, z) = (1, 2, 3);
    
    println!(&quot;x is {}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>x</span>, <span class='ident'>y</span>, <span class='ident'>z</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Remember <a href="variable-bindings.html">before</a> when I said the left-hand side of a <code>let</code> statement was more
powerful than just assigning a binding? Here we are. We can put a pattern on
the left-hand side of the <code>let</code>, and if it matches up to the right-hand side,
we can assign multiple bindings at once. In this case, <code>let</code> â€œdestructuresâ€
or â€œbreaks upâ€ the tuple, and assigns the bits to three bindings.</p>

<p>This pattern is very powerful, and weâ€™ll see it repeated more later.</p>

<p>You can disambiguate a single-element tuple from a value in parentheses with a
comma:</p>
<span class='rusttest'>fn main() {
    (0,); // single-element tuple
    (0); // zero in parentheses
}</span><pre class='rust rust-example-rendered'>
(<span class='number'>0</span>,); <span class='comment'>// single-element tuple</span>
(<span class='number'>0</span>); <span class='comment'>// zero in parentheses</span></pre>

<h2 id='tuple-indexing' class='section-header'><a href='#tuple-indexing'>Tuple Indexing</a></h2>
<p>You can also access fields of a tuple with indexing syntax:</p>
<span class='rusttest'>fn main() {
    let tuple = (1, 2, 3);
    
    let x = tuple.0;
    let y = tuple.1;
    let z = tuple.2;
    
    println!(&quot;x is {}&quot;, x);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>tuple</span> <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>);

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>tuple</span>.<span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>tuple</span>.<span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>tuple</span>.<span class='number'>2</span>;

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x is {}&quot;</span>, <span class='ident'>x</span>);</pre>

<p>Like array indexing, it starts at zero, but unlike array indexing, it uses a
<code>.</code>, rather than <code>[]</code>s.</p>

<p>You can find more documentation for tuples <a href="../std/primitive.tuple.html">in the standard library
documentation</a>.</p>

<h1 id='functions' class='section-header'><a href='#functions'>Functions</a></h1>
<p>Functions also have a type! They look like this:</p>
<span class='rusttest'>fn main() {
    fn foo(x: i32) -&gt; i32 { x }
    
    let x: fn(i32) -&gt; i32 = foo;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> { <span class='ident'>x</span> }

<span class='kw'>let</span> <span class='ident'>x</span>: <span class='kw'>fn</span>(<span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>foo</span>;</pre>

<p>In this case, <code>x</code> is a â€˜function pointerâ€™ to a function that takes an <code>i32</code> and
returns an <code>i32</code>.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>