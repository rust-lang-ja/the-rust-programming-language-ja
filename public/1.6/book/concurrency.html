<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Concurrency</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル: 推測ゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> 生存期</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> 可変性</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレイトとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`と`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ無し型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a class='active' href='concurrency.html'><b>5.6.</b> 並行</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> イントリンシック</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語事項</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンク</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Concurrency</h1>
    <p>Concurrency and parallelism are incredibly important topics in computer
science, and are also a hot topic in industry today. Computers are gaining more
and more cores, yet many programmers aren&#39;t prepared to fully utilize them.</p>

<p>Rust&#39;s memory safety features also apply to its concurrency story too. Even
concurrent Rust programs must be memory safe, having no data races. Rust&#39;s type
system is up to the task, and gives you powerful ways to reason about
concurrent code at compile time.</p>

<p>Before we talk about the concurrency features that come with Rust, it&#39;s important
to understand something: Rust is low-level enough that the vast majority of
this is provided by the standard library, not by the language. This means that
if you don&#39;t like some aspect of the way Rust handles concurrency, you can
implement an alternative way of doing things.
<a href="https://github.com/carllerche/mio">mio</a> is a real-world example of this
principle in action.</p>

<h2 id='background-send-and-sync' class='section-header'><a href='#background-send-and-sync'>Background: <code>Send</code> and <code>Sync</code></a></h2>
<p>Concurrency is difficult to reason about. In Rust, we have a strong, static
type system to help us reason about our code. As such, Rust gives us two traits
to help us make sense of code that can possibly be concurrent.</p>

<h3 id='send' class='section-header'><a href='#send'><code>Send</code></a></h3>
<p>The first trait we&#39;re going to talk about is
<a href="../std/marker/trait.Send.html"><code>Send</code></a>. When a type <code>T</code> implements <code>Send</code>, it
indicates that something of this type is able to have ownership transferred
safely between threads.</p>

<p>This is important to enforce certain restrictions. For example, if we have a
channel connecting two threads, we would want to be able to send some data
down the channel and to the other thread. Therefore, we&#39;d ensure that <code>Send</code> was
implemented for that type.</p>

<p>In the opposite way, if we were wrapping a library with <a href="ffi.html">FFI</a> that isn&#39;t
threadsafe, we wouldn&#39;t want to implement <code>Send</code>, and so the compiler will help
us enforce that it can&#39;t leave the current thread.</p>

<h3 id='sync' class='section-header'><a href='#sync'><code>Sync</code></a></h3>
<p>The second of these traits is called <a href="../std/marker/trait.Sync.html"><code>Sync</code></a>.
When a type <code>T</code> implements <code>Sync</code>, it indicates that something
of this type has no possibility of introducing memory unsafety when used from
multiple threads concurrently through shared references. This implies that
types which don&#39;t have <a href="mutability.html">interior mutability</a> are inherently
<code>Sync</code>, which includes simple primitive types (like <code>u8</code>) and aggregate types
containing them.</p>

<p>For sharing references across threads, Rust provides a wrapper type called
<code>Arc&lt;T&gt;</code>. <code>Arc&lt;T&gt;</code> implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements
both <code>Send</code> and <code>Sync</code>. For example, an object of type <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> cannot
be transferred across threads because
<a href="choosing-your-guarantees.html#refcellt"><code>RefCell</code></a> does not implement
<code>Sync</code>, consequently <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> would not implement <code>Send</code>.</p>

<p>These two traits allow you to use the type system to make strong guarantees
about the properties of your code under concurrency. Before we demonstrate
why, we need to learn how to create a concurrent Rust program in the first
place!</p>

<h2 id='threads' class='section-header'><a href='#threads'>Threads</a></h2>
<p>Rust&#39;s standard library provides a library for threads, which allow you to
run Rust code in parallel. Here&#39;s a basic example of using <code>std::thread</code>:</p>
<span class='rusttest'>use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hello from a thread!&quot;);
    });
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='op'>||</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello from a thread!&quot;</span>);
    });
}</pre>

<p>The <code>thread::spawn()</code> method accepts a <a href="closures.html">closure</a>, which is executed in a
new thread. It returns a handle to the thread, that can be used to
wait for the child thread to finish and extract its result:</p>
<span class='rusttest'>use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        &quot;Hello from a thread!&quot;
    });

    println!(&quot;{}&quot;, handle.join().unwrap());
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='op'>||</span> {
        <span class='string'>&quot;Hello from a thread!&quot;</span>
    });

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>handle</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>());
}</pre>

<p>Many languages have the ability to execute threads, but it&#39;s wildly unsafe.
There are entire books about how to prevent errors that occur from shared
mutable state. Rust helps out with its type system here as well, by preventing
data races at compile time. Let&#39;s talk about how you actually share things
between threads.</p>

<h2 id='safe-shared-mutable-state' class='section-header'><a href='#safe-shared-mutable-state'>Safe Shared Mutable State</a></h2>
<p>Due to Rust&#39;s type system, we have a concept that sounds like a lie: &quot;safe
shared mutable state.&quot; Many programmers agree that shared mutable state is
very, very bad.</p>

<p>Someone once said this:</p>

<blockquote>
<p>Shared mutable state is the root of all evil. Most languages attempt to deal
with this problem through the &#39;mutable&#39; part, but Rust deals with it by
solving the &#39;shared&#39; part.</p>
</blockquote>

<p>The same <a href="ownership.html">ownership system</a> that helps prevent using pointers
incorrectly also helps rule out data races, one of the worst kinds of
concurrency bugs.</p>

<p>As an example, here is a Rust program that would have a data race in many
languages. It will not compile:</p>
<span class='rusttest'>use std::thread;
use std::time::Duration;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>3</span> {
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
        });
    }

    <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>50</span>));
}</pre>

<p>This gives us an error:</p>

<pre><code class="language-text">8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
</code></pre>

<p>Rust knows this wouldn&#39;t be safe! If we had a reference to <code>data</code> in each
thread, and the thread takes ownership of the reference, we&#39;d have three
owners!</p>

<p>So, we need some type that lets us have more than one reference to a value and
that we can share between threads, that is it must implement <code>Sync</code>.</p>

<p>We&#39;ll use <code>Arc&lt;T&gt;</code>, Rust&#39;s standard atomic reference count type, which
wraps a value up with some extra runtime bookkeeping which allows us to
share the ownership of the value between multiple references at the same time.</p>

<p>The bookkeeping consists of a count of how many of these references exist to
the value, hence the reference count part of the name.</p>

<p>The Atomic part means <code>Arc&lt;T&gt;</code> can safely be accessed from multiple threads.
To do this the compiler guarantees that mutations of the internal count use
indivisible operations which can&#39;t have data races.</p>
<span class='rusttest'>use std::thread;
use std::sync::Arc;
use std::time::Duration;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Arc</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]);

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>3</span> {
        <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>clone</span>();
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
        });
    }

    <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>50</span>));
}</pre>

<p>We now call <code>clone()</code> on our <code>Arc&lt;T&gt;</code>, which increases the internal count.
This handle is then moved into the new thread.</p>

<p>And... still gives us an error.</p>

<pre><code class="language-text">&lt;anon&gt;:11:24 error: cannot borrow immutable borrowed content as mutable
&lt;anon&gt;:11                    data[i] += 1;
                             ^~~~
</code></pre>

<p><code>Arc&lt;T&gt;</code> assumes one more property about its contents to ensure that it is safe
to share across threads: it assumes its contents are <code>Sync</code>. This is true for
our value if it&#39;s immutable, but we want to be able to mutate it, so we need
something else to persuade the borrow checker we know what we&#39;re doing.</p>

<p>It looks like we need some type that allows us to safely mutate a shared value,
for example a type that can ensure only one thread at a time is able to
mutate the value inside it at any one time.</p>

<p>For that, we can use the <code>Mutex&lt;T&gt;</code> type!</p>

<p>Here&#39;s the working version:</p>
<span class='rusttest'>use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Arc</span>, <span class='ident'>Mutex</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>]));

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>3</span> {
        <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>clone</span>();
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
            <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
        });
    }

    <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>50</span>));
}</pre>

<p>Note that the value of <code>i</code> is bound (copied) to the closure and not shared
among the threads.</p>

<p>Also note that <a href="../std/sync/struct.Mutex.html#method.lock"><code>lock</code></a> method of
<a href="../std/sync/struct.Mutex.html"><code>Mutex</code></a> has this signature:</p>
<span class='rusttest'>fn main() {
    fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>lock</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>LockResult</span><span class='op'>&lt;</span><span class='ident'>MutexGuard</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span></pre>

<p>and because <code>Send</code> is not implemented for <code>MutexGuard&lt;T&gt;</code>, the guard cannot
cross thread boundaries, ensuring thread-locality of lock acquire and release.</p>

<p>Let&#39;s examine the body of the thread more closely:</p>
<span class='rusttest'>use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    for i in 0..3 {
        let data = data.clone();
thread::spawn(move || {
    let mut data = data.lock().unwrap();
    data[i] += 1;
});
    }
    thread::sleep(Duration::from_millis(50));
}
</span><pre class='rust rust-example-rendered'>
<span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='ident'>data</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='number'>1</span>;
});</pre>

<p>First, we call <code>lock()</code>, which acquires the mutex&#39;s lock. Because this may fail,
it returns an <code>Result&lt;T, E&gt;</code>, and because this is just an example, we <code>unwrap()</code>
it to get a reference to the data. Real code would have more robust error handling
here. We&#39;re then free to mutate it, since we have the lock.</p>

<p>Lastly, while the threads are running, we wait on a short timer. But
this is not ideal: we may have picked a reasonable amount of time to
wait but it&#39;s more likely we&#39;ll either be waiting longer than
necessary or not long enough, depending on just how much time the
threads actually take to finish computing when the program runs.</p>

<p>A more precise alternative to the timer would be to use one of the
mechanisms provided by the Rust standard library for synchronizing
threads with each other. Let&#39;s talk about one of them: channels.</p>

<h2 id='channels' class='section-header'><a href='#channels'>Channels</a></h2>
<p>Here&#39;s a version of our code that uses channels for synchronization, rather
than waiting for a specific time:</p>
<span class='rusttest'>use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc;

fn main() {
    let data = Arc::new(Mutex::new(0));

    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let (data, tx) = (data.clone(), tx.clone());

        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            *data += 1;

            tx.send(()).unwrap();
        });
    }

    for _ in 0..10 {
        rx.recv().unwrap();
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Arc</span>, <span class='ident'>Mutex</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>mpsc</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Mutex</span>::<span class='ident'>new</span>(<span class='number'>0</span>));

    <span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>mpsc</span>::<span class='ident'>channel</span>();

    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>let</span> (<span class='ident'>data</span>, <span class='ident'>tx</span>) <span class='op'>=</span> (<span class='ident'>data</span>.<span class='ident'>clone</span>(), <span class='ident'>tx</span>.<span class='ident'>clone</span>());

        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>data</span>.<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
            <span class='op'>*</span><span class='ident'>data</span> <span class='op'>+=</span> <span class='number'>1</span>;

            <span class='ident'>tx</span>.<span class='ident'>send</span>(()).<span class='ident'>unwrap</span>();
        });
    }

    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='ident'>rx</span>.<span class='ident'>recv</span>().<span class='ident'>unwrap</span>();
    }
}</pre>

<p>We use the <code>mpsc::channel()</code> method to construct a new channel. We <code>send</code>
a simple <code>()</code> down the channel, and then wait for ten of them to come back.</p>

<p>While this channel is sending a generic signal, we can send any data that
is <code>Send</code> over the channel!</p>
<span class='rusttest'>use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    for i in 0..10 {
        let tx = tx.clone();

        thread::spawn(move || {
            let answer = i * i;

            tx.send(answer).unwrap();
        });
    }

    for _ in 0..10 {
        println!(&quot;{}&quot;, rx.recv().unwrap());
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>mpsc</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>mpsc</span>::<span class='ident'>channel</span>();

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>let</span> <span class='ident'>tx</span> <span class='op'>=</span> <span class='ident'>tx</span>.<span class='ident'>clone</span>();

        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='kw'>let</span> <span class='ident'>answer</span> <span class='op'>=</span> <span class='ident'>i</span> <span class='op'>*</span> <span class='ident'>i</span>;

            <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='ident'>answer</span>).<span class='ident'>unwrap</span>();
        });
    }

    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>rx</span>.<span class='ident'>recv</span>().<span class='ident'>unwrap</span>());
    }
}</pre>

<p>Here we create 10 threads, asking each to calculate the square of a number (<code>i</code>
at the time of <code>spawn()</code>), and then <code>send()</code> back the answer over the channel.</p>

<h2 id='panics' class='section-header'><a href='#panics'>Panics</a></h2>
<p>A <code>panic!</code> will crash the currently executing thread. You can use Rust&#39;s
threads as a simple isolation mechanism:</p>
<span class='rusttest'>fn main() {
    use std::thread;
    
    let handle = thread::spawn(move || {
        panic!(&quot;oops!&quot;);
    });
    
    let result = handle.join();
    
    assert!(result.is_err());
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>let</span> <span class='ident'>handle</span> <span class='op'>=</span> <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
    <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;oops!&quot;</span>);
});

<span class='kw'>let</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='ident'>handle</span>.<span class='ident'>join</span>();

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>result</span>.<span class='ident'>is_err</span>());</pre>

<p><code>Thread.join()</code> gives us a <code>Result</code> back, which allows us to check if the thread
has panicked or not.</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>