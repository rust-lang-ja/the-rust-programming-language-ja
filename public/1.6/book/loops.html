<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Loops</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 晩餐する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a class='active' href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> 生存期</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> 可変性</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレイトとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`と`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ無し型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> イントリンシック</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語事項</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンク</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Loops</h1>
    <p>Rust currently provides three approaches to performing some kind of iterative activity. They are: <code>loop</code>, <code>while</code> and <code>for</code>. Each approach has its own set of uses.</p>

<h2 id='loop' class='section-header'><a href='#loop'>loop</a></h2>
<p>The infinite <code>loop</code> is the simplest form of loop available in Rust. Using the keyword <code>loop</code>, Rust provides a way to loop indefinitely until some terminating statement is reached. Rust&#39;s infinite <code>loop</code>s look like this:</p>
<span class='rusttest'>fn main() {
    loop {
        println!(&quot;Loop forever!&quot;);
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>loop</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Loop forever!&quot;</span>);
}</pre>

<h2 id='while' class='section-header'><a href='#while'>while</a></h2>
<p>Rust also has a <code>while</code> loop. It looks like this:</p>
<span class='rusttest'>fn main() {
    let mut x = 5; // mut x: i32
    let mut done = false; // mut done: bool
    
    while !done {
        x += x - 3;
    
        println!(&quot;{}&quot;, x);
    
        if x % 5 == 0 {
            done = true;
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>; <span class='comment'>// mut x: i32</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>false</span>; <span class='comment'>// mut done: bool</span>

<span class='kw'>while</span> <span class='op'>!</span><span class='ident'>done</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);

    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> {
        <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>true</span>;
    }
}</pre>

<p><code>while</code> loops are the correct choice when you’re not sure how many times
you need to loop.</p>

<p>If you need an infinite loop, you may be tempted to write this:</p>
<span class='rusttest'>fn main() {
    while true {
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>while</span> <span class='boolval'>true</span> {</pre>

<p>However, <code>loop</code> is far better suited to handle this case:</p>
<span class='rusttest'>fn main() {
    loop {
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>loop</span> {</pre>

<p>Rust’s control-flow analysis treats this construct differently than a <code>while true</code>, since we know that it will always loop. In general, the more information
we can give to the compiler, the better it can do with safety and code
generation, so you should always prefer <code>loop</code> when you plan to loop
infinitely.</p>

<h2 id='for' class='section-header'><a href='#for'>for</a></h2>
<p>The <code>for</code> loop is used to loop a particular number of times. Rust’s <code>for</code> loops
work a bit differently than in other systems languages, however. Rust’s <code>for</code>
loop doesn’t look like this “C-style” <code>for</code> loop:</p>

<pre><code class="language-c">for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
</code></pre>

<p>Instead, it looks like this:</p>
<span class='rusttest'>fn main() {
    for x in 0..10 {
        println!(&quot;{}&quot;, x); // x: i32
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); <span class='comment'>// x: i32</span>
}</pre>

<p>In slightly more abstract terms,</p>
<span class='rusttest'>fn main() {
    for var in expression {
        code
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>var</span> <span class='kw'>in</span> <span class='ident'>expression</span> {
    <span class='ident'>code</span>
}</pre>

<p>The expression is an item that can be converted into an <a href="iterators.html">iterator</a> using
<a href="../std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>. The iterator gives back a series of elements. Each element is
one iteration of the loop. That value is then bound to the name <code>var</code>, which is
valid for the loop body. Once the body is over, the next value is fetched from
the iterator, and we loop another time. When there are no more values, the <code>for</code>
loop is over.</p>

<p>In our example, <code>0..10</code> is an expression that takes a start and an end position,
and gives an iterator over those values. The upper bound is exclusive, though,
so our loop will print <code>0</code> through <code>9</code>, not <code>10</code>.</p>

<p>Rust does not have the “C-style” <code>for</code> loop on purpose. Manually controlling
each element of the loop is complicated and error prone, even for experienced C
developers.</p>

<h3 id='enumerate' class='section-header'><a href='#enumerate'>Enumerate</a></h3>
<p>When you need to keep track of how many times you already looped, you can use the <code>.enumerate()</code> function.</p>

<h4 id='on-ranges' class='section-header'><a href='#on-ranges'>On ranges:</a></h4><span class='rusttest'>fn main() {
    for (i,j) in (5..10).enumerate() {
        println!(&quot;i = {} and j = {}&quot;, i, j);
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> (<span class='ident'>i</span>,<span class='ident'>j</span>) <span class='kw'>in</span> (<span class='number'>5</span>..<span class='number'>10</span>).<span class='ident'>enumerate</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;i = {} and j = {}&quot;</span>, <span class='ident'>i</span>, <span class='ident'>j</span>);
}</pre>

<p>Outputs:</p>

<pre><code class="language-text">i = 0 and j = 5
i = 1 and j = 6
i = 2 and j = 7
i = 3 and j = 8
i = 4 and j = 9
</code></pre>

<p>Don&#39;t forget to add the parentheses around the range.</p>

<h4 id='on-iterators' class='section-header'><a href='#on-iterators'>On iterators:</a></h4><span class='rusttest'>fn main() {
    let lines = &quot;hello\nworld&quot;.lines();
    for (linenumber, line) in lines.enumerate() {
        println!(&quot;{}: {}&quot;, linenumber, line);
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> (<span class='ident'>linenumber</span>, <span class='ident'>line</span>) <span class='kw'>in</span> <span class='ident'>lines</span>.<span class='ident'>enumerate</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}: {}&quot;</span>, <span class='ident'>linenumber</span>, <span class='ident'>line</span>);
}</pre>

<p>Outputs:</p>

<pre><code class="language-text">0: Content of line one
1: Content of line two
2: Content of line three
3: Content of line four
</code></pre>

<h2 id='ending-iteration-early' class='section-header'><a href='#ending-iteration-early'>Ending iteration early</a></h2>
<p>Let’s take a look at that <code>while</code> loop we had earlier:</p>
<span class='rusttest'>fn main() {
    let mut x = 5;
    let mut done = false;
    
    while !done {
        x += x - 3;
    
        println!(&quot;{}&quot;, x);
    
        if x % 5 == 0 {
            done = true;
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>false</span>;

<span class='kw'>while</span> <span class='op'>!</span><span class='ident'>done</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);

    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> {
        <span class='ident'>done</span> <span class='op'>=</span> <span class='boolval'>true</span>;
    }
}</pre>

<p>We had to keep a dedicated <code>mut</code> boolean variable binding, <code>done</code>, to know
when we should exit out of the loop. Rust has two keywords to help us with
modifying iteration: <code>break</code> and <code>continue</code>.</p>

<p>In this case, we can write the loop in a better way with <code>break</code>:</p>
<span class='rusttest'>fn main() {
    let mut x = 5;
    
    loop {
        x += x - 3;
    
        println!(&quot;{}&quot;, x);
    
        if x % 5 == 0 { break; }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;

<span class='kw'>loop</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);

    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>break</span>; }
}</pre>

<p>We now loop forever with <code>loop</code> and use <code>break</code> to break out early. Issuing an explicit <code>return</code> statement will also serve to terminate the loop early.</p>

<p><code>continue</code> is similar, but instead of ending the loop, goes to the next
iteration. This will only print the odd numbers:</p>
<span class='rusttest'>fn main() {
    for x in 0..10 {
        if x % 2 == 0 { continue; }
    
        println!(&quot;{}&quot;, x);
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>continue</span>; }

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}</pre>

<h2 id='loop-labels' class='section-header'><a href='#loop-labels'>Loop labels</a></h2>
<p>You may also encounter situations where you have nested loops and need to
specify which one your <code>break</code> or <code>continue</code> statement is for. Like most
other languages, by default a <code>break</code> or <code>continue</code> will apply to innermost
loop. In a situation where you would like to a <code>break</code> or <code>continue</code> for one
of the outer loops, you can use labels to specify which loop the <code>break</code> or
 <code>continue</code> statement applies to. This will only print when both <code>x</code> and <code>y</code> are
 odd:</p>
<span class='rusttest'>fn main() {
    &#39;outer: for x in 0..10 {
        &#39;inner: for y in 0..10 {
            if x % 2 == 0 { continue &#39;outer; } // continues the loop over x
            if y % 2 == 0 { continue &#39;inner; } // continues the loop over y
            println!(&quot;x: {}, y: {}&quot;, x, y);
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='lifetime'>&#39;outer</span>: <span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
    <span class='lifetime'>&#39;inner</span>: <span class='kw'>for</span> <span class='ident'>y</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='number'>10</span> {
        <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>continue</span> <span class='lifetime'>&#39;outer</span>; } <span class='comment'>// continues the loop over x</span>
        <span class='kw'>if</span> <span class='ident'>y</span> <span class='op'>%</span> <span class='number'>2</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>continue</span> <span class='lifetime'>&#39;inner</span>; } <span class='comment'>// continues the loop over y</span>
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x: {}, y: {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
    }
}</pre>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>